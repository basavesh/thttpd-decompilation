void _init()
{
    if (__gmon_start__ != 0)
        __gmon_start__();
}

int64_t sub_5020()
{
    int64_t var_8 = data_19008;
    /* jump -> data_19010 */
}

char* getenv(char const* name)
{
    /* tailcall */
    return getenv(name);
}

int64_t sub_5036()
{
    int64_t var_8 = 0;
    /* tailcall */
    return sub_5020();
}

void free(void* ptr)
{
    /* tailcall */
    return free(ptr);
}

int64_t sub_5046()
{
    int64_t var_8 = 1;
    /* tailcall */
    return sub_5020();
}

int32_t strcasecmp(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strcasecmp(arg1, arg2);
}

int64_t sub_5056()
{
    int64_t var_8 = 2;
    /* tailcall */
    return sub_5020();
}

void closelog()
{
    /* tailcall */
    return closelog();
}

int64_t sub_5066()
{
    int64_t var_8 = 3;
    /* tailcall */
    return sub_5020();
}

struct tm* localtime(time_t* t)
{
    /* tailcall */
    return localtime(t);
}

int64_t sub_5076()
{
    int64_t var_8 = 4;
    /* tailcall */
    return sub_5020();
}

void abort() __noreturn
{
    /* tailcall */
    return abort();
}

int64_t sub_5086()
{
    int64_t var_8 = 5;
    /* tailcall */
    return sub_5020();
}

int32_t* __errno_location()
{
    /* tailcall */
    return __errno_location();
}

int64_t sub_5096()
{
    int64_t var_8 = 6;
    /* tailcall */
    return sub_5020();
}

char* strncpy(char* arg1, char const* arg2, uint64_t arg3)
{
    /* tailcall */
    return strncpy(arg1, arg2, arg3);
}

int64_t sub_50a6()
{
    int64_t var_8 = 7;
    /* tailcall */
    return sub_5020();
}

int32_t strncmp(char const* arg1, char const* arg2, uint64_t arg3)
{
    /* tailcall */
    return strncmp(arg1, arg2, arg3);
}

int64_t sub_50b6()
{
    int64_t var_8 = 8;
    /* tailcall */
    return sub_5020();
}

void _exit(int32_t status) __noreturn
{
    /* tailcall */
    return _exit(status);
}

int64_t sub_50c6()
{
    int64_t var_8 = 9;
    /* tailcall */
    return sub_5020();
}

char* strcpy(char* arg1, char const* arg2)
{
    /* tailcall */
    return strcpy(arg1, arg2);
}

int64_t sub_50d6()
{
    int64_t var_8 = 0xa;
    /* tailcall */
    return sub_5020();
}

int64_t chroot()
{
    /* tailcall */
    return chroot();
}

int64_t sub_50e6()
{
    int64_t var_8 = 0xb;
    /* tailcall */
    return sub_5020();
}

ssize_t writev(int32_t fd, struct iovec* iov, int32_t iovcnt)
{
    /* tailcall */
    return writev(fd, iov, iovcnt);
}

int64_t sub_50f6()
{
    int64_t var_8 = 0xc;
    /* tailcall */
    return sub_5020();
}

int32_t puts(char const* str)
{
    /* tailcall */
    return puts(str);
}

int64_t sub_5106()
{
    int64_t var_8 = 0xd;
    /* tailcall */
    return sub_5020();
}

void qsort(void* b, uint64_t n, uint64_t s, __compar_fn_t cmp)
{
    /* tailcall */
    return qsort(b, n, s, cmp);
}

int64_t sub_5116()
{
    int64_t var_8 = 0xe;
    /* tailcall */
    return sub_5020();
}

uint64_t fread(void* buf, uint64_t size, uint64_t count, FILE* fp)
{
    /* tailcall */
    return fread(buf, size, count, fp);
}

int64_t sub_5126()
{
    int64_t var_8 = 0xf;
    /* tailcall */
    return sub_5020();
}

int32_t vsnprintf(char* string, uint64_t maxlen, char const* format, struct __va_list_tag* args)
{
    /* tailcall */
    return vsnprintf(string, maxlen, format, args);
}

int64_t sub_5136()
{
    int64_t var_8 = 0x10;
    /* tailcall */
    return sub_5020();
}

int64_t setsockopt()
{
    /* tailcall */
    return setsockopt();
}

int64_t sub_5146()
{
    int64_t var_8 = 0x11;
    /* tailcall */
    return sub_5020();
}

int64_t readlink()
{
    /* tailcall */
    return readlink();
}

int64_t sub_5156()
{
    int64_t var_8 = 0x12;
    /* tailcall */
    return sub_5020();
}

int32_t fcntl(int32_t fd, int32_t cmd, ...)
{
    /* tailcall */
    return fcntl();
}

int64_t sub_5166()
{
    int64_t var_8 = 0x13;
    /* tailcall */
    return sub_5020();
}

ssize_t write(int32_t fd, void const* buf, uint64_t nbytes)
{
    /* tailcall */
    return write(fd, buf, nbytes);
}

int64_t sub_5176()
{
    int64_t var_8 = 0x14;
    /* tailcall */
    return sub_5020();
}

int64_t getpid()
{
    /* tailcall */
    return getpid();
}

int64_t sub_5186()
{
    int64_t var_8 = 0x15;
    /* tailcall */
    return sub_5020();
}

int32_t fclose(FILE* fp)
{
    /* tailcall */
    return fclose(fp);
}

int64_t sub_5196()
{
    int64_t var_8 = 0x16;
    /* tailcall */
    return sub_5020();
}

DIR* opendir(char const* name)
{
    /* tailcall */
    return opendir(name);
}

int64_t sub_51a6()
{
    int64_t var_8 = 0x17;
    /* tailcall */
    return sub_5020();
}

char* ctime(time_t* t)
{
    /* tailcall */
    return ctime(t);
}

int64_t sub_51b6()
{
    int64_t var_8 = 0x18;
    /* tailcall */
    return sub_5020();
}

int64_t shutdown()
{
    /* tailcall */
    return shutdown();
}

int64_t sub_51c6()
{
    int64_t var_8 = 0x19;
    /* tailcall */
    return sub_5020();
}

uint64_t strlen(char const* arg1)
{
    /* tailcall */
    return strlen(arg1);
}

int64_t sub_51d6()
{
    int64_t var_8 = 0x1a;
    /* tailcall */
    return sub_5020();
}

int64_t chdir()
{
    /* tailcall */
    return chdir();
}

int64_t sub_51e6()
{
    int64_t var_8 = 0x1b;
    /* tailcall */
    return sub_5020();
}

int64_t getuid()
{
    /* tailcall */
    return getuid();
}

int64_t sub_51f6()
{
    int64_t var_8 = 0x1c;
    /* tailcall */
    return sub_5020();
}

int64_t mmap(void* addr, uint64_t len, int32_t prot, int32_t flags, int32_t fd, off64_t offset)
{
    /* tailcall */
    return mmap(addr, len, prot, flags, fd, offset);
}

int64_t sub_5206()
{
    int64_t var_8 = 0x1d;
    /* tailcall */
    return sub_5020();
}

int64_t dup2()
{
    /* tailcall */
    return dup2();
}

int64_t sub_5216()
{
    int64_t var_8 = 0x1e;
    /* tailcall */
    return sub_5020();
}

char* strchr(char const* arg1, int32_t arg2)
{
    /* tailcall */
    return strchr(arg1, arg2);
}

int64_t sub_5226()
{
    int64_t var_8 = 0x1f;
    /* tailcall */
    return sub_5020();
}

int32_t snprintf(char* s, uint64_t maxlen, char const* format, ...)
{
    /* tailcall */
    return snprintf();
}

int64_t sub_5236()
{
    int64_t var_8 = 0x20;
    /* tailcall */
    return sub_5020();
}

char const* gai_strerror(int32_t code)
{
    /* tailcall */
    return gai_strerror(code);
}

int64_t sub_5246()
{
    int64_t var_8 = 0x21;
    /* tailcall */
    return sub_5020();
}

char* strrchr(char const* arg1, int32_t arg2)
{
    /* tailcall */
    return strrchr(arg1, arg2);
}

int64_t sub_5256()
{
    int64_t var_8 = 0x22;
    /* tailcall */
    return sub_5020();
}

int32_t gettimeofday(struct timeval* arg1, void* arg2)
{
    /* tailcall */
    return gettimeofday(arg1, arg2);
}

int64_t sub_5266()
{
    int64_t var_8 = 0x23;
    /* tailcall */
    return sub_5020();
}

int64_t memset(void* arg1, int32_t arg2, uint64_t arg3)
{
    /* tailcall */
    return memset(arg1, arg2, arg3);
}

int64_t sub_5276()
{
    int64_t var_8 = 0x24;
    /* tailcall */
    return sub_5020();
}

char* getcwd(char* buf, uint64_t size)
{
    /* tailcall */
    return getcwd(buf, size);
}

int64_t sub_5286()
{
    int64_t var_8 = 0x25;
    /* tailcall */
    return sub_5020();
}

int64_t alarm()
{
    /* tailcall */
    return alarm();
}

int64_t sub_5296()
{
    int64_t var_8 = 0x26;
    /* tailcall */
    return sub_5020();
}

int32_t close(int32_t fd)
{
    /* tailcall */
    return close(fd);
}

int64_t sub_52a6()
{
    int64_t var_8 = 0x27;
    /* tailcall */
    return sub_5020();
}

int32_t setgroups(uint64_t n, gid_t* groups)
{
    /* tailcall */
    return setgroups(n, groups);
}

int64_t sub_52b6()
{
    int64_t var_8 = 0x28;
    /* tailcall */
    return sub_5020();
}

int64_t pipe()
{
    /* tailcall */
    return pipe();
}

int64_t sub_52c6()
{
    int64_t var_8 = 0x29;
    /* tailcall */
    return sub_5020();
}

int32_t getnameinfo(struct sockaddr* sa, socklen_t addrlen, char* host, socklen_t hostlen, char* serv, socklen_t servlen, int32_t flags)
{
    /* tailcall */
    return getnameinfo(sa, addrlen, host, hostlen, serv, servlen, flags);
}

int64_t sub_52d6()
{
    int64_t var_8 = 0x2a;
    /* tailcall */
    return sub_5020();
}

int64_t setsid()
{
    /* tailcall */
    return setsid();
}

int64_t sub_52e6()
{
    int64_t var_8 = 0x2b;
    /* tailcall */
    return sub_5020();
}

uint64_t strspn(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strspn(arg1, arg2);
}

int64_t sub_52f6()
{
    int64_t var_8 = 0x2c;
    /* tailcall */
    return sub_5020();
}

int32_t closedir(DIR* dirp)
{
    /* tailcall */
    return closedir(dirp);
}

int64_t sub_5306()
{
    int64_t var_8 = 0x2d;
    /* tailcall */
    return sub_5020();
}

uint64_t strcspn(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strcspn(arg1, arg2);
}

int64_t sub_5316()
{
    int64_t var_8 = 0x2e;
    /* tailcall */
    return sub_5020();
}

int64_t memchr(void const* arg1, int32_t arg2, uint64_t arg3)
{
    /* tailcall */
    return memchr(arg1, arg2, arg3);
}

int64_t sub_5326()
{
    int64_t var_8 = 0x2f;
    /* tailcall */
    return sub_5020();
}

ssize_t read(int32_t fd, void* buf, uint64_t nbytes)
{
    /* tailcall */
    return read(fd, buf, nbytes);
}

int64_t sub_5336()
{
    int64_t var_8 = 0x30;
    /* tailcall */
    return sub_5020();
}

int64_t lstat()
{
    /* tailcall */
    return lstat();
}

int64_t sub_5346()
{
    int64_t var_8 = 0x31;
    /* tailcall */
    return sub_5020();
}

char* fgets(char* buf, int32_t n, FILE* fp)
{
    /* tailcall */
    return fgets(buf, n, fp);
}

int64_t sub_5356()
{
    int64_t var_8 = 0x32;
    /* tailcall */
    return sub_5020();
}

int64_t execve()
{
    /* tailcall */
    return execve();
}

int64_t sub_5366()
{
    int64_t var_8 = 0x33;
    /* tailcall */
    return sub_5020();
}

int32_t strcmp(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strcmp(arg1, arg2);
}

int64_t sub_5376()
{
    int64_t var_8 = 0x34;
    /* tailcall */
    return sub_5020();
}

int64_t strtoll(char const* nptr, char** endptr, int32_t base)
{
    /* tailcall */
    return strtoll(nptr, endptr, base);
}

int64_t sub_5386()
{
    int64_t var_8 = 0x35;
    /* tailcall */
    return sub_5020();
}

struct passwd* getpwnam(char const* name)
{
    /* tailcall */
    return getpwnam(name);
}

int64_t sub_5396()
{
    int64_t var_8 = 0x36;
    /* tailcall */
    return sub_5020();
}

int32_t fprintf(FILE* stream, char const* format, ...)
{
    /* tailcall */
    return fprintf();
}

int64_t sub_53a6()
{
    int64_t var_8 = 0x37;
    /* tailcall */
    return sub_5020();
}

int64_t stat()
{
    /* tailcall */
    return stat();
}

int64_t sub_53b6()
{
    int64_t var_8 = 0x38;
    /* tailcall */
    return sub_5020();
}

int64_t strtol(char const* nptr, char** endptr, int32_t base)
{
    /* tailcall */
    return strtol(nptr, endptr, base);
}

int64_t sub_53c6()
{
    int64_t var_8 = 0x39;
    /* tailcall */
    return sub_5020();
}

int64_t memcpy(void* arg1, void const* arg2, uint64_t arg3)
{
    /* tailcall */
    return memcpy(arg1, arg2, arg3);
}

int64_t sub_53d6()
{
    int64_t var_8 = 0x3a;
    /* tailcall */
    return sub_5020();
}

void tzset()
{
    /* tailcall */
    return tzset();
}

int64_t sub_53e6()
{
    int64_t var_8 = 0x3b;
    /* tailcall */
    return sub_5020();
}

int64_t kill()
{
    /* tailcall */
    return kill();
}

int64_t sub_53f6()
{
    int64_t var_8 = 0x3c;
    /* tailcall */
    return sub_5020();
}

time_t time(time_t* arg1)
{
    /* tailcall */
    return time(arg1);
}

int64_t sub_5406()
{
    int64_t var_8 = 0x3d;
    /* tailcall */
    return sub_5020();
}

int32_t fileno(FILE* fp)
{
    /* tailcall */
    return fileno(fp);
}

int64_t sub_5416()
{
    int64_t var_8 = 0x3e;
    /* tailcall */
    return sub_5020();
}

struct dirent64* readdir(DIR* dirp)
{
    /* tailcall */
    return readdir(dirp);
}

int64_t sub_5426()
{
    int64_t var_8 = 0x3f;
    /* tailcall */
    return sub_5020();
}

int64_t malloc(size_t n)
{
    /* tailcall */
    return malloc(n);
}

int64_t sub_5436()
{
    int64_t var_8 = 0x40;
    /* tailcall */
    return sub_5020();
}

int32_t strncasecmp(char const* arg1, char const* arg2, uint64_t arg3)
{
    /* tailcall */
    return strncasecmp(arg1, arg2, arg3);
}

int64_t sub_5446()
{
    int64_t var_8 = 0x41;
    /* tailcall */
    return sub_5020();
}

int32_t fflush(FILE* fp)
{
    /* tailcall */
    return fflush(fp);
}

int64_t sub_5456()
{
    int64_t var_8 = 0x42;
    /* tailcall */
    return sub_5020();
}

int32_t nice(int32_t incr)
{
    /* tailcall */
    return nice(incr);
}

int64_t sub_5466()
{
    int64_t var_8 = 0x43;
    /* tailcall */
    return sub_5020();
}

int32_t __isoc99_sscanf(char const* s, char const* format, ...)
{
    /* tailcall */
    return __isoc99_sscanf();
}

int64_t sub_5476()
{
    int64_t var_8 = 0x44;
    /* tailcall */
    return sub_5020();
}

void syslog(int32_t pri, char const* fmt, ...)
{
    /* tailcall */
    return syslog();
}

int64_t sub_5486()
{
    int64_t var_8 = 0x45;
    /* tailcall */
    return sub_5020();
}

int64_t listen()
{
    /* tailcall */
    return listen();
}

int64_t sub_5496()
{
    int64_t var_8 = 0x46;
    /* tailcall */
    return sub_5020();
}

int32_t daemon(int32_t nochdir, int32_t noclose)
{
    /* tailcall */
    return daemon(nochdir, noclose);
}

int64_t sub_54a6()
{
    int64_t var_8 = 0x47;
    /* tailcall */
    return sub_5020();
}

char* strpbrk(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strpbrk(arg1, arg2);
}

int64_t sub_54b6()
{
    int64_t var_8 = 0x48;
    /* tailcall */
    return sub_5020();
}

int32_t setrlimit(enum __rlimit_resource resource, struct rlimit64* rlimits)
{
    /* tailcall */
    return setrlimit(resource, rlimits);
}

int64_t sub_54c6()
{
    int64_t var_8 = 0x49;
    /* tailcall */
    return sub_5020();
}

int64_t realloc(void* ptr, size_t n)
{
    /* tailcall */
    return realloc(ptr, n);
}

int64_t sub_54d6()
{
    int64_t var_8 = 0x4a;
    /* tailcall */
    return sub_5020();
}

FILE* fdopen(int32_t fd, char const* mode)
{
    /* tailcall */
    return fdopen(fd, mode);
}

int64_t sub_54e6()
{
    int64_t var_8 = 0x4b;
    /* tailcall */
    return sub_5020();
}

int64_t munmap()
{
    /* tailcall */
    return munmap();
}

int64_t sub_54f6()
{
    int64_t var_8 = 0x4c;
    /* tailcall */
    return sub_5020();
}

int32_t poll(struct pollfd* fds, nfds_t nfds, int32_t timeout)
{
    /* tailcall */
    return poll(fds, nfds, timeout);
}

int64_t sub_5506()
{
    int64_t var_8 = 0x4d;
    /* tailcall */
    return sub_5020();
}

int64_t bind()
{
    /* tailcall */
    return bind();
}

int64_t sub_5516()
{
    int64_t var_8 = 0x4e;
    /* tailcall */
    return sub_5020();
}

__sighandler_t sigset(int32_t sig, __sighandler_t disp)
{
    /* tailcall */
    return sigset(sig, disp);
}

int64_t sub_5526()
{
    int64_t var_8 = 0x4f;
    /* tailcall */
    return sub_5020();
}

uint64_t strftime(char* s, uint64_t maxsize, char const* format, struct tm* tp)
{
    /* tailcall */
    return strftime(s, maxsize, format, tp);
}

int64_t sub_5536()
{
    int64_t var_8 = 0x50;
    /* tailcall */
    return sub_5020();
}

int64_t memmove(void* arg1, void const* arg2, uint64_t arg3)
{
    /* tailcall */
    return memmove(arg1, arg2, arg3);
}

int64_t sub_5546()
{
    int64_t var_8 = 0x51;
    /* tailcall */
    return sub_5020();
}

int32_t setgid(gid_t gid)
{
    /* tailcall */
    return setgid(gid);
}

int64_t sub_5556()
{
    int64_t var_8 = 0x52;
    /* tailcall */
    return sub_5020();
}

pid_t waitpid(pid_t pid, int32_t* stat_loc, int32_t options)
{
    /* tailcall */
    return waitpid(pid, stat_loc, options);
}

int64_t sub_5566()
{
    int64_t var_8 = 0x53;
    /* tailcall */
    return sub_5020();
}

int32_t open(char const* file, int32_t oflag, ...)
{
    /* tailcall */
    return open();
}

int64_t sub_5576()
{
    int64_t var_8 = 0x54;
    /* tailcall */
    return sub_5020();
}

int64_t fchown()
{
    /* tailcall */
    return fchown();
}

int64_t sub_5586()
{
    int64_t var_8 = 0x55;
    /* tailcall */
    return sub_5020();
}

FILE* fopen(char const* filename, char const* mode)
{
    /* tailcall */
    return fopen(filename, mode);
}

int64_t sub_5596()
{
    int64_t var_8 = 0x56;
    /* tailcall */
    return sub_5020();
}

void perror(char const* s)
{
    /* tailcall */
    return perror(s);
}

int64_t sub_55a6()
{
    int64_t var_8 = 0x57;
    /* tailcall */
    return sub_5020();
}

struct tm* gmtime(time_t* t)
{
    /* tailcall */
    return gmtime(t);
}

int64_t sub_55b6()
{
    int64_t var_8 = 0x58;
    /* tailcall */
    return sub_5020();
}

int32_t accept(int32_t fd, union __SOCKADDR_ARG addr, socklen_t* len)
{
    /* tailcall */
    return accept(fd, addr, len);
}

int64_t sub_55c6()
{
    int64_t var_8 = 0x59;
    /* tailcall */
    return sub_5020();
}

int64_t getsockname()
{
    /* tailcall */
    return getsockname();
}

int64_t sub_55d6()
{
    int64_t var_8 = 0x5a;
    /* tailcall */
    return sub_5020();
}

char* strcat(char* arg1, char const* arg2)
{
    /* tailcall */
    return strcat(arg1, arg2);
}

int64_t sub_55e6()
{
    int64_t var_8 = 0x5b;
    /* tailcall */
    return sub_5020();
}

void openlog(char const* ident, int32_t logstat, int32_t logfac)
{
    /* tailcall */
    return openlog(ident, logstat, logfac);
}

int64_t sub_55f6()
{
    int64_t var_8 = 0x5c;
    /* tailcall */
    return sub_5020();
}

int32_t gethostname(char* name, uint64_t len)
{
    /* tailcall */
    return gethostname(name, len);
}

int64_t sub_5606()
{
    int64_t var_8 = 0x5d;
    /* tailcall */
    return sub_5020();
}

int32_t sprintf(char* s, char const* format, ...)
{
    /* tailcall */
    return sprintf();
}

int64_t sub_5616()
{
    int64_t var_8 = 0x5e;
    /* tailcall */
    return sub_5020();
}

void exit(int32_t status) __noreturn
{
    /* tailcall */
    return exit(status);
}

int64_t sub_5626()
{
    int64_t var_8 = 0x5f;
    /* tailcall */
    return sub_5020();
}

uint64_t fwrite(void const* buf, uint64_t size, uint64_t count, FILE* fp)
{
    /* tailcall */
    return fwrite(buf, size, count, fp);
}

int64_t sub_5636()
{
    int64_t var_8 = 0x60;
    /* tailcall */
    return sub_5020();
}

int32_t getrlimit(enum __rlimit_resource resource, struct rlimit64* rlimits)
{
    /* tailcall */
    return getrlimit(resource, rlimits);
}

int64_t sub_5646()
{
    int64_t var_8 = 0x61;
    /* tailcall */
    return sub_5020();
}

int32_t setuid(uid_t uid)
{
    /* tailcall */
    return setuid(uid);
}

int64_t sub_5656()
{
    int64_t var_8 = 0x62;
    /* tailcall */
    return sub_5020();
}

int32_t getaddrinfo(char const* name, char const* service, struct addrinfo* hints, struct addrinfo** pai)
{
    /* tailcall */
    return getaddrinfo(name, service, hints, pai);
}

int64_t sub_5666()
{
    int64_t var_8 = 0x63;
    /* tailcall */
    return sub_5020();
}

char* strdup(char const* s)
{
    /* tailcall */
    return strdup(s);
}

int64_t sub_5676()
{
    int64_t var_8 = 0x64;
    /* tailcall */
    return sub_5020();
}

int32_t initgroups(char const* user, gid_t group)
{
    /* tailcall */
    return initgroups(user, group);
}

int64_t sub_5686()
{
    int64_t var_8 = 0x65;
    /* tailcall */
    return sub_5020();
}

int64_t crypt()
{
    /* tailcall */
    return crypt();
}

int64_t sub_5696()
{
    int64_t var_8 = 0x66;
    /* tailcall */
    return sub_5020();
}

uint32_t sleep(uint32_t seconds)
{
    /* tailcall */
    return sleep(seconds);
}

int64_t sub_56a6()
{
    int64_t var_8 = 0x67;
    /* tailcall */
    return sub_5020();
}

pid_t fork()
{
    /* tailcall */
    return fork();
}

int64_t sub_56b6()
{
    int64_t var_8 = 0x68;
    /* tailcall */
    return sub_5020();
}

char* strstr(char const* arg1, char const* arg2)
{
    /* tailcall */
    return strstr(arg1, arg2);
}

int64_t sub_56c6()
{
    int64_t var_8 = 0x69;
    /* tailcall */
    return sub_5020();
}

int32_t getdtablesize()
{
    /* tailcall */
    return getdtablesize();
}

int64_t sub_56d6()
{
    int64_t var_8 = 0x6a;
    /* tailcall */
    return sub_5020();
}

int32_t** __ctype_tolower_loc()
{
    /* tailcall */
    return __ctype_tolower_loc();
}

int64_t sub_56e6()
{
    int64_t var_8 = 0x6b;
    /* tailcall */
    return sub_5020();
}

uint16_t** __ctype_b_loc()
{
    /* tailcall */
    return __ctype_b_loc();
}

int64_t sub_56f6()
{
    int64_t var_8 = 0x6c;
    /* tailcall */
    return sub_5020();
}

void freeaddrinfo(struct addrinfo* ai)
{
    /* tailcall */
    return freeaddrinfo(ai);
}

int64_t sub_5706()
{
    int64_t var_8 = 0x6d;
    /* tailcall */
    return sub_5020();
}

int64_t socket()
{
    /* tailcall */
    return socket();
}

int64_t sub_5716()
{
    int64_t var_8 = 0x6e;
    /* tailcall */
    return sub_5020();
}

void __cxa_finalize(void* d)
{
    /* tailcall */
    return __cxa_finalize(d);
}

void _start(int64_t arg1, int64_t arg2, void (* arg3)()) __noreturn
{
    int64_t stack_end_1;
    int64_t stack_end = stack_end_1;
    __libc_start_main(main, __return_addr, &ubp_av, nullptr, nullptr, arg3, &stack_end);
    /* no return */
}

void deregister_tm_clones()
{
    return;
}

void register_tm_clones()
{
    return;
}

void __do_global_dtors_aux()
{
    if (__TMC_END__ != 0)
        return;
    
    if (__cxa_finalize != 0)
        __cxa_finalize(__dso_handle);
    
    deregister_tm_clones();
    __TMC_END__ = 1;
}

void frame_dummy()
{
    /* tailcall */
    return register_tm_clones();
}

int32_t main(int32_t argc, char** argv, char** envp)
{
    char** argv_1 = argv;
    char* ident_1 = *argv;
    argv0 = ident_1;
    char* rax = strrchr(ident_1, 0x2f);
    void* ident = &rax[1];
    
    if (rax == 0)
        ident = ident_1;
    
    openlog(ident, 9, 0x18);
    debug = 0;
    port = 0x50;
    dir = 0;
    data_dir = 0;
    do_chroot = 0;
    no_log = 0;
    no_symlink_check = 0;
    do_vhost = 0;
    do_global_passwd = 0;
    cgi_pattern = 0;
    cgi_limit = 0;
    url_pattern = 0;
    no_empty_referrers = 0;
    local_pattern = 0;
    throttlefile = 0;
    hostname = 0;
    logfile = 0;
    pidfile = 0;
    user = "nobody";
    charset = "UTF-8";
    p3p = &data_13553;
    max_age = 0xffffffff;
    int32_t rdx = 1;
    int128_t var_3ac8;
    void* user_1;
    uint64_t argv0_2;
    char* filename;
    char* format_1;
    FILE* stream_1;
    
    if (argc >= 2)
    {
        int32_t rbp_1 = 1;
        
        do
        {
            char* rbx = argv_1[rbp_1];
            
            if (*rbx != 0x2d)
            {
                rdx = rbp_1;
                break;
            }
            
            if (strcmp(rbx, &data_124f8) == 0)
            {
                puts("thttpd/2.29 23May2018");
                exit(0);
                /* no return */
            }
            
            int32_t rdx_2;
            
            if ((strcmp(rbx, &data_12511) != 0 || (rbp_1 + 1) >= argc))
            {
                if ((strcmp(rbx, &data_12514) != 0 || (rbp_1 + 1) >= argc))
                {
                    int32_t rax_70 = strcmp(rbx, &data_12517);
                    
                    if (rax_70 == 0)
                        rdx_2 = (rbp_1 + 1);
                    
                    if ((rax_70 != 0 || rdx_2 >= argc))
                    {
                        if (strcmp(rbx, &data_1251a) == 0)
                        {
                            do_chroot = 1;
                            no_symlink_check = 1;
                            rdx_2 = rbp_1;
                        }
                        else if (strcmp(rbx, "-nor") == 0)
                        {
                            do_chroot = 0;
                            no_symlink_check = 0;
                            rdx_2 = rbp_1;
                        }
                        else
                        {
                            int32_t rax_75 = strcmp(rbx, &data_12522);
                            
                            if (rax_75 == 0)
                                rdx_2 = (rbp_1 + 1);
                            
                            if ((rax_75 != 0 || rdx_2 >= argc))
                            {
                                if (strcmp(rbx, &data_12526) == 0)
                                {
                                    no_symlink_check = 0;
                                    rdx_2 = rbp_1;
                                }
                                else if (strcmp(rbx, "-nos") == 0)
                                {
                                    no_symlink_check = 1;
                                    rdx_2 = rbp_1;
                                }
                                else
                                {
                                    int32_t rax_80 = strcmp(rbx, &data_1252e);
                                    
                                    if (rax_80 == 0)
                                        rdx_2 = (rbp_1 + 1);
                                    
                                    if ((rax_80 != 0 || rdx_2 >= argc))
                                    {
                                        int32_t rax_83 = strcmp(rbx, &data_12531);
                                        
                                        if (rax_83 == 0)
                                            rdx_2 = (rbp_1 + 1);
                                        
                                        if ((rax_83 != 0 || rdx_2 >= argc))
                                        {
                                            int32_t rax_86 = strcmp(rbx, &data_12534);
                                            
                                            if (rax_86 == 0)
                                                rdx_2 = (rbp_1 + 1);
                                            
                                            if ((rax_86 != 0 || rdx_2 >= argc))
                                            {
                                                int32_t rax_89 = strcmp(rbx, &data_12537);
                                                
                                                if (rax_89 == 0)
                                                    rdx_2 = (rbp_1 + 1);
                                                
                                                if ((rax_89 != 0 || rdx_2 >= argc))
                                                {
                                                    int32_t rax_92 = strcmp(rbx, &data_1253a);
                                                    
                                                    if (rax_92 == 0)
                                                        rdx_2 = (rbp_1 + 1);
                                                    
                                                    if ((rax_92 != 0 || rdx_2 >= argc))
                                                    {
                                                        if (strcmp(rbx, &data_1253d) == 0)
                                                        {
                                                            do_vhost = 1;
                                                            rdx_2 = rbp_1;
                                                        }
                                                        else if (strcmp(rbx, "-nov") == 0)
                                                        {
                                                            do_vhost = 0;
                                                            rdx_2 = rbp_1;
                                                        }
                                                        else if (strcmp(rbx, &data_12545) == 0)
                                                        {
                                                            do_global_passwd = 1;
                                                            rdx_2 = rbp_1;
                                                        }
                                                        else if (strcmp(rbx, "-nog") == 0)
                                                        {
                                                            do_global_passwd = 0;
                                                            rdx_2 = rbp_1;
                                                        }
                                                        else
                                                        {
                                                            int32_t rax_99 = strcmp(rbx, &data_1254d);
                                                            
                                                            if (rax_99 == 0)
                                                                rdx_2 = (rbp_1 + 1);
                                                            
                                                            if ((rax_99 != 0 || rdx_2 >= argc))
                                                            {
                                                                int32_t rax_102 = strcmp(rbx, &data_12550);
                                                                
                                                                if (rax_102 == 0)
                                                                    rdx_2 = (rbp_1 + 1);
                                                                
                                                                if ((rax_102 != 0 || rdx_2 >= argc))
                                                                {
                                                                    int32_t rax_105 = strcmp(rbx, &data_12553);
                                                                    
                                                                    if (rax_105 == 0)
                                                                        rdx_2 = (rbp_1 + 1);
                                                                    
                                                                    if ((rax_105 != 0 || rdx_2 >= argc))
                                                                    {
                                                                        if ((strcmp(rbx, &data_12556) != 0 || (rbp_1 + 1) >= argc))
                                                                        {
                                                                            if (strcmp(rbx, &data_12559) != 0)
                                                                            {
                                                                                usage();
                                                                                /* no return */
                                                                            }
                                                                            
                                                                            debug = 1;
                                                                            rdx_2 = rbp_1;
                                                                        }
                                                                        else
                                                                        {
                                                                            rdx_2 = (rbp_1 + 1);
                                                                            max_age = strtol(argv_1[(rbp_1 + 1)], nullptr, 0xa);
                                                                        }
                                                                    }
                                                                    else
                                                                        p3p = argv_1[rdx_2];
                                                                }
                                                                else
                                                                    charset = argv_1[rdx_2];
                                                            }
                                                            else
                                                                pidfile = argv_1[rdx_2];
                                                        }
                                                    }
                                                    else
                                                        logfile = argv_1[rdx_2];
                                                }
                                                else
                                                    hostname = argv_1[rdx_2];
                                            }
                                            else
                                                throttlefile = argv_1[rdx_2];
                                        }
                                        else
                                            cgi_pattern = argv_1[rdx_2];
                                    }
                                    else
                                        user = argv_1[rdx_2];
                                }
                            }
                            else
                                data_dir = argv_1[rdx_2];
                        }
                    }
                    else
                        dir = argv_1[rdx_2];
                }
                else
                {
                    rdx_2 = (rbp_1 + 1);
                    port = strtol(argv_1[(rbp_1 + 1)], nullptr, 0xa);
                }
            }
            else
            {
                filename = argv_1[(rbp_1 + 1)];
                FILE* fp = fopen(filename, &data_1251b);
                
                if (fp == 0)
                    goto label_7de6;
                
                FILE* fp_2 = fp;
                FILE* fp_6 = fp_2;
                
                if (fgets(&var_3ac8, 0x2710, fp) != 0)
                {
                    while (true)
                    {
                        char* rax_8 = strchr(&var_3ac8, 0x23);
                        
                        if (rax_8 != 0)
                            *rax_8 = 0;
                        
                        uint64_t rax_9 = strspn(&var_3ac8, " \t\n\r");
                        
                        if (*(&var_3ac8 + rax_9) != 0)
                        {
                            void* user_2 = ((&argv_1 + rax_9) + 0x140);
                            
                            while (true)
                            {
                                void* rbx_2 = (strcspn(user_2, " \t\n\r") + user_2);
                                
                                while (true)
                                {
                                    uint64_t rax_13 = *rbx_2;
                                    
                                    if (rax_13 > 0x20)
                                        break;
                                    
                                    if (!((TEST_BITQ(0x100002600, rax_13))))
                                        break;
                                    
                                    *rbx_2 = 0;
                                    rbx_2 += 1;
                                }
                                
                                char* rax_14 = strchr(user_2, 0x3d);
                                void* r14_2;
                                
                                if (rax_14 != 0)
                                {
                                    *rax_14 = 0;
                                    
                                    if (strcasecmp(user_2, "debug") == 0)
                                    {
                                    label_6f72:
                                        stream_1 = *stderr;
                                        argv0_2 = argv0;
                                        format_1 = "%s: no value required for %s optâ€¦";
                                        user_1 = user_2;
                                        goto label_7005;
                                    }
                                    
                                    r14_2 = &rax_14[1];
                                    
                                    if (strcasecmp(user_2, "port") == 0)
                                    {
                                        port = strtol(r14_2, nullptr, 0xa);
                                        goto label_5abc;
                                    }
                                    
                                    if (strcasecmp(user_2, "dir") == 0)
                                    {
                                        char* rax_55 = strdup(r14_2);
                                        
                                        if (rax_55 == 0)
                                            break;
                                        
                                        dir = rax_55;
                                        goto label_5abc;
                                    }
                                    
                                    if (strcasecmp(user_2, "chroot") == 0)
                                        goto label_6f72;
                                    
                                    if (strcasecmp(user_2, "nochroot") == 0)
                                        goto label_6f72;
                                    
                                    if (strcasecmp(user_2, "data_dir") == 0)
                                    {
                                        char* rax_56 = strdup(r14_2);
                                        
                                        if (rax_56 == 0)
                                            break;
                                        
                                        data_dir = rax_56;
                                        goto label_5abc;
                                    }
                                    
                                    if (strcasecmp(user_2, "nosymlinkcheck") == 0)
                                        goto label_6f72;
                                    
                                    if (strcasecmp(user_2, "symlinkcheck") == 0)
                                        goto label_6f72;
                                    
                                    if (strcasecmp(user_2, "user") == 0)
                                    {
                                        char* rax_57 = strdup(r14_2);
                                        
                                        if (rax_57 == 0)
                                            break;
                                        
                                        user = rax_57;
                                        goto label_5abc;
                                    }
                                    
                                    if (strcasecmp(user_2, "cgipat") == 0)
                                    {
                                        char* rax_58 = strdup(r14_2);
                                        
                                        if (rax_58 == 0)
                                            break;
                                        
                                        cgi_pattern = rax_58;
                                        goto label_5abc;
                                    }
                                    
                                    if (strcasecmp(user_2, "cgilimit") == 0)
                                    {
                                        cgi_limit = strtol(r14_2, nullptr, 0xa);
                                        goto label_5abc;
                                    }
                                    
                                    if (strcasecmp(user_2, "urlpat") != 0)
                                        goto label_5d6d;
                                    
                                    char* rax_27 = strdup(r14_2);
                                    
                                    if (rax_27 == 0)
                                        break;
                                    
                                    url_pattern = rax_27;
                                    goto label_5abc;
                                }
                                
                                if (strcasecmp(user_2, "debug") != 0)
                                {
                                    if ((strcasecmp(user_2, "port") != 0 && strcasecmp(user_2, "dir") != 0))
                                    {
                                        if (strcasecmp(user_2, "chroot") == 0)
                                        {
                                            do_chroot = 1;
                                            no_symlink_check = 1;
                                            goto label_5abc;
                                        }
                                        
                                        if (strcasecmp(user_2, "nochroot") == 0)
                                        {
                                            do_chroot = 0;
                                        label_5f45:
                                            no_symlink_check = 0;
                                            goto label_5abc;
                                        }
                                        
                                        if (strcasecmp(user_2, "data_dir") != 0)
                                        {
                                            if (strcasecmp(user_2, "nosymlinkcheck") == 0)
                                            {
                                                no_symlink_check = 1;
                                                goto label_5abc;
                                            }
                                            
                                            if (strcasecmp(user_2, "symlinkcheck") == 0)
                                                goto label_5f45;
                                            
                                            if ((((strcasecmp(user_2, "user") != 0 && strcasecmp(user_2, "cgipat") != 0) && strcasecmp(user_2, "cgilimit") != 0) && strcasecmp(user_2, "urlpat") != 0))
                                            {
                                                r14_2 = nullptr;
                                            label_5d6d:
                                                int32_t rax_40 = strcasecmp(user_2, "noemptyreferers");
                                                int32_t rax_41;
                                                
                                                if (rax_40 != 0)
                                                    rax_41 = strcasecmp(user_2, "noemptyreferrers");
                                                
                                                if ((rax_40 == 0 || rax_41 == 0))
                                                {
                                                    if (r14_2 != 0)
                                                        goto label_6f72;
                                                    
                                                    no_empty_referrers = 1;
                                                    goto label_5abc;
                                                }
                                                
                                                if (strcasecmp(user_2, "localpat") != 0)
                                                {
                                                    if (strcasecmp(user_2, "throttles") != 0)
                                                    {
                                                        if (strcasecmp(user_2, "host") != 0)
                                                        {
                                                            if (strcasecmp(user_2, "logfile") != 0)
                                                            {
                                                                if (strcasecmp(user_2, "vhost") == 0)
                                                                {
                                                                    if (r14_2 != 0)
                                                                        goto label_6f72;
                                                                    
                                                                    do_vhost = 1;
                                                                    goto label_5abc;
                                                                }
                                                                
                                                                if (strcasecmp(user_2, "novhost") == 0)
                                                                {
                                                                    if (r14_2 != 0)
                                                                        goto label_6f72;
                                                                    
                                                                    do_vhost = 0;
                                                                    goto label_5abc;
                                                                }
                                                                
                                                                if (strcasecmp(user_2, "globalpasswd") == 0)
                                                                {
                                                                    if (r14_2 != 0)
                                                                        goto label_6f72;
                                                                    
                                                                    do_global_passwd = 1;
                                                                    goto label_5abc;
                                                                }
                                                                
                                                                if (strcasecmp(user_2, "noglobalpasswd") == 0)
                                                                {
                                                                    if (r14_2 != 0)
                                                                        goto label_6f72;
                                                                    
                                                                    do_global_passwd = 0;
                                                                    goto label_5abc;
                                                                }
                                                                
                                                                if (strcasecmp(user_2, "pidfile") != 0)
                                                                {
                                                                    if (strcasecmp(user_2, "charset") != 0)
                                                                    {
                                                                        if (strcasecmp(user_2, &data_12604) != 0)
                                                                        {
                                                                            if (strcasecmp(user_2, "max_age") != 0)
                                                                            {
                                                                                stream_1 = *stderr;
                                                                                argv0_2 = argv0;
                                                                                format_1 = "%s: unknown config option '%s'\n";
                                                                                user_1 = user_2;
                                                                                goto label_7005;
                                                                            }
                                                                            
                                                                            if (r14_2 != 0)
                                                                            {
                                                                                max_age = strtol(r14_2, nullptr, 0xa);
                                                                                goto label_5abc;
                                                                            }
                                                                        }
                                                                        else if (r14_2 != 0)
                                                                        {
                                                                            char* rax_66 = strdup(r14_2);
                                                                            
                                                                            if (rax_66 == 0)
                                                                                break;
                                                                            
                                                                            p3p = rax_66;
                                                                            goto label_5abc;
                                                                        }
                                                                    }
                                                                    else if (r14_2 != 0)
                                                                    {
                                                                        char* rax_65 = strdup(r14_2);
                                                                        
                                                                        if (rax_65 == 0)
                                                                            break;
                                                                        
                                                                        charset = rax_65;
                                                                        goto label_5abc;
                                                                    }
                                                                }
                                                                else if (r14_2 != 0)
                                                                {
                                                                    char* rax_64 = strdup(r14_2);
                                                                    
                                                                    if (rax_64 == 0)
                                                                        break;
                                                                    
                                                                    pidfile = rax_64;
                                                                    goto label_5abc;
                                                                }
                                                            }
                                                            else if (r14_2 != 0)
                                                            {
                                                                char* rax_63 = strdup(r14_2);
                                                                
                                                                if (rax_63 == 0)
                                                                    break;
                                                                
                                                                logfile = rax_63;
                                                                goto label_5abc;
                                                            }
                                                        }
                                                        else if (r14_2 != 0)
                                                        {
                                                            char* rax_62 = strdup(r14_2);
                                                            
                                                            if (rax_62 == 0)
                                                                break;
                                                            
                                                            hostname = rax_62;
                                                            goto label_5abc;
                                                        }
                                                    }
                                                    else if (r14_2 != 0)
                                                    {
                                                        char* rax_61 = strdup(r14_2);
                                                        
                                                        if (rax_61 == 0)
                                                            break;
                                                        
                                                        throttlefile = rax_61;
                                                        goto label_5abc;
                                                    }
                                                }
                                                else if (r14_2 != 0)
                                                {
                                                    char* rax_60 = strdup(r14_2);
                                                    
                                                    if (rax_60 == 0)
                                                        break;
                                                    
                                                    local_pattern = rax_60;
                                                    goto label_5abc;
                                                }
                                            }
                                        }
                                    }
                                    
                                    stream_1 = *stderr;
                                    argv0_2 = argv0;
                                    format_1 = "%s: value required for %s optionâ€¦";
                                    user_1 = user_2;
                                    goto label_7005;
                                }
                                
                                debug = 1;
                            label_5abc:
                                uint64_t rax_11 = strspn(rbx_2, " \t\n\r");
                                user_2 = (rbx_2 + rax_11);
                                
                                if (*(rbx_2 + rax_11) == 0)
                                    goto label_5a50;
                            }
                            
                            break;
                        }
                        
                    label_5a50:
                        fp_2 = fp_6;
                        
                        if (fgets(&var_3ac8, 0x2710, fp_2) == 0)
                            goto label_5a30;
                    }
                    
                    goto label_707d;
                }
                
            label_5a30:
                fclose(fp_2);
                rdx_2 = (rbp_1 + 1);
            }
            
            rdx = (rdx_2 + 1);
            rbp_1 = rdx;
        } while (rdx < argc);
    }
    
    uint64_t argv0_1;
    char* format;
    FILE* stream;
    
    if (rdx != argc)
    {
        stream = *stderr;
        argv0_1 = argv0;
        format = "usage:  %s [-C configfile] [-p pâ€¦";
    }
    else
    {
        tzset();
        int512_t zmm0_1;
        zmm0_1 = {0};
        __builtin_memset(&var_3ac8, 0, 0x30);
        var_3ac8 = 1;
        *var_3ac8[8] = 1;
        int32_t r14_3 = 0;
        char var_13b8;
        snprintf(&var_13b8, 0xa, "%d", port, zmm0_1);
        struct addrinfo* pai;
        int32_t code = getaddrinfo(hostname, &var_13b8, &var_3ac8, &pai);
        
        if (code != 0)
        {
            syslog(2, "getaddrinfo %.80s - %.80s", hostname, gai_strerror(code));
            fprintf(*stderr, "%s: getaddrinfo %s - %s\n", argv0, hostname, gai_strerror(code));
            exit(1);
            /* no return */
        }
        
        struct addrinfo* ai = pai;
        char var_3bf4_2;
        
        if (ai == 0)
        {
        label_660e:
            freeaddrinfo(ai);
            var_3bf4_2 = 1;
            
            if (r14_3 != 0)
                goto label_66d3;
            
            syslog(3, "can't find any valid address");
            stream = *stderr;
            argv0_1 = argv0;
            format = "%s: can't find any valid addressâ€¦";
        }
        else
        {
            struct addrinfo* ai_next_2 = nullptr;
            struct addrinfo* ai_next = ai;
            struct addrinfo* ai_next_1 = nullptr;
            
            do
            {
                int32_t ai_family = ai_next->ai_family;
                
                if (ai_family == 2)
                {
                    if (ai_next_2 == 0)
                        ai_next_2 = ai_next;
                }
                else if ((ai_family == 0xa && ai_next_1 == 0))
                    ai_next_1 = ai_next;
                
                ai_next = ai_next->ai_next;
            } while (ai_next != 0);
            
            r14_3 = 0;
            int128_t s;
            uint64_t ai_addrlen;
            
            if (ai_next_1 != 0)
            {
                ai_addrlen = ai_next_1->ai_addrlen;
                
                if (ai_addrlen >= 0x81)
                {
                label_7dbc:
                    syslog(2, "%.80s - sockaddr too small (%lu â€¦", hostname, 0x80, ai_addrlen);
                    exit(1);
                    /* no return */
                }
                
                __builtin_memset(&s, 0, 0x80);
                memmove(&s, ai_next_1->ai_addr, ai_next_1->ai_addrlen);
                r14_3 = 1;
            }
            
            if (ai_next_2 == 0)
                goto label_660e;
            
            ai_addrlen = ai_next_2->ai_addrlen;
            
            if (ai_addrlen >= 0x81)
                goto label_7dbc;
            
            int128_t s_1;
            __builtin_memset(&s_1, 0, 0x80);
            memmove(&s_1, ai_next_2->ai_addr, ai_next_2->ai_addrlen);
            freeaddrinfo(ai);
            var_3bf4_2 = 0;
        label_66d3:
            numthrottles = 0;
            maxthrottles = 0;
            throttles = 0;
            uint64_t throttlefile_1 = throttlefile;
            
            if (throttlefile_1 == 0)
                goto label_675d;
            
            argv_1 = r14_3;
            int32_t var_3c00;
            var_3c00 = throttlefile_1;
            FILE* fp_8 = fopen(throttlefile_1, &data_1251b);
            char* logfile_3;
            
            if (fp_8 == 0)
            {
                filename = var_3c00;
                syslog(2, "%.80s - %m", filename);
            label_7de6:
                logfile_3 = filename;
            label_68b1:
                perror(logfile_3);
                exit(1);
                /* no return */
            }
            
            FILE* fp_5 = fp_8;
            gettimeofday(&pai, nullptr);
            
            if (fgets(&var_3ac8, 0x1388, fp_5) == 0)
            {
            label_674c:
                fclose(fp_5);
                r14_3 = argv_1;
            label_675d:
                uint32_t pw_gid = 0x7fff;
                uint32_t pw_uid = 0x7fff;
                
                if (getuid() == 0)
                {
                    struct passwd* rax_117 = getpwnam(user);
                    
                    if (rax_117 == 0)
                    {
                        syslog(2, "unknown user - '%.80s'", user);
                        stream_1 = *stderr;
                        argv0_2 = argv0;
                        user_1 = user;
                        format_1 = "%s: unknown user - '%s'\n";
                    label_7005:
                        fprintf(stream_1, format_1, argv0_2, user_1);
                        exit(1);
                        /* no return */
                    }
                    
                    pw_uid = rax_117->pw_uid;
                    pw_gid = rax_117->pw_gid;
                }
                
                uint64_t logfile_2 = logfile;
                FILE* fp_3;
                
                if (logfile_2 == 0)
                {
                    fp_3 = nullptr;
                label_6882:
                    uint64_t dir_1 = dir;
                    int32_t rax_128;
                    
                    if (dir_1 != 0)
                        rax_128 = chdir(dir_1);
                    
                    if ((dir_1 == 0 || rax_128 >= 0))
                    {
                        getcwd(&var_3ac8, "me");
                        uint64_t rax_130 = strlen(&var_3ac8);
                        int128_t var_3ad8;
                        
                        if (*(&*var_3ad8[0xf] + rax_130) != 0x2f)
                            *(&var_3ac8 + strlen(&var_3ac8)) = 0x2f;
                        
                        char const* const fmt;
                        int64_t pri;
                        
                        if (debug == 0)
                        {
                            fclose(*stdin);
                            FILE* fp_4 = *stdout;
                            
                            if (fp_3 != fp_4)
                                fclose(fp_4);
                            
                            fclose(*stderr);
                            
                            if (daemon(1, 1) >= 0)
                                goto label_6955;
                            
                            fmt = "daemon - %m";
                        label_6c3c:
                            pri = 2;
                        label_6c43:
                            syslog(pri, fmt);
                            exit(1);
                            /* no return */
                        }
                        
                        setsid();
                    label_6955:
                        uint64_t pidfile_1 = pidfile;
                        
                        if (pidfile_1 != 0)
                        {
                            FILE* rax_133 = fopen(pidfile_1, "w");
                            
                            if (rax_133 == 0)
                            {
                                syslog(2, "%.80s - %m", pidfile);
                                exit(1);
                                /* no return */
                            }
                            
                            fprintf(rax_133, &data_121d7, getpid());
                            fclose(rax_133);
                        }
                        
                        uint32_t rax_156 = fdwatch_get_nfiles();
                        max_connects = rax_156;
                        
                        if (rax_156 < 0)
                        {
                            fmt = "fdwatch initialization failure";
                            goto label_6c3c;
                        }
                        
                        max_connects = (rax_156 - 0xa);
                        
                        if (do_chroot != 1)
                        {
                        label_6d5c:
                            uint64_t data_dir_1 = data_dir;
                            int32_t rax_168;
                            
                            if (data_dir_1 != 0)
                                rax_168 = chdir(data_dir_1);
                            
                            if ((data_dir_1 == 0 || rax_168 >= 0))
                            {
                                sigset(0xf, handle_term);
                                sigset(2, handle_term);
                                sigset(0x11, handle_chld);
                                sigset(0xd, &__elf_header.ident.signature[1]);
                                sigset(1, handle_hup);
                                sigset(0xa, handle_usr1);
                                sigset(0xc, handle_usr2);
                                sigset(0xe, handle_alrm);
                                got_hup = 0;
                                got_usr1 = 0;
                                watchdog_flag = 0;
                                alarm(0x168);
                                tmr_init();
                                int16_t* rsi_8 = &s_1;
                                
                                if (var_3bf4_2 != 0)
                                    rsi_8 = nullptr;
                                
                                int16_t* rdx_26 = &s;
                                
                                if (r14_3 == 0)
                                    rdx_26 = nullptr;
                                
                                char** rax_180 = httpd_initialize(hostname, rsi_8, rdx_26, port, cgi_pattern, cgi_limit, charset, p3p, max_age, &var_3ac8, no_log, fp_3, no_symlink_check, do_vhost, do_global_passwd, url_pattern, local_pattern, no_empty_referrers);
                                hs = rax_180;
                                
                                if (rax_180 == 0)
                                {
                                    exit(1);
                                    /* no return */
                                }
                                
                                if (tmr_create(nullptr, occasional, JunkClientData, 0x1d4c0, 1) == 0)
                                {
                                    fmt = "tmr_create(occasional) failed";
                                    goto label_6c3c;
                                }
                                
                                if (tmr_create(nullptr, idle, JunkClientData, 0x1388, 1) == 0)
                                {
                                    fmt = "tmr_create(idle) failed";
                                    goto label_6c3c;
                                }
                                
                                uint64_t rax_183;
                                
                                if (numthrottles > 0)
                                    rax_183 = tmr_create(nullptr, update_throttles, JunkClientData, 0x7d0, 1);
                                
                                if ((numthrottles > 0 && rax_183 == 0))
                                {
                                    fmt = "tmr_create(update_throttles) faiâ€¦";
                                    goto label_6c3c;
                                }
                                
                                if (tmr_create(nullptr, show_stats, JunkClientData, 0x36ee80, 1) == 0)
                                {
                                    fmt = "tmr_create(show_stats) failed";
                                    goto label_6c3c;
                                }
                                
                                time_t rax_186 = time(nullptr);
                                stats_time = rax_186;
                                start_time = rax_186;
                                stats_connections = 0;
                                stats_bytes = 0;
                                stats_simultaneous = 0;
                                
                                if (getuid() == 0)
                                {
                                    if (setgroups(0, nullptr) < 0)
                                    {
                                        fmt = "setgroups - %m";
                                        goto label_6c3c;
                                    }
                                    
                                    if (setgid(pw_gid) < 0)
                                    {
                                        fmt = "setgid - %m";
                                        goto label_6c3c;
                                    }
                                    
                                    if (initgroups(user, pw_gid) < 0)
                                        syslog(4, "initgroups - %m");
                                    
                                    if (setuid(pw_uid) < 0)
                                    {
                                        fmt = "setuid - %m";
                                        goto label_6c3c;
                                    }
                                    
                                    if (do_chroot == 0)
                                        syslog(4, "started as root without requestiâ€¦");
                                }
                                
                                uint32_t max_connects_1 = max_connects;
                                int64_t max_connects_2 = max_connects_1;
                                uint64_t rax_198 = malloc((max_connects_2 * 0x90));
                                connects = rax_198;
                                
                                if (rax_198 == 0)
                                {
                                    fmt = "out of memory allocating a conneâ€¦";
                                    goto label_6c3c;
                                }
                                
                                if (max_connects_1 > 0)
                                {
                                    int64_t i;
                                    
                                    if (max_connects_1 != 1)
                                    {
                                        int64_t* rsi_11 = (rax_198 + 0x98);
                                        i = 0;
                                        
                                        do
                                        {
                                            rsi_11[-0x13] = 0;
                                            *(rsi_11 - 0x94) = (i + 1);
                                            rsi_11[-0x12] = 0;
                                            rsi_11[-1] = 0;
                                            i += 2;
                                            *(rsi_11 - 4) = i;
                                            *rsi_11 = 0;
                                            rsi_11 = &rsi_11[0x24];
                                        } while ((max_connects_1 & 0xfffffffe) != i);
                                    }
                                    else
                                        i = 0;
                                    
                                    if ((max_connects_1 & 1) != 0)
                                    {
                                        int64_t rdx_34 = (i * 0x90);
                                        *(rax_198 + rdx_34) = 0;
                                        *((rax_198 + rdx_34) + 4) = (i + 1);
                                        *((rax_198 + rdx_34) + 8) = 0;
                                    }
                                }
                                
                                *(((max_connects_2 * 0x90) + rax_198) - 0x8c) = 0xffffffff;
                                first_free_connect = 0;
                                num_connects = 0;
                                httpd_conn_count = 0;
                                uint64_t hs_1 = hs;
                                
                                if (hs_1 != 0)
                                {
                                    int32_t rdi_139 = *(hs_1 + 0x48);
                                    
                                    if (rdi_139 != 0xffffffff)
                                    {
                                        fdwatch_add_fd(rdi_139, 0, 0);
                                        hs_1 = hs;
                                    }
                                    
                                    int32_t rdi_140 = *(hs_1 + 0x4c);
                                    
                                    if (rdi_140 != 0xffffffff)
                                        fdwatch_add_fd(rdi_140, 0, 0);
                                }
                                
                                gettimeofday(&pai, nullptr);
                                
                                if ((terminate != 0 && num_connects <= 0))
                                {
                                label_7c52:
                                    shut_down();
                                    syslog(5, "exiting");
                                    closelog();
                                    exit(0);
                                    /* no return */
                                }
                                
                                while (true)
                                {
                                    if (got_hup != 0)
                                    {
                                        if ((no_log == 0 && hs != 0))
                                        {
                                            uint64_t logfile_4 = logfile;
                                            
                                            if ((logfile_4 != 0 && strcmp(logfile_4, "-") != 0))
                                            {
                                                syslog(5, "re-opening logfile");
                                                FILE* fp_1 = fopen(logfile, "a");
                                                
                                                if (fp_1 == 0)
                                                    syslog(2, "re-opening %.80s - %m", logfile);
                                                else
                                                {
                                                    fcntl(fileno(fp_1), 2, 1);
                                                    httpd_set_logfp(hs, fp_1);
                                                }
                                            }
                                        }
                                        
                                        got_hup = 0;
                                    }
                                    
                                    int32_t rax_205 = fdwatch(tmr_mstimeout(&pai));
                                    
                                    if (rax_205 < 0)
                                    {
                                        int32_t rax_264 = *__errno_location();
                                        
                                        if ((rax_264 != 0xb && rax_264 != 4))
                                        {
                                            fmt = "fdwatch - %m";
                                            pri = 3;
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        gettimeofday(&pai, nullptr);
                                        
                                        if (rax_205 == 0)
                                            tmr_run(&pai);
                                        else
                                        {
                                            uint64_t hs_2 = hs;
                                            
                                            if (hs_2 == 0)
                                            {
                                            label_7419:
                                                
                                                while (true)
                                                {
                                                    int32_t* rax_212 = fdwatch_get_next_client_data();
                                                    
                                                    if (rax_212 != 0)
                                                    {
                                                        if (rax_212 == -1)
                                                        {
                                                            tmr_run(&pai);
                                                            
                                                            if ((got_usr1 != 0 && terminate == 0))
                                                            {
                                                                terminate = 1;
                                                                uint64_t hs_4 = hs;
                                                                
                                                                if (hs_4 != 0)
                                                                {
                                                                    int32_t rax_265 = *(hs_4 + 0x48);
                                                                    
                                                                    if (rax_265 != 0xffffffff)
                                                                    {
                                                                        fdwatch_del_fd(rax_265);
                                                                        hs_4 = hs;
                                                                    }
                                                                    
                                                                    int32_t rax_266 = *(hs_4 + 0x4c);
                                                                    
                                                                    if (rax_266 != 0xffffffff)
                                                                    {
                                                                        fdwatch_del_fd(rax_266);
                                                                        hs_4 = hs;
                                                                    }
                                                                    
                                                                    httpd_unlisten(hs_4);
                                                                }
                                                            }
                                                            
                                                            break;
                                                        }
                                                        
                                                        if (fdwatch_check_fd(*(*(rax_212 + 8) + 0x2c0)) != 0)
                                                        {
                                                            int32_t rax_215 = *rax_212;
                                                            
                                                            if (rax_215 == 4)
                                                            {
                                                                int32_t rax_236 = read(*(*(rax_212 + 8) + 0x2c0), &var_13b8, "me");
                                                                
                                                                if (rax_236 < 0)
                                                                {
                                                                    int32_t rax_245 = *__errno_location();
                                                                    
                                                                    if (rax_245 == 4)
                                                                        continue;
                                                                    else if (rax_245 == 0xb)
                                                                        continue;
                                                                }
                                                                else if (rax_236 != 0)
                                                                    continue;
                                                                
                                                                really_clear_connection(rax_212, &pai);
                                                                continue;
                                                            }
                                                            else if (rax_215 == 2)
                                                            {
                                                                int64_t rcx_29 = *(rax_212 + 0x40);
                                                                int64_t nbytes_1;
                                                                
                                                                if (rcx_29 == -1)
                                                                    nbytes_1 = 0x3b9aca00;
                                                                else
                                                                {
                                                                    int64_t rax_234 = (rcx_29 + 3);
                                                                    
                                                                    if (rcx_29 >= 0)
                                                                        rax_234 = rcx_29;
                                                                    
                                                                    nbytes_1 = (rax_234 >> 2);
                                                                }
                                                                
                                                                void* r12_4 = *(rax_212 + 8);
                                                                int64_t rcx_30 = *(r12_4 + 0x1d8);
                                                                int32_t rax_237;
                                                                bool cond:7_1;
                                                                
                                                                if (rcx_30 != 0)
                                                                {
                                                                    var_13b8 = *(r12_4 + 0x170);
                                                                    int64_t var_13b0_1 = rcx_30;
                                                                    int64_t rcx_31 = *(rax_212 + 0x88);
                                                                    int64_t var_13a8_1 = (*(r12_4 + 0x2c8) + rcx_31);
                                                                    int64_t nbytes_2 = (*(rax_212 + 0x80) - rcx_31);
                                                                    
                                                                    if (nbytes_2 >= nbytes_1)
                                                                        nbytes_2 = nbytes_1;
                                                                    
                                                                    int64_t nbytes_3 = nbytes_2;
                                                                    rax_237 = writev(*(r12_4 + 0x2c0), &var_13b8, 2);
                                                                    cond:7_1 = rax_237 == 0;
                                                                    
                                                                    if (rax_237 < 0)
                                                                        goto label_77eb;
                                                                    
                                                                    goto label_7760;
                                                                }
                                                                
                                                                int64_t rcx_35 = *(rax_212 + 0x88);
                                                                int64_t nbytes = (*(rax_212 + 0x80) - rcx_35);
                                                                
                                                                if (nbytes >= nbytes_1)
                                                                    nbytes = nbytes_1;
                                                                
                                                                rax_237 = write(*(r12_4 + 0x2c0), (*(r12_4 + 0x2c8) + rcx_35), nbytes);
                                                                cond:7_1 = rax_237 == 0;
                                                                
                                                                if (rax_237 >= 0)
                                                                {
                                                                label_7760:
                                                                    int64_t rcx_37;
                                                                    
                                                                    if (cond:7_1)
                                                                    {
                                                                    label_7809:
                                                                        *(rax_212 + 0x70) += 0x64;
                                                                        *rax_212 = 3;
                                                                        fdwatch_del_fd(*(r12_4 + 0x2c0));
                                                                        
                                                                        if (*(rax_212 + 0x60) != 0)
                                                                            syslog(3, "replacing non-null wakeup_timer!");
                                                                        
                                                                        rcx_37 = *(rax_212 + 0x70);
                                                                    label_7850:
                                                                        uint64_t rax_243 = tmr_create(&pai, wakeup_connection, rax_212, rcx_37, 0);
                                                                        *(rax_212 + 0x60) = rax_243;
                                                                        
                                                                        if (rax_243 != 0)
                                                                            continue;
                                                                        
                                                                        fmt = "tmr_create(wakeup_connection) faâ€¦";
                                                                        goto label_6c3c;
                                                                    }
                                                                    else
                                                                    {
                                                                        *(rax_212 + 0x58) = pai;
                                                                        int64_t rcx_33 = *(r12_4 + 0x1d8);
                                                                        
                                                                        if (rcx_33 != 0)
                                                                        {
                                                                            int64_t rsi_29 = rax_237;
                                                                            int32_t rdx_51 = (rsi_29 - rcx_33);
                                                                            int64_t rbp_6;
                                                                            
                                                                            if (rsi_29 >= rcx_33)
                                                                                rbp_6 = 0;
                                                                            else
                                                                            {
                                                                                int64_t rdi_167 = *(r12_4 + 0x170);
                                                                                rbp_6 = (rcx_33 - rax_237);
                                                                                memmove(rdi_167, (rsi_29 + rdi_167), rbp_6);
                                                                                rdx_51 = 0;
                                                                            }
                                                                            
                                                                            *(r12_4 + 0x1d8) = rbp_6;
                                                                            rax_237 = rdx_51;
                                                                        }
                                                                        
                                                                        int64_t rdx_55 = rax_237;
                                                                        int64_t r9_4 = (*(rax_212 + 0x88) + rdx_55);
                                                                        *(rax_212 + 0x88) = r9_4;
                                                                        void* rdi_172 = *(rax_212 + 8);
                                                                        int64_t rax_249 = (*(rdi_172 + 0xc8) + rdx_55);
                                                                        *(rdi_172 + 0xc8) = rax_249;
                                                                        int32_t r8_5 = rax_212[0xe];
                                                                        
                                                                        if (r8_5 > 0)
                                                                        {
                                                                            uint64_t throttles_4 = throttles;
                                                                            int64_t i_1;
                                                                            
                                                                            if (r8_5 != 1)
                                                                            {
                                                                                i_1 = 0;
                                                                                
                                                                                do
                                                                                {
                                                                                    int64_t rcx_40 = (rax_212[(i_1 + 4)] * 0x30);
                                                                                    *((throttles_4 + rcx_40) + 0x20) += rdx_55;
                                                                                    int64_t rcx_43 = (rax_212[(i_1 + 5)] * 0x30);
                                                                                    *((throttles_4 + rcx_43) + 0x20) += rdx_55;
                                                                                    i_1 += 2;
                                                                                } while ((r8_5 & 0xfffffffe) != i_1);
                                                                            }
                                                                            else
                                                                                i_1 = 0;
                                                                            
                                                                            if ((r8_5 & 1) != 0)
                                                                            {
                                                                                int64_t rcx_46 = (rax_212[(i_1 + 4)] * 0x30);
                                                                                *((throttles_4 + rcx_46) + 0x20) += rdx_55;
                                                                            }
                                                                        }
                                                                        
                                                                        if (r9_4 < *(rax_212 + 0x80))
                                                                        {
                                                                            int64_t rcx_47 = *(rax_212 + 0x70);
                                                                            
                                                                            if (rcx_47 >= 0x65)
                                                                                *(rax_212 + 0x70) = (rcx_47 - 0x64);
                                                                            
                                                                            int64_t rcx_49 = *(rax_212 + 0x40);
                                                                            
                                                                            if (rcx_49 == -1)
                                                                                continue;
                                                                            else
                                                                            {
                                                                                struct addrinfo* pai_1 = pai;
                                                                                void* rbp_7 = (pai_1 - *(rax_212 + 0x50));
                                                                                
                                                                                if (pai_1 == *(rax_212 + 0x50))
                                                                                    rbp_7 = &*nullptr->ident.signature[1];
                                                                                
                                                                                if (((rax_249 | rbp_7) >> 0x20) != 0)
                                                                                {
                                                                                    if ((rax_249 / rbp_7) <= rcx_49)
                                                                                        continue;
                                                                                }
                                                                                else if ((COMBINE(0, rax_249) / rbp_7) <= rcx_49)
                                                                                    continue;
                                                                                
                                                                                *rax_212 = 3;
                                                                                fdwatch_del_fd(*(r12_4 + 0x2c0));
                                                                                int64_t rcx_50 = *(rax_212 + 0x40);
                                                                                int64_t rax_255 = *(*(rax_212 + 8) + 0xc8);
                                                                                uint64_t rdx_67;
                                                                                int32_t rbx_11;
                                                                                
                                                                                if (((rax_255 | rcx_50) >> 0x20) == 0)
                                                                                {
                                                                                    int32_t temp2_3 = rcx_50;
                                                                                    rdx_67 = (COMBINE(0, rax_255) % temp2_3);
                                                                                    rbx_11 = (COMBINE(0, rax_255) / temp2_3);
                                                                                }
                                                                                else
                                                                                {
                                                                                    int64_t rax_256;
                                                                                    int64_t rdx_66;
                                                                                    rdx_66 = HIGHQ(rax_255);
                                                                                    rax_256 = LOWQ(rax_255);
                                                                                    rdx_67 = (COMBINE(rdx_66, rax_256) % rcx_50);
                                                                                    rbx_11 = (COMBINE(rdx_66, rax_256) / rcx_50);
                                                                                }
                                                                                
                                                                                if (*(rax_212 + 0x60) != 0)
                                                                                    syslog(3, "replacing non-null wakeup_timer!", rdx_67);
                                                                                
                                                                                int64_t rax_260 = (rbx_11 - rbp_7);
                                                                                rcx_37 = (rax_260 * 0x3e8);
                                                                                
                                                                                if (rax_260 <= 0)
                                                                                    rcx_37 = 0x1f4;
                                                                            }
                                                                            
                                                                            goto label_7850;
                                                                        }
                                                                        
                                                                        httpd_write_response(rdi_172);
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                label_77eb:
                                                                    int32_t rax_239 = *__errno_location();
                                                                    uint64_t rcx_36 = (rax_239 - 4);
                                                                    
                                                                    if (rcx_36 <= 0x1c)
                                                                        switch (rcx_36)
                                                                        {
                                                                            case 0:
                                                                            {
                                                                                continue;
                                                                            }
                                                                            case 1:
                                                                            case 2:
                                                                            case 3:
                                                                            case 4:
                                                                            case 5:
                                                                            case 6:
                                                                            case 8:
                                                                            case 9:
                                                                            case 0xa:
                                                                            case 0xb:
                                                                            case 0xc:
                                                                            case 0xd:
                                                                            case 0xe:
                                                                            case 0xf:
                                                                            case 0x10:
                                                                            case 0x11:
                                                                            case 0x13:
                                                                            case 0x14:
                                                                            case 0x15:
                                                                            case 0x16:
                                                                            case 0x17:
                                                                            case 0x18:
                                                                            case 0x19:
                                                                            case 0x1a:
                                                                            case 0x1b:
                                                                            {
                                                                                syslog(3, "write - %m sending %.80s", *(r12_4 + 0xd0));
                                                                                break;
                                                                            }
                                                                            case 7:
                                                                            {
                                                                                goto label_7809;
                                                                            }
                                                                        }
                                                                    else if (rax_239 != 0x68)
                                                                        syslog(3, "write - %m sending %.80s", *(r12_4 + 0xd0));
                                                                }
                                                            }
                                                            else
                                                            {
                                                                if (rax_215 != 1)
                                                                    continue;
                                                                else
                                                                {
                                                                    uint64_t r12_3 = *(rax_212 + 8);
                                                                    int64_t rdx_36 = *(r12_3 + 0x98);
                                                                    int64_t rsi_17 = *(r12_3 + 0xa0);
                                                                    
                                                                    if (rsi_17 < rdx_36)
                                                                        goto label_74c2;
                                                                    
                                                                    if (rdx_36 >= 0x1389)
                                                                    {
                                                                    label_73e1:
                                                                        httpd_send_err(r12_3, 0x190, httpd_err400title, &data_13553, httpd_err400form, &data_13553);
                                                                    }
                                                                    else
                                                                    {
                                                                        httpd_realloc_str((r12_3 + 0x90), (r12_3 + 0x98), (rdx_36 + 0x3e8));
                                                                        rdx_36 = *(r12_3 + 0x98);
                                                                        rsi_17 = *(r12_3 + 0xa0);
                                                                    label_74c2:
                                                                        int32_t rax_216 = read(*(r12_3 + 0x2c0), (rsi_17 + *(r12_3 + 0x90)), (rdx_36 - rsi_17));
                                                                        
                                                                        if (rax_216 == 0)
                                                                            goto label_73e1;
                                                                        
                                                                        if (rax_216 < 0)
                                                                        {
                                                                            int32_t rax_247 = *__errno_location();
                                                                            
                                                                            if (rax_247 == 4)
                                                                                continue;
                                                                            else if (rax_247 == 0xb)
                                                                                continue;
                                                                            
                                                                            goto label_73e1;
                                                                        }
                                                                        
                                                                        *(r12_3 + 0xa0) += rax_216;
                                                                        *(rax_212 + 0x58) = pai;
                                                                        int32_t rax_219 = httpd_got_request(r12_3);
                                                                        
                                                                        if (rax_219 == 0)
                                                                            continue;
                                                                        else
                                                                        {
                                                                            if (rax_219 == 2)
                                                                                goto label_73e1;
                                                                            
                                                                            int32_t rax_220;
                                                                            int32_t zmm0_2[0x4];
                                                                            rax_220 = httpd_parse_request(r12_3);
                                                                            
                                                                            if (rax_220 >= 0)
                                                                            {
                                                                                rax_212[0xe] = 0;
                                                                                *(rax_212 + 0x40) = _mm_cmpeq_epi32(zmm0_2, zmm0_2);
                                                                                
                                                                                if (numthrottles <= 0)
                                                                                {
                                                                                label_765d:
                                                                                    
                                                                                    if (httpd_start_request(r12_3, &pai) >= 0)
                                                                                    {
                                                                                        int64_t rax_233;
                                                                                        
                                                                                        if (*(r12_3 + 0x210) != 0)
                                                                                        {
                                                                                            *(rax_212 + 0x88) = *(r12_3 + 0x218);
                                                                                            rax_233 = (*(r12_3 + 0x220) + 1);
                                                                                        label_7a99:
                                                                                            *(rax_212 + 0x80) = rax_233;
                                                                                            
                                                                                            if (*(r12_3 + 0x2c8) == 0)
                                                                                                goto label_7b0f;
                                                                                            
                                                                                            goto label_7aab;
                                                                                        }
                                                                                        
                                                                                        rax_233 = *(r12_3 + 0xc0);
                                                                                        
                                                                                        if (rax_233 >= 0)
                                                                                            goto label_7a99;
                                                                                        
                                                                                        *(rax_212 + 0x80) = 0;
                                                                                        rax_233 = 0;
                                                                                        
                                                                                        if (*(r12_3 + 0x2c8) != 0)
                                                                                        {
                                                                                        label_7aab:
                                                                                            
                                                                                            if (*(rax_212 + 0x88) < rax_233)
                                                                                            {
                                                                                                *rax_212 = 2;
                                                                                                *(rax_212 + 0x50) = pai;
                                                                                                *(rax_212 + 0x70) = 0;
                                                                                                fdwatch_del_fd(*(r12_3 + 0x2c0));
                                                                                                fdwatch_add_fd(*(r12_3 + 0x2c0), rax_212, 1);
                                                                                                continue;
                                                                                            }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                        label_7b0f:
                                                                                            int32_t rcx_51 = rax_212[0xe];
                                                                                            int64_t rax_262 = *(r12_3 + 0xc8);
                                                                                            
                                                                                            if (rcx_51 > 0)
                                                                                            {
                                                                                                uint64_t throttles_3 = throttles;
                                                                                                int64_t i_2;
                                                                                                
                                                                                                if (rcx_51 != 1)
                                                                                                {
                                                                                                    i_2 = 0;
                                                                                                    
                                                                                                    do
                                                                                                    {
                                                                                                        int64_t rbp_10 = (rax_212[(i_2 + 4)] * 0x30);
                                                                                                        *((throttles_3 + rbp_10) + 0x20) += rax_262;
                                                                                                        int64_t rbp_13 = (rax_212[(i_2 + 5)] * 0x30);
                                                                                                        *((throttles_3 + rbp_13) + 0x20) += rax_262;
                                                                                                        i_2 += 2;
                                                                                                    } while ((rcx_51 & 0xfffffffe) != i_2);
                                                                                                }
                                                                                                else
                                                                                                    i_2 = 0;
                                                                                                
                                                                                                if ((rcx_51 & 1) != 0)
                                                                                                {
                                                                                                    int64_t rcx_54 = (rax_212[(i_2 + 4)] * 0x30);
                                                                                                    *((throttles_3 + rcx_54) + 0x20) += rax_262;
                                                                                                }
                                                                                            }
                                                                                            
                                                                                            *(rax_212 + 0x88) = rax_262;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                else
                                                                                {
                                                                                    int64_t rbx_8 = 1;
                                                                                    int64_t rbp_5 = 0;
                                                                                    
                                                                                    while (true)
                                                                                    {
                                                                                        if (match(*(throttles + rbp_5), *(*(rax_212 + 8) + 0xf0)) != 0)
                                                                                        {
                                                                                            uint64_t throttles_2 = throttles;
                                                                                            int64_t rax_224 = *((throttles_2 + rbp_5) + 8);
                                                                                            int64_t rsi_21 = *((throttles_2 + rbp_5) + 0x18);
                                                                                            int64_t rcx_28;
                                                                                            
                                                                                            if (rsi_21 <= (rax_224 * 2))
                                                                                                rcx_28 = *((throttles_2 + rbp_5) + 0x10);
                                                                                            
                                                                                            if ((rsi_21 > (rax_224 * 2) || rsi_21 < rcx_28))
                                                                                                break;
                                                                                            
                                                                                            if (*((throttles_2 + rbp_5) + 0x28) < 0)
                                                                                            {
                                                                                                syslog(3, "throttle sending count was negatâ€¦");
                                                                                                throttles_2 = throttles;
                                                                                                *((throttles_2 + rbp_5) + 0x28) = 0;
                                                                                                rax_224 = *((throttles_2 + rbp_5) + 8);
                                                                                                rcx_28 = *((throttles_2 + rbp_5) + 0x10);
                                                                                            }
                                                                                            
                                                                                            int64_t rsi_22 = rax_212[0xe];
                                                                                            rax_212[0xe] = (rsi_22 + 1);
                                                                                            rax_212[(rsi_22 + 4)] = (rbx_8 - 1);
                                                                                            int64_t rsi_24 = (*((throttles_2 + rbp_5) + 0x28) + 1);
                                                                                            *((throttles_2 + rbp_5) + 0x28) = rsi_24;
                                                                                            int64_t rax_227;
                                                                                            
                                                                                            if (((rax_224 | rsi_24) >> 0x20) == 0)
                                                                                                rax_227 = (COMBINE(0, rax_224) / rsi_24);
                                                                                            else
                                                                                                rax_227 = (rax_224 / rsi_24);
                                                                                            
                                                                                            int64_t rdx_45 = *(rax_212 + 0x40);
                                                                                            int64_t rsi_25 = rax_227;
                                                                                            
                                                                                            if (rdx_45 < rax_227)
                                                                                                rsi_25 = rdx_45;
                                                                                            
                                                                                            int64_t rdi_163 = *(rax_212 + 0x48);
                                                                                            
                                                                                            if (rdx_45 == -1)
                                                                                                rsi_25 = rax_227;
                                                                                            
                                                                                            *(rax_212 + 0x40) = rsi_25;
                                                                                            int64_t rax_228 = rcx_28;
                                                                                            
                                                                                            if (rdi_163 > rcx_28)
                                                                                                rax_228 = rdi_163;
                                                                                            
                                                                                            if (rdi_163 == -1)
                                                                                                rax_228 = rcx_28;
                                                                                            
                                                                                            *(rax_212 + 0x48) = rax_228;
                                                                                        }
                                                                                        
                                                                                        if (rbx_8 >= numthrottles)
                                                                                            goto label_765d;
                                                                                        
                                                                                        rbp_5 += 0x30;
                                                                                        rbx_8 += 1;
                                                                                        
                                                                                        if (rax_212[0xe] >= 0xa)
                                                                                            goto label_765d;
                                                                                    }
                                                                                    
                                                                                    httpd_send_err(r12_3, 0x1f7, httpd_err503title, &data_13553, httpd_err503form, *(r12_3 + 0xd0));
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                
                                                                httpd_write_response(*(rax_212 + 8));
                                                            }
                                                        }
                                                        
                                                        clear_connection(rax_212, &pai);
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                int32_t rdi_149 = *(hs_2 + 0x4c);
                                                
                                                if (rdi_149 == 0xffffffff)
                                                {
                                                label_73a1:
                                                    uint64_t hs_3 = hs;
                                                    
                                                    if (hs_3 == 0)
                                                        goto label_7419;
                                                    
                                                    int32_t rdi_151 = *(hs_3 + 0x48);
                                                    
                                                    if (rdi_151 == 0xffffffff)
                                                        goto label_7419;
                                                    
                                                    if (fdwatch_check_fd(rdi_151) == 0)
                                                        goto label_7419;
                                                    
                                                    if (handle_newconnect(&pai, *(hs + 0x48)) == 0)
                                                        goto label_7419;
                                                }
                                                else
                                                {
                                                    if (fdwatch_check_fd(rdi_149) == 0)
                                                        goto label_73a1;
                                                    
                                                    if (handle_newconnect(&pai, *(hs + 0x4c)) == 0)
                                                        goto label_73a1;
                                                }
                                            }
                                        }
                                    }
                                    
                                    if (terminate != 0)
                                    {
                                        if (num_connects <= 0)
                                            goto label_7c52;
                                    }
                                }
                                
                                goto label_6c43;
                            }
                            
                            syslog(2, "data_dir chdir - %m");
                            logfile_3 = "data_dir chdir";
                        }
                        else if (chroot(&var_3ac8) >= 0)
                        {
                            argv_1 = r14_3;
                            uint64_t logfile_5 = logfile;
                            
                            if ((logfile_5 != 0 && strcmp(logfile_5, "-") != 0))
                            {
                                uint64_t rax_162 = strlen(&var_3ac8);
                                
                                if (strncmp(logfile_5, &var_3ac8, rax_162) == 0)
                                    memmove(logfile_5, ((rax_162 + logfile_5) - 1), (strlen(((rax_162 + logfile_5) - 1)) + 1));
                                else
                                {
                                    syslog(4, "logfile is not within the chrootâ€¦");
                                    fprintf(*stderr, "%s: logfile is not within the châ€¦", argv0);
                                }
                            }
                            
                            var_3ac8 = 0x2f;
                            bool cond:5_1 = chdir(&var_3ac8) >= 0;
                            r14_3 = argv_1;
                            
                            if (cond:5_1)
                                goto label_6d5c;
                            
                            syslog(2, "chroot chdir - %m");
                            logfile_3 = "chroot chdir";
                        }
                        else
                        {
                            syslog(2, "chroot - %m");
                            logfile_3 = "chroot";
                        }
                    }
                    else
                    {
                        syslog(2, "chdir - %m");
                        logfile_3 = "chdir";
                    }
                }
                else
                {
                    if (strcmp(logfile_2, "/dev/null") == 0)
                    {
                        no_log = 1;
                        fp_3 = nullptr;
                        goto label_6882;
                    }
                    
                    if (strcmp(logfile_2, "-") == 0)
                    {
                        fp_3 = *stdout;
                        goto label_6882;
                    }
                    
                    FILE* fp_9 = fopen(logfile_2, "a");
                    uint64_t logfile_1 = logfile;
                    
                    if (fp_9 != 0)
                    {
                        fp_3 = fp_9;
                        
                        if (*logfile_1 != 0x2f)
                        {
                            syslog(4, "logfile is not an absolute path,â€¦");
                            fprintf(*stderr, "%s: logfile is not an absolute pâ€¦", argv0);
                        }
                        
                        fcntl(fileno(fp_3), 2, 1);
                        
                        if ((getuid() == 0 && fchown(fileno(fp_3), pw_uid, pw_gid) < 0))
                        {
                            syslog(4, "fchown logfile - %m");
                            perror("fchown logfile");
                        }
                        
                        goto label_6882;
                    }
                    
                    syslog(2, "%.80s - %m", logfile_1);
                    logfile_3 = logfile;
                }
                goto label_68b1;
            }
            
            FILE* fp_7 = fp_5;
            
            while (true)
            {
                char* rax_138 = strchr(&var_3ac8, 0x23);
                
                if (rax_138 != 0)
                    *rax_138 = 0;
                
                int32_t rax_139 = strlen(&var_3ac8);
                
                if (rax_139 > 0)
                {
                    int64_t rax_141 = (rax_139 + 1);
                    
                    while (true)
                    {
                        uint64_t rcx_19 = (rax_141 - 2);
                        uint64_t rdx_16 = *(&var_3ac8 + rcx_19);
                        
                        if (rdx_16 > 0x20)
                            break;
                        
                        if (!((TEST_BITQ(0x100002600, rdx_16))))
                            break;
                        
                        *(&var_3ac8 + rcx_19) = 0;
                        rax_141 -= 1;
                        
                        if (rax_141 <= 1)
                            goto label_6a1b;
                    }
                    
                    goto label_6a9b;
                }
                
                if (rax_139 != 0)
                {
                label_6a9b:
                    int64_t var_3bd8;
                    int64_t var_3bd0;
                    
                    if (__isoc99_sscanf(&var_3ac8, " %4900[^ \t] %ld-%ld", &var_13b8, &var_3bd8, &var_3bd0) == 3)
                        goto label_6ad8;
                    
                    if (__isoc99_sscanf(&var_3ac8, " %4900[^ \t] %ld", &var_13b8, &var_3bd0) != 2)
                    {
                        int64_t r12_1 = var_3c00;
                        syslog(2, "unparsable line in %.80s - %.80s", r12_1, &var_3ac8);
                        fprintf(*stderr, "%s: unparsable line in %.80s - %â€¦", argv0, r12_1, &var_3ac8);
                    }
                    else
                    {
                        var_3bd8 = 0;
                    label_6ad8:
                        void var_13b7;
                        
                        if (var_13b8 == 0x2f)
                            memmove(&var_13b8, &var_13b7, (strlen(&var_13b7) + 1));
                        char* i_5 = strstr(&var_13b8, &data_1285a);
                        
                        if (i_5 != 0)
                        {
                            char* i_4 = i_5;
                            char* i_3;
                            
                            do
                            {
                                memmove(&i_4[1], &i_4[2], (strlen(&i_4[2]) + 1));
                                i_3 = strstr(&var_13b8, &data_1285a);
                                i_4 = i_3;
                            } while (i_3 != 0);
                        }
                        
                        int64_t numthrottles_1 = numthrottles;
                        int64_t maxthrottles_1 = maxthrottles;
                        fp_5 = fp_7;
                        
                        if (numthrottles_1 >= maxthrottles_1)
                        {
                            uint64_t rax_149;
                            
                            if (maxthrottles_1 == 0)
                            {
                                maxthrottles = 0x64;
                                rax_149 = malloc("libcrypt.so.1");
                            }
                            else
                            {
                                maxthrottles = (maxthrottles_1 * 2);
                                rax_149 = realloc(throttles, (maxthrottles_1 * 0x60));
                            }
                            
                            throttles = rax_149;
                            
                            if (rax_149 == 0)
                            {
                                syslog(2, "out of memory allocating a throtâ€¦");
                                stream = *stderr;
                                argv0_1 = argv0;
                                format = "%s: out of memory allocating a tâ€¦";
                                goto label_709c;
                            }
                        }
                        
                        char* rax_150 = strdup(&var_13b8);
                        
                        if (rax_150 == 0)
                            break;
                        
                        char** throttles_1 = throttles;
                        int64_t rdx_22 = (numthrottles_1 * 0x30);
                        *(throttles_1 + rdx_22) = rax_150;
                        *((throttles_1 + rdx_22) + 8) = var_3bd0;
                        *((throttles_1 + rdx_22) + 0x10) = var_3bd8;
                        *((throttles_1 + rdx_22) + 0x18) = {0};
                        *((throttles_1 + rdx_22) + 0x28) = 0;
                        numthrottles = (numthrottles_1 + 1);
                    }
                }
                
            label_6a1b:
                
                if (fgets(&var_3ac8, 0x1388, fp_5) == 0)
                    goto label_674c;
            }
            
        label_707d:
            syslog(2, "out of memory copying a string");
            stream = *stderr;
            argv0_1 = argv0;
            format = "%s: out of memory copying a striâ€¦";
        }
    }
    
label_709c:
    fprintf(stream, format, argv0_1);
    exit(1);
    /* no return */
}

void handle_term(int32_t arg1) __noreturn
{
    shut_down();
    syslog(5, "exiting due to signal %d", arg1);
    closelog();
    exit(1);
    /* no return */
}

int32_t handle_chld()
{
    int64_t rax;
    int64_t var_28 = rax;
    int32_t* rax_1 = __errno_location();
    int32_t r15 = *rax_1;
    int32_t i;
    
    for (i = waitpid(0xffffffff, &*var_28[4], 1); i != 0; i = waitpid(0xffffffff, &*var_28[4], 1))
    {
        if (i < 0)
        {
            i = *rax_1;
            
            if ((i != 4 && i != 0xb))
            {
                if (i != 0xa)
                    i = syslog(3, "child wait - %m");
                
                break;
            }
        }
        else
        {
            uint64_t hs_1 = hs;
            
            if (hs_1 != 0)
            {
                int32_t rcx_1 = *(hs_1 + 0x24);
                
                if (rcx_1 <= 0)
                    rcx_1 = 1;
                
                *(hs_1 + 0x24) = (rcx_1 - 1);
            }
        }
    }
    
    *rax_1 = r15;
    return i;
}

int64_t handle_hup()
{
    got_hup = 1;
}

void handle_usr1()
{
    if (num_connects != 0)
    {
        got_usr1 = 1;
        return;
    }
    
    shut_down();
    syslog(5, "exiting");
    closelog();
    exit(0);
    /* no return */
}

int64_t handle_usr2()
{
    int64_t rax;
    int64_t var_18 = rax;
    int32_t* rax_1 = __errno_location();
    int32_t rbp = *rax_1;
    int64_t result = logstats(nullptr);
    *rax_1 = rbp;
    return result;
}

int64_t handle_alrm()
{
    int64_t rax;
    int64_t var_18 = rax;
    int32_t* rax_1 = __errno_location();
    int32_t rbp = *rax_1;
    
    if (watchdog_flag == 0)
    {
        chdir("/tmp");
        abort();
        /* no return */
    }
    
    watchdog_flag = 0;
    int64_t result = alarm(0x168);
    *rax_1 = rbp;
    return result;
}

int64_t occasional(int64_t arg1, int64_t* arg2)
{
    mmc_cleanup(arg2);
    int64_t result = tmr_cleanup();
    watchdog_flag = 1;
    return result;
}

void idle(int64_t arg1, int64_t* arg2)
{
    int64_t rax;
    int64_t var_38 = rax;
    
    if (max_connects > 0)
    {
        int64_t r15_1 = 0;
        int64_t i = 0;
        
        do
        {
            uint64_t connects_1 = connects;
            int32_t rax_1 = *(connects_1 + r15_1);
            
            if ((rax_1 - 2) >= 2)
            {
                if ((rax_1 == 1 && (*arg2 - *((connects_1 + r15_1) + 0x58)) >= 0x3c))
                {
                    httpd_ntoa((*((connects_1 + r15_1) + 8) + 0x10));
                    syslog(6, "%.80s connection timed out readiâ€¦", &httpd_ntoa.str);
                    httpd_send_err(*((connects_1 + r15_1) + 8), 0x198, httpd_err408title, &data_13553, httpd_err408form, &data_13553);
                    httpd_write_response(*((connects_1 + r15_1) + 8));
                    clear_connection((connects_1 + r15_1), arg2);
                }
            }
            else if ((*arg2 - *((connects_1 + r15_1) + 0x58)) >= 0x12c)
            {
                httpd_ntoa((*((connects_1 + r15_1) + 8) + 0x10));
                syslog(6, "%.80s connection timed out sendiâ€¦", &httpd_ntoa.str);
                clear_connection((connects_1 + r15_1), arg2);
            }
            
            i += 1;
            r15_1 += 0x90;
        } while (i < max_connects);
    }
}

void update_throttles()
{
    int64_t rax;
    int64_t var_38 = rax;
    
    if (numthrottles > 0)
    {
        int64_t rbx_1 = 0x28;
        uint64_t throttles_1 = throttles;
        int64_t i = 0;
        
        do
        {
            int64_t r9_1 = *((throttles_1 + rbx_1) - 0x20);
            int64_t rdx_1 = *((throttles_1 + rbx_1) - 8);
            int64_t rax_3;
            int64_t rdx_2;
            rdx_2 = HIGHQ((((((rdx_1 >> 0x3f) + rdx_1) >> 1) + (*((throttles_1 + rbx_1) - 0x10) << 1)) * 0x5555555555555556));
            rax_3 = LOWQ((((((rdx_1 >> 0x3f) + rdx_1) >> 1) + (*((throttles_1 + rbx_1) - 0x10) << 1)) * 0x5555555555555556));
            int64_t r8_3 = ((rdx_2 >> 0x3f) + rdx_2);
            *((throttles_1 + rbx_1) - 0x10) = r8_3;
            *((throttles_1 + rbx_1) - 8) = 0;
            
            if (r8_3 > r9_1)
            {
                int32_t rax_4 = *(throttles_1 + rbx_1);
                
                if (rax_4 != 0)
                {
                    char const* const fmt;
                    int64_t pri;
                    
                    if (r8_3 <= (r9_1 * 2))
                    {
                        var_38 = rax_4;
                        pri = 6;
                        fmt = "throttle #%d '%.80s' rate %ld exâ€¦";
                    }
                    else
                    {
                        var_38 = rax_4;
                        pri = 5;
                        fmt = "throttle #%d '%.80s' rate %ld grâ€¦";
                    }
                    
                    syslog(pri, fmt, i);
                }
            }
            
            throttles_1 = throttles;
            int64_t r9_2 = *((throttles_1 + rbx_1) - 0x18);
            int64_t r8_4 = *((throttles_1 + rbx_1) - 0x10);
            
            if (r8_4 < r9_2)
            {
                int32_t rax_6 = *(throttles_1 + rbx_1);
                
                if (rax_6 != 0)
                {
                    var_38 = rax_6;
                    syslog(5, "throttle #%d '%.80s' rate %ld loâ€¦", i, *((throttles_1 + rbx_1) - 0x28), r8_4, r9_2, var_38);
                    throttles_1 = throttles;
                }
            }
            
            i += 1;
            rbx_1 += 0x30;
        } while (i < numthrottles);
    }
    
    uint64_t max_connects_1 = max_connects;
    
    if (max_connects_1 > 0)
    {
        int32_t* connects_1 = connects;
        uint64_t throttles_2 = throttles;
        void* rbp_1 = &connects_1[4];
        int64_t r11_1 = 0;
        
        do
        {
            rax = (r11_1 * 0x90);
            
            if ((*(connects_1 + rax) & 0xfffffffe) == 2)
            {
                *((connects_1 + rax) + 0x40) = -1;
                uint64_t r14_1 = *((connects_1 + rax) + 0x38);
                
                if (r14_1 > 0)
                {
                    int64_t* r9_4 = ((connects_1 + rax) + 0x40);
                    int64_t rsi_5 = -1;
                    int64_t rbx_2 = 0;
                    
                    do
                    {
                        int64_t rcx_6 = (*(rbp_1 + (rbx_2 << 2)) * 0x30);
                        int64_t rax_11 = *((throttles_2 + rcx_6) + 8);
                        int64_t rcx_7 = *((throttles_2 + rcx_6) + 0x28);
                        
                        if (((rax_11 | rcx_7) >> 0x20) != 0)
                            rax = (rax_11 / rcx_7);
                        else
                            rax = (COMBINE(0, rax_11) / rcx_7);
                        
                        int64_t rcx_4 = rax;
                        
                        if (rsi_5 < rax)
                            rcx_4 = rsi_5;
                        
                        bool cond:1_1 = rsi_5 == -1;
                        rsi_5 = rcx_4;
                        
                        if (cond:1_1)
                            rsi_5 = rax;
                        
                        rbx_2 += 1;
                    } while (r14_1 != rbx_2);
                    
                    *r9_4 = rsi_5;
                }
            }
            
            r11_1 += 1;
            rbp_1 += 0x90;
        } while (r11_1 != max_connects_1);
    }
}

int64_t show_stats(int64_t arg1, void* arg2)
{
    /* tailcall */
    return logstats(arg2);
}

int64_t handle_newconnect(int64_t* arg1, int32_t arg2)
{
    int64_t rax;
    int64_t var_38 = rax;
    
    if (num_connects < max_connects)
    {
        while (true)
        {
            int64_t first_free_connect_1 = first_free_connect;
            int64_t rbx_2;
            uint64_t connects_1;
            
            if (first_free_connect_1 != -1)
            {
                connects_1 = connects;
                rbx_2 = (first_free_connect_1 * 0x90);
            }
            
            char const* const fmt;
            
            if ((first_free_connect_1 == -1 || *(connects_1 + rbx_2) != 0))
                fmt = "the connects free list is messedâ€¦";
            else
            {
                int32_t* rax_2 = *((connects_1 + rbx_2) + 8);
                
                if (rax_2 != 0)
                    goto label_846a;
                
                rax_2 = malloc(0x2d0);
                *((rbx_2 + connects_1) + 8) = rax_2;
                
                if (rax_2 == 0)
                    fmt = "out of memory allocating an httpâ€¦";
                else
                {
                    *rax_2 = 0;
                    httpd_conn_count += 1;
                label_846a:
                    int32_t rax_3 = httpd_get_conn(hs, arg2, rax_2);
                    
                    if (rax_3 == 0)
                        goto label_8527;
                    
                    if (rax_3 == 2)
                        return 1;
                    
                    int64_t r13_1 = (rbx_2 + connects_1);
                    *r13_1 = 1;
                    first_free_connect = *((connects_1 + rbx_2) + 4);
                    *((connects_1 + rbx_2) + 4) = 0xffffffff;
                    num_connects += 1;
                    *((connects_1 + rbx_2) + 0x58) = *arg1;
                    *((connects_1 + rbx_2) + 0x88) = 0;
                    *((connects_1 + rbx_2) + 0x38) = 0;
                    *((connects_1 + rbx_2) + 0x60) = {0};
                    httpd_set_ndelay(*(*((rbx_2 + connects_1) + 8) + 0x2c0));
                    fdwatch_add_fd(*(*((rbx_2 + connects_1) + 8) + 0x2c0), r13_1, 0);
                    stats_connections += 1;
                    uint32_t num_connects_1 = num_connects;
                    
                    if (num_connects_1 > stats_simultaneous)
                        stats_simultaneous = num_connects_1;
                    
                    if (num_connects_1 >= max_connects)
                        break;
                    
                    continue;
                }
            }
            
            syslog(2, fmt);
            exit(1);
            /* no return */
        }
    }
    
    syslog(4, "too many connections!");
label_8527:
    tmr_run(arg1);
    return 0;
}

uint64_t clear_connection(int32_t* arg1, int64_t* arg2)
{
    int64_t rax;
    int64_t var_18 = rax;
    uint64_t rdi = *(arg1 + 0x60);
    
    if (rdi != 0)
    {
        tmr_cancel(rdi);
        *(arg1 + 0x60) = 0;
    }
    
    if (*arg1 != 4)
    {
        void* rax_2 = *(arg1 + 8);
        
        if (*(rax_2 + 0x22c) != 0)
        {
            if (*arg1 != 3)
            {
                fdwatch_del_fd(*(rax_2 + 0x2c0));
                rax_2 = *(arg1 + 8);
            }
            
            *arg1 = 4;
            shutdown(*(rax_2 + 0x2c0), 1);
            fdwatch_add_fd(*(*(arg1 + 8) + 0x2c0), arg1, 0);
            
            if (*(arg1 + 0x68) != 0)
                syslog(3, "replacing non-null linger_timer!");
            
            uint64_t result = tmr_create(arg2, linger_clear_connection, arg1, 0x1f4, 0);
            *(arg1 + 0x68) = result;
            
            if (result != 0)
                return result;
            
            syslog(2, "tmr_create(linger_clear_connectiâ€¦");
            exit(1);
            /* no return */
        }
    }
    else
    {
        tmr_cancel(*(arg1 + 0x68));
        *(arg1 + 0x68) = 0;
        *(*(arg1 + 8) + 0x22c) = 0;
    }
    
    /* tailcall */
    return really_clear_connection(arg1, arg2);
}

int64_t shut_down()
{
    void var_30;
    gettimeofday(&var_30, nullptr);
    logstats(&var_30);
    
    if (max_connects > 0)
    {
        int64_t rbx_1 = 8;
        uint64_t connects_1 = connects;
        int64_t i = 0;
        
        do
        {
            if (*((connects_1 + rbx_1) - 8) != 0)
            {
                httpd_close_conn(*(connects_1 + rbx_1), &var_30);
                connects_1 = connects;
            }
            
            int32_t* rdi_3 = *(connects_1 + rbx_1);
            
            if (rdi_3 != 0)
            {
                httpd_destroy_conn(rdi_3);
                connects_1 = connects;
                free(*(connects_1 + rbx_1));
                httpd_conn_count -= 1;
                *(connects_1 + rbx_1) = 0;
            }
            
            i += 1;
            rbx_1 += 0x90;
        } while (i < max_connects);
    }
    
    uint64_t hs_1 = hs;
    
    if (hs_1 != 0)
    {
        hs = 0;
        int32_t rdi_5 = *(hs_1 + 0x48);
        
        if (rdi_5 != 0xffffffff)
            fdwatch_del_fd(rdi_5);
        
        int32_t rdi_6 = *(hs_1 + 0x4c);
        
        if (rdi_6 != 0xffffffff)
            fdwatch_del_fd(rdi_6);
        
        httpd_terminate(hs_1);
    }
    
    mmc_term();
    tmr_term();
    int64_t result = free(connects);
    uint64_t throttles_1 = throttles;
    
    if (throttles_1 == 0)
        return result;
    
    return free(throttles_1);
}

int64_t logstats(void* arg1)
{
    void* rbx = arg1;
    
    if (arg1 == 0)
    {
        void var_18;
        rbx = &var_18;
        gettimeofday(&var_18, nullptr);
    }
    
    uint64_t rax = *rbx;
    uint64_t rdx_1 = (rax - start_time);
    uint64_t rbx_1 = 1;
    
    if (rax != stats_time)
        rbx_1 = (rax - stats_time);
    
    stats_time = rax;
    syslog(5, "up %ld seconds, stats for %ld seâ€¦", rdx_1, rbx_1);
    
    if (rbx_1 > 0)
    {
        float zmm1_1 = rbx_1;
        int64_t rax_2;
        rax_2 = 2;
        syslog(5, "  thttpd - %ld connections (%g/sâ€¦", (stats_connections / zmm1_1), (stats_bytes / zmm1_1));
    }
    
    stats_connections = 0;
    stats_bytes = 0;
    stats_simultaneous = 0;
    int64_t rax_4 = mmc_logstats(httpd_logstats());
    fdwatch_logstats(rbx_1);
    /* tailcall */
    return tmr_logstats(rax_4);
}

void usage() __noreturn
{
    fprintf(*stderr, "usage:  %s [-C configfile] [-p pâ€¦", argv0);
    exit(1);
    /* no return */
}

void wakeup_connection(int32_t* arg1)
{
    *(arg1 + 0x60) = 0;
    
    if (*arg1 != 3)
        return;
    
    *arg1 = 2;
    /* tailcall */
    return fdwatch_add_fd(*(*(arg1 + 8) + 0x2c0), arg1, 1);
}

uint32_t really_clear_connection(int32_t* arg1, int64_t* arg2)
{
    int64_t rax;
    int64_t var_18 = rax;
    void* rdi = *(arg1 + 8);
    stats_bytes += *(rdi + 0xc8);
    
    if (*arg1 != 3)
    {
        fdwatch_del_fd(*(rdi + 0x2c0));
        rdi = *(arg1 + 8);
    }
    
    httpd_close_conn(rdi, arg2);
    int32_t rax_2 = arg1[0xe];
    
    if (rax_2 > 0)
    {
        uint64_t throttles_1 = throttles;
        int64_t i;
        
        if (rax_2 != 1)
        {
            i = 0;
            
            do
            {
                int64_t rdi_4 = (arg1[(i + 4)] * 0x30);
                *((throttles_1 + rdi_4) + 0x28) -= 1;
                int64_t rdi_7 = (arg1[(i + 5)] * 0x30);
                *((throttles_1 + rdi_7) + 0x28) -= 1;
                i += 2;
            } while ((rax_2 & 0xfffffffe) != i);
        }
        else
            i = 0;
        
        if ((rax_2 & 1) != 0)
        {
            int64_t rax_5 = (arg1[(i + 4)] * 0x30);
            *((throttles_1 + rax_5) + 0x28) -= 1;
        }
    }
    
    uint64_t rdi_8 = *(arg1 + 0x68);
    
    if (rdi_8 != 0)
    {
        tmr_cancel(rdi_8);
        *(arg1 + 0x68) = 0;
    }
    
    *arg1 = 0;
    arg1[1] = first_free_connect;
    uint32_t result = (((arg1 - connects) >> 4) * 0x38e38e39);
    first_free_connect = result;
    num_connects -= 1;
    return result;
}

int64_t linger_clear_connection(int32_t* arg1, int64_t* arg2)
{
    *(arg1 + 0x68) = 0;
    /* tailcall */
    return really_clear_connection(arg1, arg2);
}

char** httpd_initialize(char* arg1, int16_t* arg2, int16_t* arg3, int16_t arg4, char* arg5, int32_t arg6, char* arg7, char* arg8, int32_t arg9, char* arg10, int32_t arg11, int64_t arg12, int32_t arg13, int32_t arg14, int32_t arg15, char* arg16, char* arg17, int32_t arg18)
{
    char** result_1 = malloc(0x88);
    char** result;
    
    if (result_1 == 0)
    {
        result = nullptr;
        syslog(2, "out of memory allocating an httpâ€¦");
    }
    else
    {
        result = result_1;
        
        if (arg1 == 0)
        {
            *result = {0};
            
            if (gethostname(&httpd_initialize.ghnbuf, 0x100) < 0)
                httpd_initialize.ghnbuf = 0;
            else if ((result[1] == 0 && httpd_initialize.ghnbuf != 0))
                result[1] = &httpd_initialize.ghnbuf;
            
            goto label_8aa3;
        }
        
        char* rax = strdup(arg1);
        *result = rax;
        
        if (rax == 0)
        {
            result = nullptr;
            syslog(2, "out of memory copying hostname");
        }
        else
        {
            result[1] = rax;
        label_8aa3:
            result[2] = arg4;
            
            if (arg5 == 0)
            {
                result[3] = 0;
            label_8b40:
                result[4] = arg6;
                *(result + 0x24) = 0;
                result[5] = strdup(arg7);
                result[6] = strdup(arg8);
                result[7] = arg9;
                char* rax_6 = strdup(arg10);
                result[8] = rax_6;
                
                if (rax_6 == 0)
                {
                    result = nullptr;
                    syslog(2, "out of memory copying cwd");
                }
                else
                {
                    int16_t* sa_1;
                    
                    if (arg16 == 0)
                    {
                        result[0xe] = 0;
                        sa_1 = arg3;
                    label_8bc2:
                        int16_t* sa;
                        
                        if (arg17 == 0)
                        {
                            result[0xf] = 0;
                            sa = arg2;
                        label_8c34:
                            result[0xa] = arg11;
                            result[0xb] = arg12;
                            result[0xc] = arg13;
                            *(result + 0x64) = arg14;
                            result[0xd] = arg15;
                            result[0x10] = arg18;
                            int32_t rax_12;
                            
                            if (sa_1 == 0)
                                rax_12 = -1;
                            else
                                rax_12 = initialize_listen_socket(sa_1);
                            
                            *(result + 0x4c) = rax_12;
                            void* r12_2;
                            
                            if (sa == 0)
                            {
                                r12_2 = &result[9];
                                result[9] = 0xffffffff;
                                
                                if (rax_12 == 0xffffffff)
                                {
                                    free_httpd_server(result);
                                    return nullptr;
                                }
                            }
                            else
                            {
                                int32_t rax_13 = initialize_listen_socket(sa);
                                r12_2 = &result[9];
                                result[9] = rax_13;
                                
                                if ((rax_13 == 0xffffffff && *(result + 0x4c) == 0xffffffff))
                                {
                                    free_httpd_server(result);
                                    return nullptr;
                                }
                            }
                            
                            qsort(&enc_tab, 3, 0x20, ext_compare);
                            qsort(&typ_tab, 0xc1, 0x20, ext_compare);
                            data_193d8 = strlen(enc_tab);
                            data_193e8 = strlen(data_193e0);
                            data_193f8 = strlen(data_193f0);
                            data_19408 = strlen(data_19400);
                            data_19418 = strlen(data_19410);
                            data_19428 = strlen(data_19420);
                            
                            for (int64_t i = 0x18; i != 0x1838; i += 0x20)
                            {
                                *(i + &data_19420) = strlen(*(i + &data_19418));
                                *(i + &typ_tab) = strlen(*(i + &data_19428));
                            }
                            
                            if (*result == 0)
                                syslog(5, "%.80s starting on port %d", "thttpd/2.29 23May2018", result[2]);
                            else
                            {
                                if (*r12_2 == 0xffffffff)
                                    sa = sa_1;
                                
                                int16_t rax_23 = *sa;
                                socklen_t addrlen_1 = 0x1c;
                                
                                if (rax_23 != 0xa)
                                    addrlen_1 = 0;
                                
                                socklen_t addrlen = 0x10;
                                
                                if (rax_23 != 2)
                                    addrlen = addrlen_1;
                                
                                if (getnameinfo(sa, addrlen, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                                    httpd_ntoa.str = 0x3f;
                                else if ((*(sa + 8) == 0 && (*(sa + 0xc) == 0 && (*(sa + 0x10) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                                    memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                                
                                syslog(5, "%.80s starting on %.80s, port %d", "thttpd/2.29 23May2018", &httpd_ntoa.str, result[2]);
                            }
                        }
                        else
                        {
                            char* rax_8 = strdup(arg17);
                            result[0xf] = rax_8;
                            sa = arg2;
                            
                            if (rax_8 != 0)
                                goto label_8c34;
                            
                            result = nullptr;
                            syslog(2, "out of memory copying local_pattâ€¦");
                        }
                    }
                    else
                    {
                        char* rax_7 = strdup(arg16);
                        result[0xe] = rax_7;
                        sa_1 = arg3;
                        
                        if (rax_7 != 0)
                            goto label_8bc2;
                        
                        result = nullptr;
                        syslog(2, "out of memory copying url_patterâ€¦");
                    }
                }
            }
            else
            {
                void* rdi_1;
                rdi_1 = *arg5 == 0x2f;
                char* rax_2 = strdup((rdi_1 + arg5));
                result[3] = rax_2;
                
                if (rax_2 != 0)
                {
                    char* i_3 = strstr(rax_2, &data_1285a);
                    
                    if (i_3 != 0)
                    {
                        char* i_2 = i_3;
                        char* i_1;
                        
                        do
                        {
                            memmove(&i_2[1], &i_2[2], (strlen(&i_2[2]) + 1));
                            i_1 = strstr(result[3], &data_1285a);
                            i_2 = i_1;
                        } while (i_1 != 0);
                    }
                    
                    goto label_8b40;
                }
                
                result = nullptr;
                syslog(2, "out of memory copying cgi_patterâ€¦");
            }
        }
    }
    
    return result;
}

void httpd_set_logfp(void* arg1, int64_t arg2)
{
    int64_t rax;
    int64_t var_18 = rax;
    FILE* fp = *(arg1 + 0x58);
    
    if (fp != 0)
        fclose(fp);
    
    *(arg1 + 0x58) = arg2;
}

uint64_t initialize_listen_socket(int16_t* arg1)
{
    int32_t fd;
    
    if ((*arg1 & 0xfff7) != 2)
    {
        syslog(2, "unknown sockaddr family on listeâ€¦");
        fd = -1;
    }
    else
    {
        int32_t fd_1 = socket();
        
        if (fd_1 < 0)
        {
            int16_t rax_14 = *arg1;
            socklen_t addrlen_2 = 0x1c;
            
            if (rax_14 != 0xa)
                addrlen_2 = 0;
            
            socklen_t addrlen_1 = 0x10;
            
            if (rax_14 != 2)
                addrlen_1 = addrlen_2;
            
            if (getnameinfo(arg1, addrlen_1, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                httpd_ntoa.str = 0x3f;
            else if ((*(arg1 + 8) == 0 && (*(arg1 + 0xc) == 0 && (*(arg1 + 0x10) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
            
            syslog(2, "socket %.80s - %m", &httpd_ntoa.str);
            fd = -1;
        }
        else
        {
            fd = fd_1;
            int32_t rbp_1 = 0;
            fcntl(fd_1, 2, 1);
            int32_t var_2c = 1;
            
            if (setsockopt(fd, 1, 2, &var_2c, 4) < 0)
                syslog(2, "setsockopt SO_REUSEADDR - %m");
            
            int16_t rax_5 = *arg1;
            socklen_t addrlen = 0x1c;
            
            if (rax_5 == 0xa)
                rbp_1 = 0x1c;
            
            if (rax_5 == 2)
                rbp_1 = 0x10;
            
            if (bind(fd, arg1, rbp_1) < 0)
            {
                int16_t rax_16 = *arg1;
                
                if (rax_16 != 0xa)
                    addrlen = 0;
                
                if (rax_16 == 2)
                    addrlen = 0x10;
                
                if (getnameinfo(arg1, addrlen, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                    httpd_ntoa.str = 0x3f;
                else if ((*(arg1 + 8) == 0 && (*(arg1 + 0xc) == 0 && (*(arg1 + 0x10) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                    memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                
                syslog(2, "bind %.80s - %m", &httpd_ntoa.str);
                close(fd);
                fd = -1;
            }
            else
            {
                int32_t rax_8 = fcntl(fd, 3, 0);
                char const* const fmt;
                
                if (rax_8 == 0xffffffff)
                {
                    fmt = "fcntl F_GETFL - %m";
                label_9126:
                    syslog(2, fmt);
                    close(fd);
                    fd = -1;
                }
                else
                {
                    if (fcntl(fd, 4, (rax_8 | 0x800)) < 0)
                    {
                        fmt = "fcntl O_NDELAY - %m";
                        goto label_9126;
                    }
                    
                    if (listen(fd, 0x400) < 0)
                    {
                        fmt = "listen - %m";
                        goto label_9126;
                    }
                }
            }
        }
    }
    
    return fd;
}

int64_t free_httpd_server(int64_t* arg1)
{
    int64_t rdi = *arg1;
    
    if (rdi != 0)
        free(rdi);
    
    int64_t rdi_1 = arg1[8];
    
    if (rdi_1 != 0)
        free(rdi_1);
    
    int64_t rdi_2 = arg1[3];
    
    if (rdi_2 != 0)
        free(rdi_2);
    
    int64_t rdi_3 = arg1[5];
    
    if (rdi_3 != 0)
        free(rdi_3);
    
    int64_t rdi_4 = arg1[6];
    
    if (rdi_4 != 0)
        free(rdi_4);
    
    int64_t rdi_5 = arg1[0xe];
    
    if (rdi_5 != 0)
        free(rdi_5);
    
    int64_t rdi_6 = arg1[0xf];
    
    if (rdi_6 != 0)
        free(rdi_6);
    
    /* tailcall */
    return free(arg1);
}

int64_t httpd_ntoa(int16_t* arg1)
{
    int16_t rax = *arg1;
    socklen_t addrlen_1 = 0x1c;
    
    if (rax != 0xa)
        addrlen_1 = 0;
    
    socklen_t addrlen = 0x10;
    
    if (rax != 2)
        addrlen = addrlen_1;
    
    if (getnameinfo(arg1, addrlen, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
        httpd_ntoa.str = 0x3f;
    else if ((*(arg1 + 8) == 0 && (*(arg1 + 0xc) == 0 && (*(arg1 + 0x10) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
        memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
    
    return &httpd_ntoa.str;
}

int64_t httpd_terminate(int64_t* arg1)
{
    int32_t fd = arg1[9];
    
    if (fd != 0xffffffff)
    {
        close(fd);
        arg1[9] = 0xffffffff;
    }
    
    int32_t fd_1 = *(arg1 + 0x4c);
    
    if (fd_1 != 0xffffffff)
    {
        close(fd_1);
        *(arg1 + 0x4c) = 0xffffffff;
    }
    
    FILE* fp = arg1[0xb];
    
    if (fp != 0)
        fclose(fp);
    
    /* tailcall */
    return free_httpd_server(arg1);
}

void httpd_unlisten(void* arg1)
{
    int32_t fd = *(arg1 + 0x48);
    
    if (fd != 0xffffffff)
    {
        close(fd);
        *(arg1 + 0x48) = 0xffffffff;
    }
    
    int32_t fd_1 = *(arg1 + 0x4c);
    
    if (fd_1 != 0xffffffff)
    {
        close(fd_1);
        *(arg1 + 0x4c) = 0xffffffff;
    }
}

void httpd_write_response(void* arg1)
{
    ssize_t rax;
    
    if (sub_process == 1)
    {
        int32_t rbp_1 = *(arg1 + 0x2c0);
        rax = fcntl(rbp_1, 3, 0);
        
        if (rax != 0xffffffff)
        {
            int32_t rdx_2 = (rax & 0xfffff7ff);
            
            if (rdx_2 != rax)
                fcntl(rbp_1, 4, rdx_2);
        }
    }
    
    int64_t rbx = *(arg1 + 0x1d8);
    
    if (rbx != 0)
    {
        int32_t fd = *(arg1 + 0x2c0);
        int64_t r12_1 = *(arg1 + 0x170);
        rax = 0;
        int32_t rbp_2 = 0;
        
        do
        {
            rax = write(fd, (r12_1 + rax), (rbx - rax));
            int32_t temp0_1 = rax;
            
            if (temp0_1 < 0)
            {
                rax = *__errno_location();
                
                if ((rax != 0xb && rax != 4))
                    break;
                
                sleep(1);
            }
            else
            {
                if (temp0_1 == 0)
                    break;
                
                rbp_2 += rax;
            }
            
            rax = rbp_2;
        } while (rbx > rax);
        
        *(arg1 + 0x1d8) = 0;
    }
}

int32_t httpd_clear_ndelay(int32_t arg1)
{
    int32_t result = fcntl();
    
    if (result != 0xffffffff)
    {
        int32_t rdx_2 = (result & 0xfffff7ff);
        
        if (rdx_2 != result)
            /* tailcall */
            return fcntl(arg1, 4, rdx_2);
    }
    
    return result;
}

uint64_t httpd_write_fully(int32_t arg1, int64_t arg2, int64_t arg3)
{
    int32_t rbp;
    
    if (arg3 == 0)
        rbp = 0;
    else
    {
        int64_t rax_1 = 0;
        rbp = 0;
        
        do
        {
            int32_t rax_2 = write(arg1, (arg2 + rax_1), (arg3 - rax_1));
            
            if (rax_2 < 0)
            {
                int32_t rax_4 = *__errno_location();
                
                if ((rax_4 != 0xb && rax_4 != 4))
                {
                    rbp = rax_2;
                    break;
                }
                
                sleep(1);
            }
            else
            {
                rbp += rax_2;
                
                if (rax_2 == 0)
                    break;
            }
            
            rax_1 = rbp;
        } while (rax_1 < arg3);
    }
    
    return rbp;
}

int32_t httpd_set_ndelay(int32_t arg1)
{
    int32_t result = fcntl();
    
    if (result != 0xffffffff)
    {
        int32_t rdx_2 = (result | 0x800);
        
        if (rdx_2 != result)
            /* tailcall */
            return fcntl(arg1, 4, rdx_2);
    }
    
    return result;
}

int64_t httpd_realloc_str(int64_t* arg1, int64_t* arg2, int64_t arg3)
{
    int64_t rax;
    int64_t var_28 = rax;
    int64_t result = *arg2;
    uint64_t str_alloc_size_1;
    int64_t r15_1;
    
    if (result == 0)
    {
        r15_1 = 0xc8;
        
        if ((arg3 + 0x64) >= 0xc9)
            r15_1 = (arg3 + 0x64);
        
        *arg2 = r15_1;
        result = malloc((r15_1 + 1));
        *arg1 = result;
        str_alloc_count += 1;
        str_alloc_size_1 = str_alloc_size;
    label_95c6:
        str_alloc_size = (str_alloc_size_1 + r15_1);
        
        if (result == 0)
        {
            syslog(3, "out of memory reallocating a strâ€¦", r15_1);
            exit(1);
            /* no return */
        }
    }
    else if (result < arg3)
    {
        str_alloc_size_1 = (str_alloc_size - result);
        uint64_t rax_1 = (result * 2);
        uint64_t rsi_1 = ((arg3 * 5) >> 2);
        
        if (rax_1 > rsi_1)
            rsi_1 = rax_1;
        
        *arg2 = rsi_1;
        result = realloc(*arg1, (rsi_1 + 1));
        *arg1 = result;
        r15_1 = *arg2;
        goto label_95c6;
    }
    return result;
}

int64_t httpd_send_err(void* arg1, int32_t arg2, void* arg3, char* arg4, char* arg5, char* arg6)
{
    void var_418;
    int32_t result;
    
    if ((*(*(arg1 + 8) + 0x64) != 0 && **(arg1 + 0x158) != 0))
    {
        my_snprintf(&var_418, 0x3e8, "%s/%s/err%d.html", 0);
        result = send_err_file(arg1, arg2, arg3, arg4, &var_418);
    }
    
    if (((*(*(arg1 + 8) + 0x64) == 0 || **(arg1 + 0x158) == 0) || result == 0))
    {
        my_snprintf(&var_418, 0x3e8, "%s/err%d.html", 0);
        result = send_err_file(arg1, arg2, arg3, arg4, &var_418);
        
        if (result == 0)
            /* tailcall */
            return send_response(arg1, arg2, arg3, arg4, arg5, arg6);
    }
    
    return result;
}

int64_t my_snprintf(char* arg1, uint64_t arg2, char* arg3, char arg4 @ rax)
{
    int64_t rcx;
    int64_t var_a0 = rcx;
    int64_t r8;
    int64_t var_98 = r8;
    int64_t r9;
    int64_t var_90 = r9;
    
    if (arg4 != 0)
    {
        int128_t zmm0;
        int128_t var_88_1 = zmm0;
        int128_t zmm1;
        int128_t var_78_1 = zmm1;
        int128_t zmm2;
        int128_t var_68_1 = zmm2;
        int128_t zmm3;
        int128_t var_58_1 = zmm3;
        int128_t zmm4;
        int128_t var_48_1 = zmm4;
        int128_t zmm5;
        int128_t var_38_1 = zmm5;
        int128_t zmm6;
        int128_t var_28_1 = zmm6;
        int128_t zmm7;
        int128_t var_18_1 = zmm7;
    }
    
    void var_b8;
    void* var_c8 = &var_b8;
    void* var_d0 = &arg_8;
    int64_t args = 0x3000000018;
    return vsnprintf(arg1, arg2, arg3, &args);
}

int64_t send_err_file(void* arg1, int32_t arg2, void* arg3, char* arg4, char* arg5)
{
    FILE* fp = fopen(arg5, &data_1251b);
    
    if (fp == 0)
        return 0;
    
    send_mime(arg1, arg2, arg3, &data_13553, arg4, "text/html; charset=%s", -1, 0);
    void buf;
    
    for (uint64_t i = fread(&buf, 1, 0x3e7, fp); i != 0; i = fread(&buf, 1, 0x3e7, fp))
    {
        *(&buf + i) = 0;
        uint64_t rax = strlen(&buf);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax));
        memcpy((*(arg1 + 0x170) + *(arg1 + 0x1d8)), &buf, rax);
        *(arg1 + 0x1d8) += rax;
    }
    
    fclose(fp);
    void var_418;
    my_snprintf(&var_418, 0x3e8, "    <hr>\n\n    <address><a hrefâ€¦", 0);
    uint64_t rax_1 = strlen(&var_418);
    httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_1));
    memcpy((*(arg1 + 0x170) + *(arg1 + 0x1d8)), &var_418, rax_1);
    *(arg1 + 0x1d8) += rax_1;
    return 1;
}

int64_t send_response(void* arg1, int32_t arg2, void* arg3, char* arg4, char* arg5, char* arg6)
{
    send_mime(arg1, arg2, arg3, &data_13553, arg4, "text/html; charset=%s", -1, 0);
    void* var_ff8 = arg3;
    void var_be8;
    my_snprintf(&var_be8, 0x7d0, "<!DOCTYPE html PUBLIC "-//W3C//Dâ€¦", 0);
    uint64_t rax = strlen(&var_be8);
    httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax));
    memcpy((*(arg1 + 0x170) + *(arg1 + 0x1d8)), &var_be8, rax);
    *(arg1 + 0x1d8) += rax;
    char rcx_1 = *arg6;
    void* rax_1;
    char* rdx_3;
    void var_fd8;
    
    if (rcx_1 == 0)
    {
        rax_1 = &var_fd8;
        rdx_3 = arg5;
    }
    else
    {
        void* rbx_1 = &arg6[1];
        rax_1 = &var_fd8;
        rdx_3 = arg5;
        
        do
        {
            int32_t rsi_2 = rcx_1;
            
            if (rsi_2 == 0x3e)
            {
                __builtin_strncpy(rax_1, "&gt;", 4);
                rax_1 += 3;
            }
            else if (rsi_2 != 0x3c)
                *rax_1 = rcx_1;
            else
            {
                __builtin_strncpy(rax_1, "&lt;", 4);
                rax_1 += 3;
            }
            
            rax_1 += 1;
            rcx_1 = *rbx_1;
            
            if (rcx_1 == 0)
                break;
            
            rbx_1 += 1;
        } while ((rax_1 - &var_fd8) < 0x3e3);
    }
    *rax_1 = 0;
    my_snprintf(&var_be8, 0x7d0, rdx_3, 0);
    uint64_t rax_2 = strlen(&var_be8);
    httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_2));
    memcpy((*(arg1 + 0x170) + *(arg1 + 0x1d8)), &var_be8, rax_2);
    *(arg1 + 0x1d8) += rax_2;
    
    if (match("**MSIE**", *(arg1 + 0x118)) != 0)
    {
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (*(arg1 + 0x1d8) + 5));
        int32_t* rax_4 = *(arg1 + 0x170);
        int64_t rcx_2 = *(arg1 + 0x1d8);
        *((rax_4 + rcx_2) + 4) = 0xa;
        *(rax_4 + rcx_2) = 0x2d2d213c;
        int64_t rdx_9 = *(arg1 + 0x1d8);
        *(arg1 + 0x1d8) = (rdx_9 + 5);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (rdx_9 + 0x53));
        int128_t* rax_6 = *(arg1 + 0x170);
        int64_t rcx_3 = *(arg1 + 0x1d8);
        *((rax_6 + rcx_3) + 0x3e) = (*"own canned one.\n")[0];
        *((rax_6 + rcx_3) + 0x30) = (*"nstead of its own canned one.\n")[0];
        *((rax_6 + rcx_3) + 0x20) = (*"how this error instead of its owâ€¦")[0];
        *((rax_6 + rcx_3) + 0x10) = (*"MSIE deigns to show this error iâ€¦")[0];
        *(rax_6 + rcx_3) = (*"Padding so that MSIE deigns to sâ€¦")[0];
        int64_t rdx_11 = *(arg1 + 0x1d8);
        *(arg1 + 0x1d8) = (rdx_11 + 0x4e);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (rdx_11 + 0x9c));
        int128_t* rax_8 = *(arg1 + 0x170);
        int64_t rcx_4 = *(arg1 + 0x1d8);
        *((rax_8 + rcx_4) + 0x3e) = (*"own canned one.\n")[0];
        *((rax_8 + rcx_4) + 0x30) = (*"nstead of its own canned one.\n")[0];
        *((rax_8 + rcx_4) + 0x20) = (*"how this error instead of its owâ€¦")[0];
        *((rax_8 + rcx_4) + 0x10) = (*"MSIE deigns to show this error iâ€¦")[0];
        *(rax_8 + rcx_4) = (*"Padding so that MSIE deigns to sâ€¦")[0];
        int64_t rdx_13 = *(arg1 + 0x1d8);
        *(arg1 + 0x1d8) = (rdx_13 + 0x4e);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (rdx_13 + 0x9c));
        int128_t* rax_10 = *(arg1 + 0x170);
        int64_t rcx_5 = *(arg1 + 0x1d8);
        *((rax_10 + rcx_5) + 0x3e) = (*"own canned one.\n")[0];
        *((rax_10 + rcx_5) + 0x30) = (*"nstead of its own canned one.\n")[0];
        *((rax_10 + rcx_5) + 0x20) = (*"how this error instead of its owâ€¦")[0];
        *((rax_10 + rcx_5) + 0x10) = (*"MSIE deigns to show this error iâ€¦")[0];
        *(rax_10 + rcx_5) = (*"Padding so that MSIE deigns to sâ€¦")[0];
        int64_t rdx_15 = *(arg1 + 0x1d8);
        *(arg1 + 0x1d8) = (rdx_15 + 0x4e);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (rdx_15 + 0x9c));
        int128_t* rax_12 = *(arg1 + 0x170);
        int64_t rcx_6 = *(arg1 + 0x1d8);
        *((rax_12 + rcx_6) + 0x3e) = (*"own canned one.\n")[0];
        *((rax_12 + rcx_6) + 0x30) = (*"nstead of its own canned one.\n")[0];
        *((rax_12 + rcx_6) + 0x20) = (*"how this error instead of its owâ€¦")[0];
        *((rax_12 + rcx_6) + 0x10) = (*"MSIE deigns to show this error iâ€¦")[0];
        *(rax_12 + rcx_6) = (*"Padding so that MSIE deigns to sâ€¦")[0];
        int64_t rdx_17 = *(arg1 + 0x1d8);
        *(arg1 + 0x1d8) = (rdx_17 + 0x4e);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (rdx_17 + 0x9c));
        int128_t* rax_14 = *(arg1 + 0x170);
        int64_t rcx_7 = *(arg1 + 0x1d8);
        *((rax_14 + rcx_7) + 0x3e) = (*"own canned one.\n")[0];
        *((rax_14 + rcx_7) + 0x30) = (*"nstead of its own canned one.\n")[0];
        *((rax_14 + rcx_7) + 0x20) = (*"how this error instead of its owâ€¦")[0];
        *((rax_14 + rcx_7) + 0x10) = (*"MSIE deigns to show this error iâ€¦")[0];
        *(rax_14 + rcx_7) = (*"Padding so that MSIE deigns to sâ€¦")[0];
        int64_t rdx_19 = *(arg1 + 0x1d8);
        *(arg1 + 0x1d8) = (rdx_19 + 0x4e);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (rdx_19 + 0x9c));
        int128_t* rax_16 = *(arg1 + 0x170);
        int64_t rcx_8 = *(arg1 + 0x1d8);
        *((rax_16 + rcx_8) + 0x3e) = (*"own canned one.\n")[0];
        *((rax_16 + rcx_8) + 0x30) = (*"nstead of its own canned one.\n")[0];
        *((rax_16 + rcx_8) + 0x20) = (*"how this error instead of its owâ€¦")[0];
        *((rax_16 + rcx_8) + 0x10) = (*"MSIE deigns to show this error iâ€¦")[0];
        *(rax_16 + rcx_8) = (*"Padding so that MSIE deigns to sâ€¦")[0];
        int64_t rdx_21 = *(arg1 + 0x1d8);
        *(arg1 + 0x1d8) = (rdx_21 + 0x4e);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (rdx_21 + 0x52));
        *(*(arg1 + 0x170) + *(arg1 + 0x1d8)) = 0xa3e2d2d;
        *(arg1 + 0x1d8) += 4;
    }
    
    void var_418;
    my_snprintf(&var_418, 0x3e8, "    <hr>\n\n    <address><a hrefâ€¦", 0);
    uint64_t rax_19 = strlen(&var_418);
    httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_19));
    int64_t result = memcpy((*(arg1 + 0x170) + *(arg1 + 0x1d8)), &var_418, rax_19);
    *(arg1 + 0x1d8) += rax_19;
    return result;
}

int64_t httpd_method_str(int32_t arg1)
{
    if ((arg1 - 1) > 5)
        return "UNKNOWN";
    
    return &data_18da0[(arg1 - 1)];
}

uint64_t httpd_get_conn(int64_t arg1, int32_t arg2, int32_t* arg3)
{
    int32_t* rbx = arg3;
    
    if (*arg3 == 0)
    {
        *(rbx + 0x98) = 0;
        httpd_realloc_str(&rbx[0x24], &rbx[0x26], 0x1f4);
        __builtin_memset(&rbx[0x5e], 0, 0x60);
        httpd_realloc_str(&rbx[0x36], &rbx[0x5e], 1);
        httpd_realloc_str(&rbx[0x3a], &rbx[0x60], 1);
        httpd_realloc_str(&rbx[0x3c], &rbx[0x62], 0);
        httpd_realloc_str(&rbx[0x3e], &rbx[0x64], 0);
        httpd_realloc_str(&rbx[0x40], &rbx[0x66], 0);
        httpd_realloc_str(&rbx[0x42], &rbx[0x68], 0);
        httpd_realloc_str(&rbx[0x48], &rbx[0x6a], 0);
        httpd_realloc_str(&rbx[0x4a], &rbx[0x6c], 0);
        httpd_realloc_str(&rbx[0x52], &rbx[0x6e], 0);
        httpd_realloc_str(&rbx[0x56], &rbx[0x70], 0);
        httpd_realloc_str(&rbx[0x5a], &rbx[0x72], 0);
        httpd_realloc_str(&rbx[0x5c], &rbx[0x74], 0);
        *rbx = 1;
    }
    
    socklen_t len = 0x80;
    int16_t addr;
    int32_t rax_8 = accept(arg2, &addr, &len);
    rbx[0xb0] = rax_8;
    int32_t r14_2;
    
    if (rax_8 < 0)
    {
        int32_t rax_11 = *__errno_location();
        
        if (rax_11 == 0xb)
            r14_2 = 2;
        else
        {
            if (rax_11 != 0x67)
                syslog(3, "accept - %m");
            
            r14_2 = 0;
        }
    }
    else
    {
        int16_t rcx_2 = (addr & 0xfff7);
        
        if (rcx_2 != 2)
        {
            r14_2 = 0;
            syslog(3, "unknown sockaddr family");
            close(rbx[0xb0]);
            rbx[0xb0] = 0xffffffff;
        }
        else
        {
            r14_2 = 1;
            fcntl(rax_8, 2, 1, rcx_2);
            *(rbx + 8) = arg1;
            int16_t addr_1 = addr;
            uint64_t rcx_3 = 0x1c;
            
            if (addr_1 != 0xa)
                rcx_3 = 0;
            
            uint64_t rbp_2 = 0x10;
            
            if (addr_1 != 2)
                rbp_2 = rcx_3;
            
            memset(((rbx + rbp_2) + 0x10), 0, (0x80 - rbp_2));
            int32_t zmm1_1[0x4] = memcpy(&rbx[4], &addr, rbp_2);
            __builtin_memset(&rbx[0x28], 0, 0x1c);
            *(rbx + 0xc0) = {0};
            *(rbx + 0xd0) = &data_13553;
            **(rbx + 0xd8) = 0;
            *(rbx + 0xe0) = "UNKNOWN";
            **(rbx + 0xe8) = 0;
            **(rbx + 0xf0) = 0;
            **(rbx + 0xf8) = 0;
            **(rbx + 0x100) = 0;
            **(rbx + 0x108) = 0;
            *(rbx + 0x110) = &data_13553;
            *(rbx + 0x118) = &data_13553;
            **(rbx + 0x120) = 0;
            **(rbx + 0x128) = 0;
            *(rbx + 0x130) = &data_13553;
            *(rbx + 0x138) = &data_13553;
            *(rbx + 0x140) = &data_13553;
            **(rbx + 0x148) = 0;
            *(rbx + 0x150) = &data_13553;
            **(rbx + 0x158) = 0;
            *(rbx + 0x160) = &data_13553;
            **(rbx + 0x168) = 0;
            **(rbx + 0x170) = 0;
            *(rbx + 0x1d8) = 0;
            *(rbx + 0x1e0) = _mm_cmpeq_epi32(zmm1_1, zmm1_1);
            *(rbx + 0x1f0) = -1;
            *(rbx + 0x1f8) = &data_13553;
            *(rbx + 0x200) = 0;
            rbx[0x82] = 1;
            __builtin_memset(&rbx[0x83], 0, 0x14);
            *(rbx + 0x220) = -1;
            *(rbx + 0x228) = 0;
            *(rbx + 0x2c8) = 0;
        }
    }
    
    return r14_2;
}

int64_t httpd_got_request(void* arg1)
{
    int64_t rcx = *(arg1 + 0xa0);
    int64_t rdx = *(arg1 + 0xa8);
    
    if (rdx < rcx)
    {
        int64_t r13_1 = *(arg1 + 0x90);
        int32_t rbp_1 = *(arg1 + 0xb0);
        int64_t rdx_1 = (rdx + 1);
        int64_t i;
        
        do
        {
            if (rbp_1 <= 0xb)
            {
                int32_t rsi_1 = *((r13_1 + rdx_1) - 1);
                int64_t result = 2;
                int32_t rbx_1;
                
                switch (rbp_1)
                {
                    case 0:
                    {
                        rbp_1 = 0;
                        uint64_t rsi_2 = (rsi_1 - 9);
                        
                        if (rsi_2 <= 0x17)
                        {
                            rbx_1 = 1;
                            
                            switch (rsi_2)
                            {
                                case 0:
                                case 0x17:
                                {
                                    *(arg1 + 0xb0) = rbx_1;
                                    rbp_1 = rbx_1;
                                    break;
                                }
                                case 1:
                                case 4:
                                {
                                    *(arg1 + 0xb0) = 0xb;
                                    return result;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    case 1:
                    {
                        rbx_1 = 2;
                        uint64_t rsi_5 = (rsi_1 - 9);
                        
                        if (rsi_5 > 0x17)
                        {
                            *(arg1 + 0xb0) = rbx_1;
                            rbp_1 = rbx_1;
                        }
                        else
                        {
                            rbp_1 = 1;
                            
                            switch (rsi_5)
                            {
                                case 1:
                                case 4:
                                {
                                    *(arg1 + 0xb0) = 0xb;
                                    return result;
                                    break;
                                }
                                case 2:
                                case 3:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                case 0xa:
                                case 0xb:
                                case 0xc:
                                case 0xd:
                                case 0xe:
                                case 0xf:
                                case 0x10:
                                case 0x11:
                                case 0x12:
                                case 0x13:
                                case 0x14:
                                case 0x15:
                                case 0x16:
                                {
                                    *(arg1 + 0xb0) = rbx_1;
                                    rbp_1 = rbx_1;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    case 2:
                    {
                        rbp_1 = 2;
                        uint64_t rsi_8 = (rsi_1 - 9);
                        
                        if (rsi_8 <= 0x17)
                        {
                            rbx_1 = 3;
                            
                            switch (rsi_8)
                            {
                                case 0:
                                case 0x17:
                                {
                                    *(arg1 + 0xb0) = rbx_1;
                                    rbp_1 = rbx_1;
                                    break;
                                }
                                case 1:
                                case 4:
                                {
                                    return 1;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    case 3:
                    {
                        rbx_1 = 4;
                        uint64_t rsi_11 = (rsi_1 - 9);
                        
                        if (rsi_11 > 0x17)
                        {
                            *(arg1 + 0xb0) = rbx_1;
                            rbp_1 = rbx_1;
                        }
                        else
                        {
                            rbp_1 = 3;
                            
                            switch (rsi_11)
                            {
                                case 1:
                                case 4:
                                {
                                    *(arg1 + 0xb0) = 0xb;
                                    return result;
                                    break;
                                }
                                case 2:
                                case 3:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                case 0xa:
                                case 0xb:
                                case 0xc:
                                case 0xd:
                                case 0xe:
                                case 0xf:
                                case 0x10:
                                case 0x11:
                                case 0x12:
                                case 0x13:
                                case 0x14:
                                case 0x15:
                                case 0x16:
                                {
                                    *(arg1 + 0xb0) = rbx_1;
                                    rbp_1 = rbx_1;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    case 4:
                    {
                        rbp_1 = 4;
                        uint64_t rsi_14 = (rsi_1 - 9);
                        
                        if (rsi_14 <= 0x17)
                        {
                            rbx_1 = 5;
                            
                            switch (rsi_14)
                            {
                                case 0:
                                case 0x17:
                                {
                                    *(arg1 + 0xb0) = rbx_1;
                                    rbp_1 = rbx_1;
                                    break;
                                }
                                case 1:
                                {
                                    goto label_a278;
                                }
                                case 4:
                                {
                                label_a387:
                                    rbx_1 = 8;
                                    *(arg1 + 0xb0) = rbx_1;
                                    rbp_1 = rbx_1;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    case 5:
                    {
                        uint64_t rsi_15 = (rsi_1 - 9);
                        
                        if (rsi_15 > 0x17)
                        {
                            *(arg1 + 0xb0) = 0xb;
                            return result;
                        }
                        
                        rbx_1 = 7;
                        rbp_1 = 5;
                        
                        switch (rsi_15)
                        {
                            case 1:
                            {
                                *(arg1 + 0xb0) = rbx_1;
                                rbp_1 = rbx_1;
                                break;
                            }
                            case 2:
                            case 3:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 0xa:
                            case 0xb:
                            case 0xc:
                            case 0xd:
                            case 0xe:
                            case 0xf:
                            case 0x10:
                            case 0x11:
                            case 0x12:
                            case 0x13:
                            case 0x14:
                            case 0x15:
                            case 0x16:
                            {
                                *(arg1 + 0xb0) = 0xb;
                                return result;
                                break;
                            }
                            case 4:
                            {
                                goto label_a387;
                            }
                        }
                        break;
                    }
                    case 6:
                    {
                        if (rsi_1 == 0xa)
                        {
                        label_a278:
                            rbx_1 = 7;
                            *(arg1 + 0xb0) = rbx_1;
                            rbp_1 = rbx_1;
                        }
                        else
                        {
                            rbp_1 = 6;
                            
                            if (rsi_1 == 0xd)
                                goto label_a387;
                        }
                        break;
                    }
                    case 7:
                    {
                        rbx_1 = 8;
                        
                        if (rsi_1 != 0xd)
                        {
                        label_a3c3:
                            
                            if (rsi_1 == 0xa)
                                return 1;
                            
                            goto label_a3c8;
                        }
                        
                        *(arg1 + 0xb0) = rbx_1;
                        rbp_1 = rbx_1;
                        break;
                    }
                    case 8:
                    {
                        rbx_1 = 9;
                        
                        if (rsi_1 == 0xa)
                        {
                            *(arg1 + 0xb0) = rbx_1;
                            rbp_1 = rbx_1;
                        }
                        else
                        {
                            if (rsi_1 == 0xd)
                                return 1;
                            
                        label_a3c8:
                            rbx_1 = 6;
                            *(arg1 + 0xb0) = rbx_1;
                            rbp_1 = rbx_1;
                        }
                        break;
                    }
                    case 9:
                    {
                        rbx_1 = 0xa;
                        
                        if (rsi_1 != 0xd)
                            goto label_a3c3;
                        
                        *(arg1 + 0xb0) = rbx_1;
                        rbp_1 = rbx_1;
                        break;
                    }
                    case 0xa:
                    {
                        result = 1;
                        
                        if (rsi_1 == 0xa)
                            return result;
                        
                        rbx_1 = 6;
                        
                        if (rsi_1 == 0xd)
                            return result;
                        
                        *(arg1 + 0xb0) = rbx_1;
                        rbp_1 = rbx_1;
                        break;
                    }
                    case 0xb:
                    {
                        return result;
                        break;
                    }
                }
            }
            
            *(arg1 + 0xa8) = rdx_1;
            i = ((-(rcx) + rdx_1) + 1);
            rdx_1 += 1;
        } while (i != 1);
    }
    
    return 0;
}

uint64_t httpd_parse_request(uint64_t arg1)
{
    uint64_t i_12 = arg1;
    *(arg1 + 0xa8) = 0;
    int64_t rax = *(arg1 + 0xa0);
    char* r15;
    
    if (rax == 0)
        r15 = nullptr;
    else
    {
        int64_t rcx_1 = *(i_12 + 0x90);
        int64_t rdx_1 = 1;
        r15 = nullptr;
        
        while (true)
        {
            char rbx_1 = *((rcx_1 + rdx_1) - 1);
            
            if ((rbx_1 != 0xd && rbx_1 != 0xa))
            {
                *(i_12 + 0xa8) = rdx_1;
                int64_t rsi_2 = ((-(rax) + rdx_1) + 1);
                rdx_1 += 1;
                
                if (rsi_2 == 1)
                    break;
                
                continue;
            }
            
            *((rcx_1 + rdx_1) - 1) = 0;
            int64_t rax_3 = (*(i_12 + 0xa8) + 1);
            *(i_12 + 0xa8) = rax_3;
            
            if ((rbx_1 == 0xd && rax_3 < *(i_12 + 0xa0)))
            {
                char* rcx_2 = *(i_12 + 0x90);
                
                if (rcx_2[rax_3] == 0xa)
                {
                    rcx_2[rax_3] = 0;
                    *(i_12 + 0xa8) += 1;
                }
            }
            
            r15 = *(i_12 + 0x90);
            break;
        }
    }
    
    char* rax_4 = strpbrk(r15, " \t\n\r");
    int32_t rbx_17;
    void* httpd_err400title_1;
    uint64_t i_11;
    char* httpd_err400form_1;
    
    if (rax_4 == 0)
    {
    label_b33c:
        httpd_err400title_1 = httpd_err400title;
        httpd_err400form_1 = httpd_err400form;
        i_11 = i_12;
    label_b354:
        httpd_send_err(i_11, 0x190, httpd_err400title_1, &data_13553, httpd_err400form_1, &data_13553);
        rbx_17 = -1;
    }
    else
    {
        *rax_4 = 0;
        void* r12_2 = &rax_4[(strspn(&rax_4[1], " \t\n\r") + 1)];
        char* rax_6 = strpbrk(r12_2, " \t\n\r");
        void* rbp_2;
        
        if (rax_6 == 0)
        {
            *(i_12 + 0x208) = 0;
            rbp_2 = "HTTP/0.9";
        }
        else
        {
            *rax_6 = 0;
            uint64_t rax_7 = strspn(&rax_6[1], " \t\n\r");
            rbp_2 = &rax_6[(rax_7 + 1)];
            
            if (rax_6[(rax_7 + 1)] != 0)
            {
                char* rax_8 = strpbrk(rbp_2, " \t\n\r");
                
                if (rax_8 != 0)
                    *rax_8 = 0;
                
                if (strcasecmp(rbp_2, "HTTP/1.0") != 0)
                    *(i_12 + 0x20c) = 1;
            }
        }
        
        *(i_12 + 0xe0) = rbp_2;
        
        if (strncasecmp(r12_2, "http://", 7) == 0)
        {
            if (*(i_12 + 0x20c) == 0)
                goto label_b33c;
            
            char* rax_17 = strchr((r12_2 + 7), 0x2f);
            
            if (rax_17 == 0)
                goto label_b33c;
            
            *rax_17 = 0;
            
            if ((strchr((r12_2 + 7), 0x2f) != 0 || *(r12_2 + 7) == 0x2e))
                goto label_b33c;
            
            httpd_realloc_str((i_12 + 0x148), (i_12 + 0x1b8), strlen((r12_2 + 7)));
            strcpy(*(i_12 + 0x148), (r12_2 + 7));
            *rax_17 = 0x2f;
            r12_2 = rax_17;
        }
        else if (*r12_2 != 0x2f)
            goto label_b33c;
        
        int32_t rax_20;
        
        if (strcasecmp(r15, &data_134e3) == 0)
        {
            rax_20 = 1;
        label_a71e:
            *(i_12 + 0xb4) = rax_20;
            *(i_12 + 0xd0) = r12_2;
            httpd_realloc_str((i_12 + 0xd8), (i_12 + 0x178), strlen(r12_2));
            char* rbp_5 = *(i_12 + 0xd0);
            char* rbx_6 = *(i_12 + 0xd8);
            
            while (true)
            {
                char rdx_4 = *rbp_5;
                
                if (rdx_4 == 0x25)
                {
                    uint16_t* rcx_3 = *__ctype_b_loc();
                    int64_t rsi_7 = rbp_5[1];
                    rdx_4 = 0x25;
                    
                    if ((*(&rcx_3[rsi_7] + 1) & 0x10) != 0)
                    {
                        int64_t rax_23 = rbp_5[2];
                        
                        if ((*(&rcx_3[rax_23] + 1) & 0x10) != 0)
                        {
                            char rcx_4 = (rsi_7 - 0x30);
                            
                            if (rcx_4 >= 0xa)
                            {
                                if ((rsi_7 - 0x61) > 5)
                                {
                                    char rcx_6 = (rsi_7 - 0x41);
                                    rsi_7 -= 0x37;
                                    rcx_4 = rsi_7;
                                    
                                    if (rcx_6 >= 6)
                                        rcx_4 = 0;
                                }
                                else
                                {
                                    rsi_7 -= 0x57;
                                    rcx_4 = rsi_7;
                                }
                            }
                            
                            rdx_4 = (rax_23 - 0x30);
                            
                            if (rdx_4 >= 0xa)
                            {
                                if ((rax_23 - 0x61) > 5)
                                {
                                    char rdx_6 = (rax_23 - 0x41);
                                    rax_23 -= 0x37;
                                    rdx_4 = rax_23;
                                    
                                    if (rdx_6 >= 6)
                                        rdx_4 = 0;
                                }
                                else
                                {
                                    rax_23 -= 0x57;
                                    rdx_4 = rax_23;
                                }
                            }
                            
                            rdx_4 += (rcx_4 << 4);
                            rbp_5 = &rbp_5[2];
                        }
                    }
                }
                else if (rdx_4 == 0)
                    break;
                
                *rbx_6 = rdx_4;
                rbx_6 = &rbx_6[1];
                rbp_5 = &rbp_5[1];
            }
            
            *rbx_6 = 0;
            int64_t* rbp_6 = (i_12 + 0xe8);
            httpd_realloc_str(rbp_6, (i_12 + 0x180), strlen(*(i_12 + 0xd8)));
            strcpy(*(i_12 + 0xe8), (*(i_12 + 0xd8) + 1));
            char* rax_25 = *(i_12 + 0xe8);
            
            if (*rax_25 == 0)
                *rax_25 = 0x2e;
            
            char* rax_26 = strchr(*(i_12 + 0xd0), 0x3f);
            
            if (rax_26 != 0)
            {
                httpd_realloc_str((i_12 + 0x108), (i_12 + 0x1a0), strlen(&rax_26[1]));
                strcpy(*(i_12 + 0x108), &rax_26[1]);
                char* rax_28 = strchr(*(i_12 + 0xe8), 0x3f);
                
                if (rax_28 != 0)
                    *rax_28 = 0;
            }
            
            char* rbp_7 = *rbp_6;
            char* i_8 = strstr(rbp_7, "//");
            
            if (i_8 != 0)
            {
                char* i_6 = i_8;
                char* i;
                
                do
                {
                    void* rbx_10 = &i_6[1];
                    bool cond:1_1;
                    
                    do
                    {
                        cond:1_1 = *(rbx_10 + 1) == 0x2f;
                        rbx_10 += 1;
                    } while (cond:1_1);
                    memmove(&i_6[1], rbx_10, (strlen(rbx_10) + 1));
                    i = strstr(rbp_7, "//");
                    i_6 = i;
                } while (i != 0);
            }
            
            if (strncmp(rbp_7, "./", 2) == 0)
            {
                int32_t i_1;
                
                do
                {
                    memmove(rbp_7, &rbp_7[2], (strlen(&rbp_7[2]) + 1));
                    i_1 = strncmp(rbp_7, "./", 2);
                } while (i_1 == 0);
            }
            
            uint64_t i_7 = i_12;
            char* i_9 = strstr(rbp_7, &data_13c31);
            
            if (i_9 != 0)
            {
                char* i_4 = i_9;
                char* i_2;
                
                do
                {
                    memmove(i_4, &i_4[2], (strlen(&i_4[2]) + 1));
                    i_2 = strstr(rbp_7, &data_13c31);
                    i_4 = i_2;
                } while (i_2 != 0);
            }
            
            while (true)
            {
                uint64_t rdx_12;
                void* rsi_16;
                void* rdi_41;
                
                if (strncmp(rbp_7, "../", 3) == 0)
                {
                    rdx_12 = (strlen(&rbp_7[3]) + 1);
                    rdi_41 = rbp_7;
                    rsi_16 = &rbp_7[3];
                }
                else
                {
                    char* rax_35 = strstr(rbp_7, "/../");
                    
                    if (rax_35 == 0)
                        break;
                    
                    void* rax_36 = &rax_35[-1];
                    void* r12_4;
                    
                    do
                    {
                        r12_4 = rax_36;
                        
                        if (rax_36 < rbp_7)
                            break;
                        
                        rax_36 = (r12_4 - 1);
                    } while (*r12_4 != 0x2f);
                    
                    rdx_12 = (strlen(&rax_35[4]) + 1);
                    rdi_41 = (r12_4 + 1);
                    rsi_16 = &rax_35[4];
                }
                
                memmove(rdi_41, rsi_16, rdx_12);
            }
            
            int32_t i_3 = strlen(rbp_7);
            i_12 = i_7;
            uint64_t i_5;
            
            if (i_3 >= 4)
            {
                do
                {
                    i_5 = i_3;
                    
                    if (strcmp(&rbp_7[(-3 + i_5)], &data_13c3a) != 0)
                        break;
                    
                    i_5 = &rbp_7[(-4 + i_5)];
                    uint64_t i_10;
                    bool cond:4_1;
                    
                    do
                    {
                        if (i_5 < rbp_7)
                            goto label_aae7;
                        
                        i_10 = (i_5 - 1);
                        cond:4_1 = *i_5 != 0x2f;
                        i_5 = i_10;
                    } while (cond:4_1);
                    *(i_10 + 1) = 0;
                    i_3 = strlen(rbp_7);
                } while (i_3 > 3);
            }
            
        label_aae7:
            char* rax_40 = *rbp_6;
            char rcx_7 = *rax_40;
            
            if (rcx_7 == 0x2f)
                goto label_b33c;
            
            if ((rcx_7 == 0x2e && rax_40[1] == 0x2e))
            {
                rax_40 = rax_40[2];
                
                if ((rax_40 == 0x2f || rax_40 == 0))
                    goto label_b33c;
            }
            
            int64_t rax_42;
            int64_t rcx_8;
            
            if (*(i_12 + 0x208) != 0)
            {
                rcx_8 = *(i_7 + 0xa0);
                rax_42 = *(i_7 + 0xa8);
            }
            
            if ((*(i_12 + 0x208) != 0 && rax_42 < rcx_8))
            {
                while (true)
                {
                    int64_t rdx_16 = *(i_7 + 0x90);
                    int64_t rsi_20 = (rax_42 + 1);
                    
                    while (true)
                    {
                        i_5 = *((rdx_16 + rsi_20) - 1);
                        
                        if (i_5 == 0xd)
                            break;
                        
                        if (i_5 == 0xa)
                            break;
                        
                        *(i_7 + 0xa8) = rsi_20;
                        int64_t rdi_50 = ((-(rcx_8) + rsi_20) + 1);
                        rsi_20 += 1;
                        
                        if (rdi_50 == 1)
                            goto label_b242;
                    }
                    
                    *((rdx_16 + rsi_20) - 1) = 0;
                    int64_t rcx_11 = (*(i_7 + 0xa8) + 1);
                    *(i_7 + 0xa8) = rcx_11;
                    
                    if ((i_5 != 0xd || rcx_11 >= *(i_7 + 0xa0)))
                        goto label_ac17;
                    
                    char* r15_4 = *(i_7 + 0x90);
                    
                    if (r15_4[rcx_11] == 0xa)
                    {
                        r15_4[rcx_11] = 0;
                        *(i_7 + 0xa8) += 1;
                    label_ac17:
                        r15_4 = *(i_7 + 0x90);
                        
                        if (r15_4 == 0)
                            goto label_b242;
                    }
                    
                    void* r15_5 = &r15_4[rax_42];
                    
                    if (*r15_5 == 0)
                        goto label_b242;
                    
                    if (strncasecmp(r15_5, "Referer:", 8) == 0)
                    {
                        i_5 = i_7;
                        *(i_5 + 0x110) = ((strspn((r15_5 + 8), &data_13551) + r15_5) + 8);
                    }
                    else if (strncasecmp(r15_5, "Referrer:", 9) == 0)
                    {
                        i_5 = i_7;
                        *(i_5 + 0x110) = ((strspn((r15_5 + 9), &data_13551) + r15_5) + 9);
                    }
                    else if (strncasecmp(r15_5, "User-Agent:", 0xb) == 0)
                    {
                        i_5 = i_7;
                        *(i_5 + 0x118) = ((strspn((r15_5 + 0xb), &data_13551) + r15_5) + 0xb);
                    }
                    else if (strncasecmp(r15_5, "Host:", 5) == 0)
                    {
                        void* rbp_9 = ((r15_5 + strspn((r15_5 + 5), &data_13551)) + 5);
                        i_5 = i_7;
                        *(i_5 + 0x150) = rbp_9;
                        char* rax_71 = strchr(rbp_9, 0x3a);
                        
                        if (rax_71 != 0)
                        {
                            *rax_71 = 0;
                            rbp_9 = *(i_5 + 0x150);
                        }
                        
                        if ((strchr(rbp_9, 0x2f) != 0 || *rbp_9 == 0x2e))
                        {
                            httpd_err400title_1 = httpd_err400title;
                            httpd_err400form_1 = httpd_err400form;
                            i_11 = i_5;
                            break;
                        }
                    }
                    else if (strncasecmp(r15_5, "Accept:", 7) == 0)
                    {
                        void* r15_7 = ((r15_5 + strspn((r15_5 + 7), &data_13551)) + 7);
                        char* rdi_77 = *(i_7 + 0x120);
                        
                        if (*rdi_77 == 0)
                        {
                            httpd_realloc_str((i_7 + 0x120), (i_7 + 0x1a8), strlen(r15_7));
                            strcat(*(i_7 + 0x120), r15_7);
                            i_5 = i_7;
                        }
                        else
                        {
                            uint64_t rax_74 = strlen(rdi_77);
                            
                            if (rax_74 < 0x1389)
                            {
                                httpd_realloc_str((i_7 + 0x120), (i_7 + 0x1a8), ((rax_74 + strlen(r15_7)) + 2));
                                char* rbx_13 = *(i_7 + 0x120);
                                uint64_t rax_83 = strlen(rbx_13);
                                *(rbx_13 + rax_83) = 0x202c;
                                rbx_13[(rax_83 + 2)] = 0;
                                strcat(*(i_7 + 0x120), r15_7);
                                i_5 = i_7;
                            }
                            else
                            {
                                httpd_ntoa((i_7 + 0x10));
                                syslog(3, "%.80s way too much Accept: data", &httpd_ntoa.str);
                                i_5 = i_7;
                            }
                        }
                    }
                    else if (strncasecmp(r15_5, "Accept-Encoding:", 0x10) == 0)
                    {
                        void* r15_9 = ((r15_5 + strspn((r15_5 + 0x10), &data_13551)) + 0x10);
                        char* rdi_80 = *(i_7 + 0x128);
                        
                        if (*rdi_80 == 0)
                        {
                            httpd_realloc_str((i_7 + 0x128), (i_7 + 0x1b0), strlen(r15_9));
                            strcpy(*(i_7 + 0x128), r15_9);
                            i_5 = i_7;
                        }
                        else
                        {
                            uint64_t rax_76 = strlen(rdi_80);
                            
                            if (rax_76 < 0x1389)
                            {
                                httpd_realloc_str((i_7 + 0x128), (i_7 + 0x1b0), ((rax_76 + strlen(r15_9)) + 2));
                                char* rbx_15 = *(i_7 + 0x128);
                                uint64_t rax_87 = strlen(rbx_15);
                                *(rbx_15 + rax_87) = 0x202c;
                                rbx_15[(rax_87 + 2)] = 0;
                                strcpy(*(i_7 + 0x128), r15_9);
                                i_5 = i_7;
                            }
                            else
                            {
                                httpd_ntoa((i_7 + 0x10));
                                syslog(3, "%.80s way too much Accept-Encodiâ€¦", &httpd_ntoa.str);
                                i_5 = i_7;
                            }
                        }
                    }
                    else if (strncasecmp(r15_5, "Accept-Language:", 0x10) == 0)
                    {
                        i_5 = i_7;
                        *(i_5 + 0x130) = ((strspn((r15_5 + 0x10), &data_13551) + r15_5) + 0x10);
                    }
                    else
                    {
                        int64_t rax_84;
                        void* r15_10;
                        
                        if (strncasecmp(r15_5, "If-Modified-Since:", 0x12) == 0)
                        {
                            r15_10 = (r15_5 + 0x12);
                            rax_84 = tdate_parse(r15_10);
                            i_5 = i_7;
                            *(i_5 + 0x1e0) = rax_84;
                        label_b0e2:
                            
                            if (rax_84 == -1)
                                syslog(7, "unparsable time: %.80s", r15_10);
                        }
                        else if (strncasecmp(r15_5, "Cookie:", 7) == 0)
                        {
                            i_5 = i_7;
                            *(i_5 + 0x138) = ((strspn((r15_5 + 7), &data_13551) + r15_5) + 7);
                        }
                        else if (strncasecmp(r15_5, "Range:", 6) == 0)
                        {
                            i_5 = i_7;
                            
                            if (strchr(r15_5, 0x2c) == 0)
                            {
                                char* rax_93 = strchr(r15_5, 0x3d);
                                
                                if (rax_93 != 0)
                                {
                                    char* rax_94 = strchr(&rax_93[1], 0x2d);
                                    
                                    if ((rax_94 != 0 && rax_94 != &rax_93[1]))
                                    {
                                        *rax_94 = 0;
                                        *(i_5 + 0x210) = 1;
                                        int64_t rax_95 = strtoll(&rax_93[1], nullptr, 0xa);
                                        
                                        if (rax_95 < 0)
                                            rax_95 = 0;
                                        
                                        *(i_5 + 0x218) = rax_95;
                                        
                                        if ((*(&*__ctype_b_loc()[rax_94[1]] + 1) & 8) != 0)
                                        {
                                            int64_t rax_98 = strtoll(&rax_94[1], nullptr, 0xa);
                                            
                                            if (rax_98 < 0)
                                                rax_98 = -1;
                                            
                                            *(i_5 + 0x220) = rax_98;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            int32_t rax_54 = strncasecmp(r15_5, "Range-If:", 9);
                            int32_t rax_55;
                            
                            if (rax_54 != 0)
                                rax_55 = strncasecmp(r15_5, "If-Range:", 9);
                            
                            if ((rax_54 == 0 || rax_55 == 0))
                            {
                                r15_10 = (r15_5 + 9);
                                rax_84 = tdate_parse(r15_10);
                                i_5 = i_7;
                                *(i_5 + 0x1e8) = rax_84;
                                goto label_b0e2;
                            }
                            
                            if (strncasecmp(r15_5, "Content-Type:", 0xd) == 0)
                            {
                                i_5 = i_7;
                                *(i_5 + 0x140) = ((strspn((r15_5 + 0xd), &data_13551) + r15_5) + 0xd);
                            }
                            else if (strncasecmp(r15_5, "Content-Length:", 0xf) == 0)
                            {
                                i_5 = i_7;
                                *(i_5 + 0x1f0) = strtol((r15_5 + 0xf), nullptr, 0xa);
                            }
                            else if (strncasecmp(r15_5, "Authorization:", 0xe) == 0)
                            {
                                i_5 = i_7;
                                *(i_5 + 0x160) = ((strspn((r15_5 + 0xe), &data_13551) + r15_5) + 0xe);
                            }
                            else
                            {
                                i_5 = i_7;
                                
                                if ((strncasecmp(r15_5, "Connection:", 0xb) == 0 && strcasecmp(((r15_5 + strspn((r15_5 + 0xb), &data_13551)) + 0xb), "keep-alive") == 0))
                                    *(i_5 + 0x228) = 1;
                            }
                        }
                    }
                    
                    rcx_8 = *(i_5 + 0xa0);
                    rax_42 = *(i_5 + 0xa8);
                    
                    if (rax_42 >= rcx_8)
                        goto label_b242;
                }
                
                goto label_b354;
            }
            
        label_b242:
            i_12 = i_7;
            
            if (*(i_12 + 0x20c) != 0)
            {
                if ((**(i_12 + 0x148) == 0 && **(i_12 + 0x150) == 0))
                    goto label_b33c;
                
                if (*(i_12 + 0x228) != 0)
                    *(i_12 + 0x22c) = 1;
            }
            
            httpd_realloc_str((i_12 + 0xf0), (i_12 + 0x188), strlen(*(i_12 + 0xe8)));
            strcpy(*(i_12 + 0xf0), *(i_12 + 0xe8));
            void* rax_109 = *(i_12 + 8);
            char* sa;
            
            if (*(rax_109 + 0x64) == 0)
            {
            label_b46f:
                uint64_t rax_120 = expand_symlinks(*(i_12 + 0xf0), &sa, *(rax_109 + 0x60), *(i_12 + 0x214));
                
                if (rax_120 == 0)
                    goto label_b657;
                
                httpd_realloc_str((i_12 + 0xf0), (i_12 + 0x188), strlen(rax_120));
                strcpy(*(i_12 + 0xf0), rax_120);
                char* sa_1 = sa;
                httpd_realloc_str((i_12 + 0x100), (i_12 + 0x198), strlen(sa_1));
                strcpy(*(i_12 + 0x100), sa_1);
                char* rbx_22 = *(i_12 + 0x100);
                
                if (*rbx_22 != 0)
                {
                    char* r14_9 = *rbp_6;
                    int32_t rbp_19 = (strlen(r14_9) - strlen(rbx_22));
                    
                    if ((rbp_19 > 0 && strcmp(&r14_9[rbp_19], rbx_22) == 0))
                        r14_9[(rbp_19 - 1)] = 0;
                }
                
                char* rbp_21 = *(i_12 + 0xf0);
                rbx_17 = 0;
                
                if (*rbp_21 == 0x2f)
                {
                    char* r15_15 = *(*(i_12 + 8) + 0x40);
                    uint64_t rax_128 = strlen(r15_15);
                    
                    if (strncmp(rbp_21, r15_15, rax_128) == 0)
                    {
                        void* r14_11 = &rbp_21[rax_128];
                        memmove(rbp_21, r14_11, (strlen(r14_11) + 1));
                    }
                    else
                    {
                        httpd_ntoa((i_12 + 0x10));
                        syslog(5, "%.80s URL "%.80s" goes outside tâ€¦", &httpd_ntoa.str, *(i_12 + 0xd0));
                        httpd_send_err(i_12, 0x193, "Forbidden", &data_13553, "The requested URL '%.80s' resolvâ€¦", *(i_12 + 0xd0));
                        rbx_17 = -1;
                    }
                }
            }
            else
            {
                char* rbp_14 = *(i_12 + 0x148);
                
                if (*rbp_14 != 0)
                {
                label_b2e9:
                    *(i_12 + 0x200) = rbp_14;
                    i_5 = *rbp_14;
                    
                    if (i_5 != 0)
                    {
                        uint16_t** rax_110 = __ctype_b_loc();
                        void* rbp_15 = &rbp_14[1];
                        
                        do
                        {
                            int64_t rbx_16 = i_5;
                            
                            if ((*(&*rax_110[rbx_16] + 1) & 1) != 0)
                                *(rbp_15 - 1) = *__ctype_tolower_loc()[rbx_16];
                            
                            i_5 = *rbp_15;
                            rbp_15 += 1;
                        } while (i_5 != 0);
                    }
                    
                    if (*(i_12 + 0x214) == 0)
                    {
                        httpd_realloc_str((i_12 + 0x158), (i_12 + 0x1c0), strlen(*(i_12 + 0x200)));
                        strcpy(*(i_12 + 0x158), *(i_12 + 0x200));
                        int64_t rbx_19 = strlen(*(i_12 + 0xf0));
                        httpd_realloc_str(&vhost_map.tempfilename, &vhost_map.maxtempfilename, rbx_19);
                        strcpy(vhost_map.tempfilename, *(i_12 + 0xf0));
                        httpd_realloc_str((i_12 + 0xf0), (i_12 + 0x188), ((rbx_19 + strlen(*(i_12 + 0x158))) + 1));
                        strcpy(*(i_12 + 0xf0), *(i_12 + 0x158));
                        char* rbx_20 = *(i_12 + 0xf0);
                        *(rbx_20 + strlen(rbx_20)) = 0x2f;
                        strcat(*(i_12 + 0xf0), vhost_map.tempfilename);
                    }
                    
                    rax_109 = *(i_12 + 8);
                    goto label_b46f;
                }
                
                rbp_14 = *(i_12 + 0x150);
                
                if (*rbp_14 != 0)
                    goto label_b2e9;
                
                int32_t var_dc = 0x80;
                
                if (getsockname(*(i_12 + 0x2c0), &sa, &var_dc) >= 0)
                {
                    int16_t rax_133 = sa;
                    socklen_t addrlen_1 = 0x1c;
                    
                    if (rax_133 != 0xa)
                        addrlen_1 = 0;
                    
                    socklen_t addrlen = 0x10;
                    
                    if (rax_133 != 2)
                        addrlen = addrlen_1;
                    
                    rbp_14 = &httpd_ntoa.str;
                    int32_t var_a8;
                    int32_t var_a4;
                    int32_t var_a0;
                    
                    if (getnameinfo(&sa, addrlen, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                        httpd_ntoa.str = 0x3f;
                    else if ((var_a8 == 0 && (var_a4 == 0 && (var_a0 == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                    {
                        rbp_14 = &httpd_ntoa.str;
                        memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                    }
                    goto label_b2e9;
                }
                
                syslog(3, "getsockname - %m");
            label_b657:
                httpd_send_err(i_12, 0x1f4, "Internal Error", &data_13553, "There was an unusual problem serâ€¦", *(i_12 + 0xd0));
                rbx_17 = -1;
            }
        }
        else
        {
            if (strcasecmp(r15, "HEAD") == 0)
            {
                rax_20 = 2;
                goto label_a71e;
            }
            
            if (strcasecmp(r15, "POST") == 0)
            {
                rax_20 = 3;
                goto label_a71e;
            }
            
            if (strcasecmp(r15, &data_134f1) == 0)
            {
                rax_20 = 4;
                goto label_a71e;
            }
            
            if (strcasecmp(r15, "DELETE") == 0)
            {
                rax_20 = 5;
                goto label_a71e;
            }
            
            if (strcasecmp(r15, "TRACE") == 0)
            {
                rax_20 = 6;
                goto label_a71e;
            }
            
            httpd_send_err(i_12, 0x1f5, "Not Implemented", &data_13553, "The requested method '%.80s' is â€¦", r15);
            rbx_17 = -1;
        }
    }
    return rbx_17;
}

uint64_t expand_symlinks(char* arg1, uint64_t* arg2, int32_t arg3, int32_t arg4)
{
    void var_13b8;
    int32_t rax_1;
    
    if (arg3 != 0)
        rax_1 = stat(arg1, &var_13b8);
    
    if ((arg3 == 0 || rax_1 == 0xffffffff))
    {
        httpd_realloc_str(&expand_symlinks.checked, &expand_symlinks.maxchecked, 1);
        **&expand_symlinks.checked = 0;
        uint64_t rax_7 = strlen(arg1);
        uint64_t r15_1 = rax_7;
        httpd_realloc_str(&expand_symlinks.rest, &expand_symlinks.maxrest, rax_7);
        uint64_t expand_symlinks.rest_7 = expand_symlinks.rest;
        char* var_13c0 = arg1;
        strcpy(expand_symlinks.rest_7, arg1);
        uint64_t expand_symlinks.rest_1 = expand_symlinks.rest;
        
        if (*((expand_symlinks.rest_1 + r15_1) - 1) == 0x2f)
        {
            r15_1 -= 1;
            *(expand_symlinks.rest_1 + r15_1) = 0;
        }
        
        uint64_t expand_symlinks.rest_8 = expand_symlinks.rest;
        
        if (arg4 == 0)
        {
            while (*expand_symlinks.rest_8 == 0x2f)
            {
                memmove(expand_symlinks.rest_8, (expand_symlinks.rest_8 + 1), (strlen((expand_symlinks.rest_8 + 1)) + 1));
                r15_1 -= 1;
                expand_symlinks.rest_8 = expand_symlinks.rest;
            }
        }
        
        if (r15_1 == 0)
        {
        label_bcc5:
            *arg2 = expand_symlinks.rest_8;
            uint64_t expand_symlinks.checked_5 = expand_symlinks.checked;
            
            if (*expand_symlinks.checked_5 != 0)
                return expand_symlinks.checked_5;
            
            *expand_symlinks.checked_5 = 0x2e;
        }
        else
        {
            int32_t var_13cc_1 = 0;
            void* r12_1 = nullptr;
            
            while (true)
            {
                char* rax_9 = strchr(expand_symlinks.rest_8, 0x2f);
                uint64_t rax_13;
                uint64_t rbx_4;
                void* r13_3;
                
                if (rax_9 == 0)
                {
                    if (strcmp(expand_symlinks.rest_8, &data_13c3b) != 0)
                    {
                        httpd_realloc_str(&expand_symlinks.checked, &expand_symlinks.maxchecked, ((r12_1 + r15_1) + 1));
                        void* r13_2;
                        
                        if (r12_1 == 0)
                            r13_2 = nullptr;
                        else
                        {
                            uint64_t expand_symlinks.checked_2 = expand_symlinks.checked;
                            r13_2 = r12_1;
                            
                            if (*((r12_1 + expand_symlinks.checked_2) - 1) != 0x2f)
                            {
                                r13_2 = (r12_1 + 1);
                                *(expand_symlinks.checked_2 + r12_1) = 0x2f;
                            }
                        }
                        
                        strcpy((expand_symlinks.checked + r13_2), expand_symlinks.rest_8);
                        r13_3 = (r13_2 + r15_1);
                        rbx_4 = 0;
                    }
                    else if (r12_1 != 0)
                    {
                        char* expand_symlinks.checked_6 = expand_symlinks.checked;
                        char* rax_18 = strrchr(expand_symlinks.checked_6, 0x2f);
                        
                        if (rax_18 == 0)
                        {
                            r13_3 = nullptr;
                            *expand_symlinks.checked_6 = 0;
                        }
                        else
                        {
                            r13_3 = (rax_18 - expand_symlinks.checked_6);
                            
                            if (rax_18 == expand_symlinks.checked_6)
                                r13_3 = &*nullptr->ident.signature[1];
                            
                            *(expand_symlinks.checked_6 + r13_3) = 0;
                        }
                        
                        rbx_4 = 0;
                    }
                    else
                    {
                        rbx_4 = 0;
                        r13_3 = nullptr;
                    }
                    
                    rax_13 = r15_1;
                }
                else
                {
                    int32_t rbp_3 = (rax_9 - expand_symlinks.rest_8);
                    
                    if (rbp_3 == 0)
                    {
                        r13_3 = (r12_1 + 1);
                        httpd_realloc_str(&expand_symlinks.checked, &expand_symlinks.maxchecked, r13_3);
                        strncpy((expand_symlinks.checked + r12_1), expand_symlinks.rest_8, 1);
                    }
                    else
                    {
                        uint64_t rdx_3 = rbp_3;
                        
                        if (rbp_3 < 3)
                            rdx_3 = 2;
                        
                        if (strncmp(expand_symlinks.rest_8, &data_13c3b, rdx_3) != 0)
                        {
                            void* r13_1 = r12_1;
                            uint64_t r12_2 = rbp_3;
                            httpd_realloc_str(&expand_symlinks.checked, &expand_symlinks.maxchecked, ((r12_2 + r13_1) + 1));
                            void* rbx_3;
                            
                            if (r13_1 == 0)
                            {
                                rbx_3 = r13_1;
                                r13_1 = nullptr;
                            }
                            else
                            {
                                uint64_t expand_symlinks.checked_1 = expand_symlinks.checked;
                                rbx_3 = r13_1;
                                
                                if (*((r13_1 + expand_symlinks.checked_1) - 1) != 0x2f)
                                {
                                    r13_1 = (rbx_3 + 1);
                                    *(expand_symlinks.checked_1 + rbx_3) = 0x2f;
                                }
                            }
                            
                            strncpy((expand_symlinks.checked + r13_1), expand_symlinks.rest_8, r12_2);
                            r13_3 = (r13_1 + r12_2);
                            r12_1 = rbx_3;
                        }
                        else if (r12_1 != 0)
                        {
                            uint64_t expand_symlinks.checked_8 = expand_symlinks.checked;
                            char* rax_17 = strrchr(expand_symlinks.checked_8, 0x2f);
                            
                            if (rax_17 == 0)
                                r13_3 = nullptr;
                            else
                            {
                                r13_3 = (rax_17 - expand_symlinks.checked_8);
                                
                                if (rax_17 == expand_symlinks.checked_8)
                                    r13_3 = &*nullptr->ident.signature[1];
                            }
                            
                            r12_1 = r12_1;
                        }
                        else
                            r13_3 = nullptr;
                    }
                    
                    *(expand_symlinks.checked + r13_3) = 0;
                    rax_13 = (rbp_3 + 1);
                    rbx_4 = (r15_1 - rax_13);
                }
                
                expand_symlinks.rest_8 += rax_13;
                uint64_t expand_symlinks.checked_7 = expand_symlinks.checked;
                
                if (*expand_symlinks.checked_7 != 0)
                {
                    uint64_t rax_14 = readlink(expand_symlinks.checked_7, &var_13b8, 0x1387);
                    
                    if (rax_14 != -1)
                    {
                        if (var_13cc_1 == 0x20)
                            char* rdx_18 = var_13c0;
                        else
                        {
                            *(&var_13b8 + rax_14) = 0;
                            uint64_t rbp_5 = (rax_14 - 1);
                            char rcx_4 = *(&*var_13c0[7] + rax_14);
                            bool cond:5_1 = rcx_4 != 0x2f;
                            
                            if (rcx_4 == 0x2f)
                                rcx_4 = 0;
                            
                            *(&*var_13c0[7] + rax_14) = rcx_4;
                            
                            if (cond:5_1)
                                rbp_5 = rax_14;
                            
                            if (rbx_4 == 0)
                            {
                                httpd_realloc_str(&expand_symlinks.rest, &expand_symlinks.maxrest, rbp_5);
                                strcpy(expand_symlinks.rest, &var_13b8);
                                r15_1 = rbp_5;
                            }
                            else
                            {
                                memmove(expand_symlinks.rest, expand_symlinks.rest_8, (strlen(expand_symlinks.rest_8) + 1));
                                r15_1 = ((rbx_4 + rbp_5) + 1);
                                httpd_realloc_str(&expand_symlinks.rest, &expand_symlinks.maxrest, r15_1);
                                
                                if ((rbx_4 & 0x80000000) == 0)
                                {
                                    uint64_t i_3 = rbx_4;
                                    uint64_t i_1 = i_3;
                                    int64_t i_2 = ((rbx_4 + 1) & 3);
                                    
                                    if (i_2 != 0)
                                    {
                                        i_1 = i_3;
                                        int64_t i;
                                        
                                        do
                                        {
                                            uint64_t expand_symlinks.rest_6 = expand_symlinks.rest;
                                            *(i_1 + (expand_symlinks.rest_6 + (rbp_5 + 1))) = *(expand_symlinks.rest_6 + i_1);
                                            i_1 -= 1;
                                            i = i_2;
                                            i_2 -= 1;
                                        } while (i != 1);
                                    }
                                    
                                    if (i_3 >= 3)
                                    {
                                        do
                                        {
                                            uint64_t expand_symlinks.rest_2 = expand_symlinks.rest;
                                            *((i_1 + (expand_symlinks.rest_2 + rbp_5)) + 1) = *(expand_symlinks.rest_2 + i_1);
                                            uint64_t expand_symlinks.rest_3 = expand_symlinks.rest;
                                            *(i_1 + (expand_symlinks.rest_3 + rbp_5)) = *((expand_symlinks.rest_3 + i_1) - 1);
                                            uint64_t expand_symlinks.rest_4 = expand_symlinks.rest;
                                            *((i_1 + (expand_symlinks.rest_4 + rbp_5)) - 1) = *((expand_symlinks.rest_4 + i_1) - 2);
                                            uint64_t expand_symlinks.rest_5 = expand_symlinks.rest;
                                            *((i_1 + (expand_symlinks.rest_5 + rbp_5)) - 2) = *((expand_symlinks.rest_5 + i_1) - 3);
                                            i_1 -= 4;
                                        } while (i_1 != -1);
                                    }
                                }
                                
                                strcpy(expand_symlinks.rest, &var_13b8);
                                *(expand_symlinks.rest + rbp_5) = 0x2f;
                            }
                            
                            var_13cc_1 += 1;
                            expand_symlinks.rest_8 = expand_symlinks.rest;
                            
                            if (*expand_symlinks.rest_8 == 0x2f)
                                r12_1 = nullptr;
                            
                            *(expand_symlinks.checked + r12_1) = 0;
                            
                            if (r15_1 == 0)
                                goto label_bcc5;
                            
                            continue;
                        }
                        
                        syslog(3, "too many symlinks in %.80s", var_13c0);
                        return 0;
                    }
                    
                    int32_t rax_16 = *__errno_location();
                    
                    if (rax_16 != 0x16)
                    {
                        if ((rax_16 > 0x14 || !((TEST_BITD(0x102004, rax_16)))))
                        {
                            syslog(3, "readlink %.80s - %m", expand_symlinks.checked);
                            return 0;
                        }
                        
                        *arg2 = (expand_symlinks.rest_8 + (rbx_4 - r15_1));
                        
                        if (r12_1 == 0)
                            **&expand_symlinks.checked = 0x2e;
                        else
                            *(expand_symlinks.checked + r12_1) = 0;
                        
                        return expand_symlinks.checked;
                    }
                }
                
                r12_1 = r13_3;
                r15_1 = rbx_4;
                
                if (rbx_4 == 0)
                    goto label_bcc5;
            }
        }
    }
    else
    {
        uint64_t rax_2 = strlen(arg1);
        httpd_realloc_str(&expand_symlinks.checked, &expand_symlinks.maxchecked, rax_2);
        strcpy(expand_symlinks.checked, arg1);
        uint64_t expand_symlinks.checked_3 = expand_symlinks.checked;
        
        if (*((expand_symlinks.checked_3 + rax_2) - 1) == 0x2f)
        {
            int64_t rax_3 = (rax_2 - 1);
            char* rcx_1 = ((expand_symlinks.checked_3 + rax_2) - 1);
            int64_t rbx_2 = (rax_2 - 2);
            bool cond:0_1;
            
            do
            {
                *rcx_1 = 0;
                uint64_t expand_symlinks.checked_4 = expand_symlinks.checked;
                rcx_1 = ((expand_symlinks.checked_4 + rax_3) - 1);
                rax_3 -= 1;
                cond:0_1 = *(expand_symlinks.checked_4 + rbx_2) == 0x2f;
                rbx_2 -= 1;
            } while (cond:0_1);
        }
        
        httpd_realloc_str(&expand_symlinks.rest, &expand_symlinks.maxrest, 0);
        **&expand_symlinks.rest = 0;
        *arg2 = expand_symlinks.rest;
    }
    
    return expand_symlinks.checked;
}

time_t httpd_close_conn(void* arg1, int64_t* arg2)
{
    time_t result = *(arg1 + 8);
    
    if (*(result + 0x50) == 0)
    {
        char* rcx_1 = *(arg1 + 0x168);
        char const* const r15_1 = "-";
        
        if (*rcx_1 != 0)
            r15_1 = rcx_1;
        
        void var_1d8;
        
        if ((*(result + 0x64) == 0 || *(arg1 + 0x214) != 0))
        {
            *(arg1 + 0xd0);
            my_snprintf(&var_1d8, 0x131, "%.200s", 0);
        }
        else
        {
            if (*(arg1 + 0x200) == 0)
                *(result + 8);
            
            *(arg1 + 0xd0);
            my_snprintf(&var_1d8, 0x131, "/%.100s%.200s", 0);
        }
        
        int16_t var_278;
        
        if (*(arg1 + 0xc8) < 0)
            var_278 = 0x2d;
        else
            my_snprintf(&var_278, 0x28, "%lld", 0);
        
        if (*(*(arg1 + 8) + 0x58) == 0)
        {
            int16_t rax_1 = *(arg1 + 0x10);
            socklen_t addrlen_3 = 0x1c;
            
            if (rax_1 != 0xa)
                addrlen_3 = 0;
            
            socklen_t addrlen = 0x10;
            
            if (rax_1 != 2)
                addrlen = addrlen_3;
            
            int32_t var_2b8_1 = 1;
            
            if (getnameinfo((arg1 + 0x10), addrlen, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                httpd_ntoa.str = 0x3f;
            else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
            
            int32_t rax_24 = (*(arg1 + 0xb4) - 1);
            char const* const r8_5;
            
            if (rax_24 > 5)
                r8_5 = "UNKNOWN";
            else
                r8_5 = &data_18da0[rax_24];
            
            var_2b8_1 = *(arg1 + 0xe0);
            result = syslog(6, "%.80s - %.80s "%.80s %.200s %.80â€¦", &httpd_ntoa.str, r15_1, r8_5, &var_1d8, 1, *(arg1 + 0xb8), &var_278, *(arg1 + 0x110));
        }
        else
        {
            time_t t_1;
            
            if (arg2 == 0)
                t_1 = time(nullptr);
            else
                t_1 = *arg2;
            
            time_t t = t_1;
            struct tm* tp = localtime(&t);
            void s;
            strftime(&s, 0x64, "%d/%b/%Y:%H:%M:%S", tp);
            tp->tm_gmtoff;
            void var_248;
            my_snprintf(&var_248, 0x64, "%s %c%04d", 0);
            FILE* stream = *(*(arg1 + 8) + 0x58);
            int16_t rax_11 = *(arg1 + 0x10);
            socklen_t addrlen_2 = 0x1c;
            
            if (rax_11 != 0xa)
                addrlen_2 = 0;
            
            socklen_t addrlen_1 = 0x10;
            
            if (rax_11 != 2)
                addrlen_1 = addrlen_2;
            
            int32_t var_2b8_2 = 1;
            
            if (getnameinfo((arg1 + 0x10), addrlen_1, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                httpd_ntoa.str = 0x3f;
            else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
            
            int32_t rax_16 = (*(arg1 + 0xb4) - 1);
            char const* const r9_5;
            
            if (rax_16 > 5)
                r9_5 = "UNKNOWN";
            else
                r9_5 = &data_18da0[rax_16];
            
            int128_t var_2a0 = *(arg1 + 0x110);
            var_2a0 = &var_278;
            int64_t var_2a8;
            var_2a8 = *(arg1 + 0xb8);
            int32_t var_2b0;
            var_2b0 = *(arg1 + 0xe0);
            var_2b8_2 = &var_1d8;
            fprintf(stream, "%.80s - %.80s [%s] "%.80s %.300sâ€¦", &httpd_ntoa.str, r15_1, &var_248, r9_5, var_2b8_2, var_2b0, var_2a8, var_2a0);
            result = fflush(*(*(arg1 + 8) + 0x58));
        }
    }
    
    int64_t rdi_10 = *(arg1 + 0x2c8);
    
    if (rdi_10 != 0)
    {
        result = mmc_unmap(rdi_10, (arg1 + 0x230), arg2);
        *(arg1 + 0x2c8) = 0;
    }
    
    int32_t fd = *(arg1 + 0x2c0);
    
    if (fd >= 0)
    {
        result = close(fd);
        *(arg1 + 0x2c0) = 0xffffffff;
    }
    
    return result;
}

void httpd_destroy_conn(int32_t* arg1)
{
    if (*arg1 != 0)
    {
        free(*(arg1 + 0x90));
        free(*(arg1 + 0xd8));
        free(*(arg1 + 0xe8));
        free(*(arg1 + 0xf0));
        free(*(arg1 + 0xf8));
        free(*(arg1 + 0x100));
        free(*(arg1 + 0x108));
        free(*(arg1 + 0x120));
        free(*(arg1 + 0x128));
        free(*(arg1 + 0x148));
        free(*(arg1 + 0x158));
        free(*(arg1 + 0x168));
        free(*(arg1 + 0x170));
        *arg1 = 0;
    }
}

uint64_t httpd_start_request(void* arg1, int64_t* arg2)
{
    char* rbx = *(arg1 + 0xf0);
    uint64_t r12 = strlen(rbx);
    void* rsi = (arg1 + 0x230);
    char const* const httpd_err503title_1;
    int32_t rsi_1;
    void* rdi_2;
    char const* const httpd_err503form_1;
    char* r9_1;
    
    if (stat(rbx, rsi) < 0)
    {
    label_c5a8:
        r9_1 = *(arg1 + 0xd0);
        httpd_err503title_1 = "Internal Error";
        httpd_err503form_1 = "There was an unusual problem serâ€¦";
        rdi_2 = arg1;
    label_c5c7:
        rsi_1 = 0x1f4;
    label_c5cc:
        httpd_send_err(rdi_2, rsi_1, httpd_err503title_1, &data_13553, httpd_err503form_1, r9_1);
        return -1;
    }
    
    int32_t rax_2 = *(arg1 + 0x248);
    
    if ((rax_2 & 5) == 0)
    {
        int16_t rax_5 = *(arg1 + 0x10);
        socklen_t addrlen_7 = 0x1c;
        
        if (rax_5 != 0xa)
            addrlen_7 = 0;
        
        socklen_t addrlen = 0x10;
        
        if (rax_5 != 2)
            addrlen = addrlen_7;
        
        if (getnameinfo((arg1 + 0x10), addrlen, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
            httpd_ntoa.str = 0x3f;
        else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
            memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
        
        syslog(6, "%.80s URL "%.80s" resolves to a â€¦", &httpd_ntoa.str, *(arg1 + 0xd0));
        r9_1 = *(arg1 + 0xd0);
        httpd_err503title_1 = "Forbidden";
        httpd_err503form_1 = "The requested URL '%.80s' resolvâ€¦";
    }
    else
    {
        void* r14_1 = (arg1 + 0xf0);
        int64_t var_11f8_1;
        time_t var_11f0_1;
        void* var_11e0;
        char var_1038;
        char* rcx_5;
        void* rdx_4;
        void* rbx_2;
        int32_t rsi_8;
        char const* const fmt;
        void* rdi_20;
        int64_t pri;
        char* r9_2;
        char* r9_7;
        
        if ((rax_2 & 0xf000) == 0x4000)
        {
            if (**(arg1 + 0x100) != 0)
            {
                r9_1 = *(arg1 + 0xd0);
                httpd_err503title_1 = "Not Found";
                httpd_err503form_1 = "The requested URL '%.80s' was noâ€¦";
                rdi_2 = arg1;
                rsi_1 = 0x194;
                goto label_c5cc;
            }
            
            char* rbx_1 = *(arg1 + 0xe8);
            
            if (((*rbx_1 != 0 && strcmp(rbx_1, &data_13c3c) != 0) && rbx_1[(strlen(rbx_1) - 1)] != 0x2f))
            {
                char* rbp_3 = *(arg1 + 0xd0);
                char* rbx_4 = *(arg1 + 0x108);
                
                if (*rbx_4 == 0)
                {
                    httpd_realloc_str(&send_dirredirect.location, &send_dirredirect.maxlocation, (strlen(rbp_3) + 1));
                    *(arg1 + 0xd0);
                    my_snprintf(send_dirredirect.location, send_dirredirect.maxlocation, &data_14d4e, 0);
                }
                else
                {
                    char* rax_28 = strchr(rbp_3, 0x3f);
                    
                    if (rax_28 != 0)
                    {
                        *rax_28 = 0;
                        rbp_3 = *(arg1 + 0xd0);
                        rbx_4 = *(arg1 + 0x108);
                    }
                    
                    uint64_t rax_29 = strlen(rbp_3);
                    httpd_realloc_str(&send_dirredirect.location, &send_dirredirect.maxlocation, ((strlen(rbx_4) + rax_29) + 2));
                    *(arg1 + 0xd0);
                    *(arg1 + 0x108);
                    my_snprintf(send_dirredirect.location, send_dirredirect.maxlocation, "%s/?%s", 0);
                }
                
                httpd_realloc_str(&send_dirredirect.header, &send_dirredirect.maxheader, (strlen(send_dirredirect.location) + 0xb));
                send_dirredirect.location;
                my_snprintf(send_dirredirect.header, send_dirredirect.maxheader, "%s%s\r\n", 0);
                send_response(arg1, 0x12e, "Found", send_dirredirect.header, "The actual URL is '%.80s'.\n", send_dirredirect.location);
                return -1;
            }
            
            uint64_t var_10c8;
            
            for (int64_t i = 0; i != 0x30; )
            {
                char* r15_1 = *(i + &really_start_request.index_names);
                httpd_realloc_str(&really_start_request.indexname, &really_start_request.maxindexname, (strlen(r15_1) + (r12 + 1)));
                void* rbp_1 = r14_1;
                strcpy(really_start_request.indexname, *r14_1);
                uint64_t really_start_request.indexname_1 = really_start_request.indexname;
                uint64_t rax_13 = strlen(really_start_request.indexname_1);
                
                if ((rax_13 == 0 || *((rax_13 + really_start_request.indexname_1) - 1) != 0x2f))
                {
                    *(really_start_request.indexname_1 + strlen(really_start_request.indexname_1)) = 0x2f;
                    really_start_request.indexname_1 = really_start_request.indexname;
                }
                
                if (strcmp(really_start_request.indexname_1, "./") == 0)
                {
                    *really_start_request.indexname_1 = 0;
                    really_start_request.indexname_1 = really_start_request.indexname;
                }
                
                strcat(really_start_request.indexname_1, r15_1);
                
                if (stat(really_start_request.indexname, rsi) >= 0)
                {
                    char* rax_20 = expand_symlinks(really_start_request.indexname, &var_10c8, *(*(arg1 + 8) + 0x60), *(arg1 + 0x214));
                    
                    if (rax_20 == 0)
                        goto label_c5a8;
                    
                    if (*var_10c8 != 0)
                        goto label_c5a8;
                    
                    r14_1 = rbp_1;
                    uint64_t rax_31 = strlen(rax_20);
                    r12 = rax_31;
                    httpd_realloc_str(rbp_1, (arg1 + 0x188), rax_31);
                    strcpy(*(arg1 + 0xf0), rax_20);
                    
                    if ((*(arg1 + 0x248) & 5) != 0)
                        goto label_c78f;
                    
                    int16_t rax_82 = *(arg1 + 0x10);
                    socklen_t addrlen_12 = 0x1c;
                    
                    if (rax_82 != 0xa)
                        addrlen_12 = 0;
                    
                    socklen_t addrlen_5 = 0x10;
                    
                    if (rax_82 != 2)
                        addrlen_5 = addrlen_12;
                    
                    if (getnameinfo((arg1 + 0x10), addrlen_5, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                        httpd_ntoa.str = 0x3f;
                    else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                        memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                    
                    syslog(6, "%.80s URL "%.80s" resolves to a â€¦", &httpd_ntoa.str, *(arg1 + 0xd0));
                    r9_1 = *(arg1 + 0xd0);
                    httpd_err503title_1 = "Forbidden";
                    httpd_err503form_1 = "The requested URL '%.80s' resolvâ€¦";
                    goto label_c3e4;
                }
                
                i += 8;
                r14_1 = rbp_1;
            }
            
            rbx_2 = arg1;
            
            if ((*(rbx_2 + 0x248) & 4) == 0)
            {
                int16_t rax_17 = *(rbx_2 + 0x10);
                socklen_t addrlen_8 = 0x1c;
                
                if (rax_17 != 0xa)
                    addrlen_8 = 0;
                
                socklen_t addrlen_1 = 0x10;
                
                if (rax_17 != 2)
                    addrlen_1 = addrlen_8;
                
                if (getnameinfo((rbx_2 + 0x10), addrlen_1, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                    httpd_ntoa.str = 0x3f;
                else if ((*(rbx_2 + 0x18) == 0 && (*(rbx_2 + 0x1c) == 0 && (*(rbx_2 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                    memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                
                syslog(6, "%.80s URL "%.80s" tried to indexâ€¦", &httpd_ntoa.str, *(rbx_2 + 0xd0));
                r9_1 = *(rbx_2 + 0xd0);
                httpd_err503title_1 = "Forbidden";
                httpd_err503form_1 = "The requested URL '%.80s' resolvâ€¦";
                rdi_2 = rbx_2;
                rsi_1 = 0x193;
                goto label_c5cc;
            }
            
            void* rax_23 = *(rbx_2 + 8);
            char* r15_2 = *(rbx_2 + 0xf0);
            
            if (*(rax_23 + 0x68) == 0)
            {
            label_c62e:
                
                if (auth_check2(rbx_2, r15_2) == 0xffffffff)
                    return -1;
            }
            else
            {
                char* rsi_6;
                
                if (*(rax_23 + 0x64) != 0)
                    rsi_6 = *(rbx_2 + 0x158);
                
                if ((*(rax_23 + 0x64) == 0 || *rsi_6 == 0))
                    rsi_6 = &data_13c3c;
                
                int32_t rax_24 = auth_check2(rbx_2, rsi_6);
                
                if (rax_24 == 0xffffffff)
                    return rax_24;
                
                if (rax_24 != 1)
                    goto label_c62e;
            }
            
            if (check_referrer(rbx_2) == 0)
                return -1;
            
            DIR* dirp = opendir(*r14_1);
            
            if (dirp == 0)
            {
                syslog(3, "opendir %.80s - %m", *(rbx_2 + 0xf0));
                r9_1 = *(rbx_2 + 0xd0);
                httpd_err503title_1 = "Not Found";
                httpd_err503form_1 = "The requested URL '%.80s' was noâ€¦";
                rdi_2 = rbx_2;
                rsi_1 = 0x194;
                goto label_c5cc;
            }
            
            int32_t rax_27 = *(rbx_2 + 0xb4);
            
            if (rax_27 != 1)
            {
                if (rax_27 != 2)
                {
                    closedir(dirp);
                    int32_t rax_88 = (*(rbx_2 + 0xb4) - 1);
                    
                    if (rax_88 > 5)
                        r9_7 = "UNKNOWN";
                    else
                        r9_7 = &data_18da0[rax_88];
                    
                    httpd_send_err(rbx_2, 0x1f5, "Not Implemented", &data_13553, "The requested method '%.80s' is â€¦", r9_7);
                    return -1;
                }
                
                closedir(dirp);
                rdx_4 = &data_15488;
                rcx_5 = &data_13553;
                r9_2 = "text/html; charset=%s";
                rdi_20 = rbx_2;
                rsi_8 = 0xc8;
                var_11f0_1 = *(rbx_2 + 0x288);
                var_11f8_1 = -1;
            label_d44d:
                send_mime(rdi_20, rsi_8, rdx_4, rcx_5, &data_13553, r9_2, var_11f8_1, var_11f0_1);
                return 0;
            }
            
            void* rax_86 = *(rbx_2 + 8);
            int32_t rdx_28 = *(rax_86 + 0x20);
            int32_t rcx_31 = *(rax_86 + 0x24);
            
            if ((rdx_28 != 0 && rcx_31 >= rdx_28))
            {
                closedir(dirp);
                httpd_err503title_1 = httpd_err503title;
                httpd_err503form_1 = httpd_err503form;
                r9_1 = *(rbx_2 + 0xd0);
                rdi_2 = rbx_2;
                rsi_1 = 0x1f7;
                goto label_c5cc;
            }
            
            *(rax_86 + 0x24) = (rcx_31 + 1);
            pid_t rax_93 = fork();
            
            if (rax_93 < 0)
            {
                syslog(3, "fork - %m");
                closedir(dirp);
            label_d45d:
                r9_1 = *(rbx_2 + 0xd0);
                httpd_err503title_1 = "Internal Error";
                httpd_err503form_1 = "There was an unusual problem serâ€¦";
                rdi_2 = rbx_2;
                goto label_c5c7;
            }
            
            if (rax_93 != 0)
            {
                closedir(dirp);
                syslog(7, "spawned indexing process %d for â€¦", rax_93, *r14_1);
                
                if (tmr_create(nullptr, cgi_kill, rax_93, 0x7530, 0) == 0)
                {
                    fmt = "tmr_create(cgi_kill ls) failed";
                    goto label_d663;
                }
                
                *(rbx_2 + 0xb8) = 0xc8;
                *(rbx_2 + 0xc8) = 0x61a8;
                *(rbx_2 + 0x22c) = 0;
                return 0;
            }
            
            sub_process = 1;
            void* rbp_21 = *(rbx_2 + 8);
            int32_t fd_3 = *(rbp_21 + 0x48);
            
            if (fd_3 != 0xffffffff)
            {
                close(fd_3);
                *(rbp_21 + 0x48) = 0xffffffff;
            }
            
            int32_t fd_4 = *(rbp_21 + 0x4c);
            
            if (fd_4 != 0xffffffff)
            {
                close(fd_4);
                *(rbp_21 + 0x4c) = 0xffffffff;
            }
            
            send_mime(arg1, 0xc8, &data_15488, &data_13553, &data_13553, "text/html; charset=%s", -1, *(arg1 + 0x288));
            httpd_write_response(arg1);
            nice(0xa);
            FILE* rax_201 = fdopen(*(arg1 + 0x2c0), "w");
            
            if (rax_201 == 0)
            {
                syslog(3, "fdopen - %m");
                httpd_send_err(arg1, 0x1f4, "Internal Error", &data_13553, "There was an unusual problem serâ€¦", *(arg1 + 0xd0));
                httpd_write_response(arg1);
                closedir(dirp);
                exit(1);
                /* no return */
            }
            
            int64_t rbx_31 = 0;
            fprintf(rax_201, "<!DOCTYPE html PUBLIC "-//W3C//Dâ€¦", *(arg1 + 0xd0));
            struct dirent64* rax_207 = readdir(dirp);
            
            if (rax_207 != 0)
            {
                struct dirent64* r14_9 = rax_207;
                rbx_31 = 0;
                
                while (true)
                {
                    int64_t ls.maxnames_1 = ls.maxnames;
                    uint64_t ls.nameptrs_2;
                    
                    if (rbx_31 < ls.maxnames_1)
                        ls.nameptrs_2 = ls.nameptrs;
                    else
                    {
                        uint64_t rbp_23;
                        
                        if (ls.maxnames_1 == 0)
                        {
                            ls.maxnames = 0x64;
                            uint64_t rax_215 = malloc(0x64064);
                            rbp_23 = rax_215;
                            ls.names = rax_215;
                            uint64_t ls.nameptrs_4 = malloc(0x320);  {  // {"d-linux-x86-64.so.2"}}
                            ls.nameptrs = ls.nameptrs_4;
                            
                            if (rbp_23 == 0)
                            {
                            label_e830:
                                fmt = "out of memory reallocating direcâ€¦";
                                pri = 3;
                                break;
                            }
                            
                            ls.nameptrs_2 = ls.nameptrs_4;
                            
                            if (ls.nameptrs_4 == 0)
                                goto label_e830;
                            
                            var_11e0 = 0x64;
                        label_e288:
                            uint64_t rcx_82 = var_11e0;
                            uint64_t rax_217 = (rcx_82 & 2);
                            int64_t i_1;
                            
                            if ((rcx_82 - 1) >= 3)
                            {
                                int64_t rsi_58 = 0x2002;
                                i_1 = 0;
                                
                                do
                                {
                                    *(ls.nameptrs_2 + (i_1 << 3)) = (((rsi_58 - 0x2002) & 0xfffffffc) + rbp_23);
                                    *((ls.nameptrs_2 + (i_1 << 3)) + 8) = (((rsi_58 - 0x1001) & 0xfffffffd) + rbp_23);  {  // {"e"}}
                                    *((ls.nameptrs_2 + (i_1 << 3)) + 0x10) = ((rsi_58 & 0xfffffffe) + rbp_23);
                                    *((ls.nameptrs_2 + (i_1 << 3)) + 0x18) = (&*"e"[rsi_58] + rbp_23);
                                    i_1 += 4;
                                    rsi_58 += 0x4004;
                                } while ((rcx_82 & 0xfffffffc) != i_1);
                            }
                            else
                                i_1 = 0;
                            
                            if (rax_217 != 0)
                            {
                                void* rsi_61 = (i_1 * 0x1001);  {  // {"e"}}
                                int64_t rdx_47 = 0;
                                
                                do
                                {
                                    *((ls.nameptrs_2 + (i_1 << 3)) + (rdx_47 << 3)) = (rsi_61 + rbp_23);
                                    rdx_47 += 1;
                                    rsi_61 += "e";
                                } while (rax_217 != rdx_47);
                            }
                        }
                        else
                        {
                            int32_t rax_211 = (ls.maxnames_1 * 2);
                            var_11e0 = rax_211;
                            ls.maxnames = rax_211;
                            uint64_t rax_214 = realloc(ls.names, (ls.maxnames_1 * 0x2002));
                            rbp_23 = rax_214;
                            ls.names = rax_214;
                            uint64_t ls.nameptrs_3 = realloc(ls.nameptrs, (ls.maxnames_1 << 4));
                            ls.nameptrs = ls.nameptrs_3;
                            
                            if (rbp_23 == 0)
                                goto label_e830;
                            
                            ls.nameptrs_2 = ls.nameptrs_3;
                            
                            if (ls.nameptrs_3 == 0)
                                goto label_e830;
                            
                            if (ls.maxnames_1 > 0)
                                goto label_e288;
                        }
                    }
                    
                    uint64_t rbp_22 = strlen(&r14_9->d_name);
                    strncpy(*(ls.nameptrs_2 + (rbx_31 << 3)), &r14_9->d_name, rbp_22);
                    *(*(ls.nameptrs_2 + (rbx_31 << 3)) + rbp_22) = 0;
                    rbx_31 += 1;
                    struct dirent64* rax_210 = readdir(dirp);
                    r14_9 = rax_210;
                    
                    if (rax_210 == 0)
                        goto label_e0ba;
                }
                
                goto label_d66a;
            }
            
        label_e0ba:
            closedir(dirp);
            uint64_t n = rbx_31;
            qsort(ls.nameptrs, n, 8, name_compare);
            
            if (rbx_31 != 0)
            {
                int64_t rbx_33 = 0;
                
                do
                {
                    httpd_realloc_str(&ls.name, &ls.maxname, ((strlen(*(arg1 + 0xf0)) + strlen(*(ls.nameptrs + (rbx_33 << 3)))) + 1));
                    httpd_realloc_str(&ls.rname, &ls.maxrname, ((strlen(*(arg1 + 0xe8)) + strlen(*(ls.nameptrs + (rbx_33 << 3)))) + 1));
                    char* rbp_27 = *(arg1 + 0xf0);
                    int32_t rax_227;
                    
                    if (*rbp_27 != 0)
                        rax_227 = strcmp(rbp_27, &data_13c3c);
                    
                    if ((*rbp_27 == 0 || rax_227 == 0))
                    {
                        uint64_t ls.nameptrs_1 = ls.nameptrs;
                        strcpy(ls.name, *(ls.nameptrs_1 + (rbx_33 << 3)));
                        strcpy(ls.rname, *(ls.nameptrs_1 + (rbx_33 << 3)));
                    }
                    else
                    {
                        *(ls.nameptrs + (rbx_33 << 3));
                        my_snprintf(ls.name, ls.maxname, "%s/%s", 0);
                        int32_t rax_230 = strcmp(*(arg1 + 0xe8), &data_13c3c);
                        uint64_t ls.rname_1 = ls.rname;
                        uint64_t ls.maxrname_1 = ls.maxrname;
                        *(ls.nameptrs + (rbx_33 << 3));
                        
                        if (rax_230 == 0)
                            my_snprintf(ls.rname_1, ls.maxrname_1, "%s", 0);
                        else
                            my_snprintf(ls.rname_1, ls.maxrname_1, "%s%s", 0);
                    }
                    
                    httpd_realloc_str(&ls.encrname, &ls.maxencrname, ((strlen(ls.rname) * 3) + 1));
                    char* ls.encrname_1 = ls.encrname;
                    int32_t ls.maxencrname_1 = *ls.maxencrname;
                    
                    if (ls.maxencrname_1 >= 5)
                    {
                        char* ls.rname_2 = ls.rname;
                        DIR* r15_3;
                        r15_3 = *ls.rname_2;
                        
                        if (r15_3 != 0)
                        {
                            uint16_t** rax_232 = __ctype_b_loc();
                            void* r12_11 = &ls.rname_2[1];
                            int32_t r14_13 = 0;
                            int32_t rcx_92;
                            
                            do
                            {
                                int64_t rax_234;
                                
                                if ((*rax_232[r15_3] & 8) == 0)
                                    rax_234 = memchr("/_.-~", r15_3, 6);
                                
                                int32_t rax_235;
                                int64_t rcx_90;
                                
                                if (((*rax_232[r15_3] & 8) == 0 && rax_234 == 0))
                                {
                                    sprintf(ls.encrname_1, "%%%02x", r15_3);
                                    rax_235 = 3;
                                    rcx_90 = 3;
                                }
                                else
                                {
                                    *ls.encrname_1 = r15_3;
                                    rax_235 = 1;
                                    rcx_90 = 1;
                                }
                                
                                ls.encrname_1 = &ls.encrname_1[rcx_90];
                                r15_3 = *r12_11;
                                
                                if (r15_3 == 0)
                                    break;
                                
                                rcx_92 = ((rax_235 + r14_13) + 4);
                                r12_11 += 1;
                                r14_13 += rax_235;
                            } while (rcx_92 < ls.maxencrname_1);
                        }
                    }
                    
                    *ls.encrname_1 = 0;
                    void var_1158;
                    
                    if ((stat(ls.name, &var_10c8) >= 0 && lstat(ls.name, &var_1158) >= 0))
                    {
                        var_1038 = 0;
                        int32_t var_1140;
                        uint64_t rax_243 = (((var_1140 & 0xf000) - 0x1000) >> 0xc);  {  // {"me"}}
                        char var_11c8;
                        void* const r14_14;
                        
                        if (rax_243 > 0xb)
                        {
                            var_11c8 = 0x3f;
                            r14_14 = &data_13553;
                        }
                        else
                            switch (rax_243)
                            {
                                case 0:
                                {
                                    var_11c8 = 0x70;
                                    r14_14 = &data_13553;
                                    break;
                                }
                                case 1:
                                {
                                    var_11c8 = 0x63;
                                    r14_14 = &data_13553;
                                    break;
                                }
                                case 2:
                                case 4:
                                case 6:
                                case 8:
                                case 0xa:
                                {
                                    var_11c8 = 0x3f;
                                    r14_14 = &data_13553;
                                    break;
                                }
                                case 3:
                                {
                                    var_11c8 = 0x64;
                                    r14_14 = &data_13553;
                                    break;
                                }
                                case 5:
                                {
                                    var_11c8 = 0x62;
                                    r14_14 = &data_13553;
                                    break;
                                }
                                case 7:
                                {
                                    var_11c8 = 0x2d;
                                    r14_14 = &data_13553;
                                    break;
                                }
                                case 9:
                                {
                                    var_11c8 = 0x6c;
                                    int32_t rax_246 = readlink(ls.name, &var_1038, "me", &jump_table_12d70);
                                    r14_14 = &data_13553;
                                    
                                    if (rax_246 != 0xffffffff)
                                    {
                                        &var_1038[rax_246] = 0;
                                        r14_14 = " -&gt; ";
                                    }
                                    break;
                                }
                                case 0xb:
                                {
                                    var_11c8 = 0x73;
                                    r14_14 = &data_13553;
                                    break;
                                }
                            }
                        
                        char rax_248 = var_1140;
                        char rcx_94 = 0x72;
                        
                        if ((rax_248 & 4) == 0)
                            rcx_94 = 0x2d;
                        
                        char rdx_56 = 0x77;
                        
                        if ((rax_248 & 2) == 0)
                            rdx_56 = 0x2d;
                        
                        char var_11c7_1 = rcx_94;
                        char var_11c6_1 = rdx_56;
                        char rax_249 = 0x78;
                        
                        if ((rax_248 & 1) == 0)
                            rax_249 = 0x2d;
                        
                        char var_11c5_1 = rax_249;
                        char var_11c4_1 = 0;
                        time_t rax_250 = time(nullptr);
                        int64_t t;
                        char* rax_251 = ctime(&t);
                        *rax_251 = rax_251[4];
                        *(rax_251 + 1) = *(rax_251 + 5);
                        rax_251[3] = 0x20;
                        *(rax_251 + 4) = *(rax_251 + 8);
                        rax_251[6] = 0x20;
                        
                        if ((rax_250 - t) < 0xeff101)
                        {
                            int16_t rdx_57 = *(rax_251 + 0xe);
                            *(rax_251 + 7) = *(rax_251 + 0xb);
                            rax_251[9] = 0x3a;
                            *(rax_251 + 0xa) = rdx_57;
                        }
                        else
                        {
                            rax_251[7] = 0x20;
                            *(rax_251 + 8) = *(rax_251 + 0x14);
                        }
                        
                        rax_251[0xc] = 0;
                        int32_t var_10b0;
                        int32_t rdx_59 = (var_10b0 & 0xf000);
                        char const* const rbp_24;
                        
                        if (rdx_59 == 0xa000)
                            rbp_24 = &data_150ca;
                        else
                        {
                            uint32_t rsi_69 = rdx_59;
                            rbp_24 = "/";
                            
                            if (rsi_69 != 0x4000)
                            {
                                if (rsi_69 != 0xc000)
                                {
                                    rbp_24 = "*";
                                    
                                    if ((var_10b0 & 1) == 0)
                                        rbp_24 = &data_13553;
                                }
                                else
                                    rbp_24 = &data_13618;
                            }
                        }
                        
                        void* const rbx_34 = &data_13553;
                        
                        if (rdx_59 == 0x4000)
                            rbx_34 = "/";
                        
                        int64_t var_1148;
                        int64_t var_1128;
                        fprintf(rax_201, "%s %3ld  %10lld  %s  <a href="/%â€¦", &var_11c8, var_1148, var_1128, rax_251, ls.encrname, rbx_34, *(ls.nameptrs + (rbx_33 << 3)), r14_14, &var_1038, rbp_24, arg1, rbx_33, rax_201, n);
                    }
                    
                    rbx_33 += 1;
                } while (rbx_33 != n);
            }
            
            fwrite("    </pre>\n  </body>\n</html>\n", 0x1d, 1, rax_201);
            fclose(rax_201);
            exit(0);
            /* no return */
        }
        
    label_c78f:
        httpd_realloc_str(&really_start_request.dirname, &really_start_request.maxdirname, r12);
        strcpy(really_start_request.dirname, *r14_1);
        uint64_t really_start_request.dirname_1 = really_start_request.dirname;
        char* rax_32 = strrchr(really_start_request.dirname_1, 0x2f);
        
        if (rax_32 == 0)
            *really_start_request.dirname_1 = 0x2e;
        else
            *rax_32 = 0;
        
        char* really_start_request.dirname_2 = really_start_request.dirname;
        void* rax_33 = *(arg1 + 8);
        
        if (*(rax_33 + 0x68) == 0)
        {
        label_c80e:
            
            if (auth_check2(arg1, really_start_request.dirname_2) == 0xffffffff)
                return -1;
        }
        else
        {
            char* rsi_13;
            
            if (*(rax_33 + 0x64) != 0)
                rsi_13 = *(arg1 + 0x158);
            
            if ((*(rax_33 + 0x64) == 0 || *rsi_13 == 0))
                rsi_13 = &data_13c3c;
            
            int32_t rax_34 = auth_check2(arg1, rsi_13);
            
            if (rax_34 == 0xffffffff)
                return rax_34;
            
            if (rax_34 != 1)
                goto label_c80e;
        }
        
        if (r12 != 9)
        {
            if (r12 > 9)
            {
                int64_t rbx_5 = *r14_1;
                
                if ((strcmp(((r12 + rbx_5) - 9), ".htpasswd") != 0 || *((r12 + rbx_5) - 0xa) != 0x2f))
                    goto label_c8b7;
                
                goto label_c839;
            }
            
        label_c8b7:
            int32_t rbp_2 = -1;
            
            if (check_referrer(arg1) == 0)
                return rbp_2;
            
            char* rdi_37 = *(*(arg1 + 8) + 0x18);
            int32_t rax_42;
            
            if ((rdi_37 != 0 && (*(arg1 + 0x248) & 1) != 0))
                rax_42 = match(rdi_37, *r14_1);
            
            if (((rdi_37 == 0 || (*(arg1 + 0x248) & 1) == 0) || rax_42 == 0))
            {
                if ((*(arg1 + 0x248) & 1) != 0)
                {
                    int16_t rax_47 = *(arg1 + 0x10);
                    socklen_t addrlen_11 = 0x1c;
                    
                    if (rax_47 != 0xa)
                        addrlen_11 = 0;
                    
                    socklen_t addrlen_4 = 0x10;
                    
                    if (rax_47 != 2)
                        addrlen_4 = addrlen_11;
                    
                    if (getnameinfo((arg1 + 0x10), addrlen_4, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                        httpd_ntoa.str = 0x3f;
                    else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                        memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                    
                    syslog(5, "%.80s URL "%.80s" is executable â€¦", &httpd_ntoa.str, *(arg1 + 0xd0));
                    httpd_send_err(arg1, 0x193, "Forbidden", &data_13553, "The requested URL '%.80s' resolvâ€¦", *(arg1 + 0xd0));
                    return rbp_2;
                }
                
                if (**(arg1 + 0x100) != 0)
                {
                    int16_t rax_45 = *(arg1 + 0x10);
                    socklen_t addrlen_10 = 0x1c;
                    
                    if (rax_45 != 0xa)
                        addrlen_10 = 0;
                    
                    socklen_t addrlen_3 = 0x10;
                    
                    if (rax_45 != 2)
                        addrlen_3 = addrlen_10;
                    
                    if (getnameinfo((arg1 + 0x10), addrlen_3, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                        httpd_ntoa.str = 0x3f;
                    else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                        memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                    
                    syslog(6, "%.80s URL "%.80s" has pathinfo bâ€¦", &httpd_ntoa.str, *(arg1 + 0xd0));
                    httpd_send_err(arg1, 0x193, "Forbidden", &data_13553, "The requested URL '%.80s' resolvâ€¦", *(arg1 + 0xd0));
                    return rbp_2;
                }
                
                int32_t rax_52 = *(arg1 + 0xb4);
                
                if ((rax_52 - 1) >= 2)
                {
                    if ((rax_52 - 3) > 3)
                        r9_7 = "UNKNOWN";
                    else
                        r9_7 = (*(&data_13280 + ((rax_52 - 3) << 2)) + &data_13280);
                    
                    httpd_send_err(arg1, 0x1f5, "Not Implemented", &data_13553, "The requested method '%.80s' is â€¦", r9_7);
                    return rbp_2;
                }
                
                if (*(arg1 + 0x210) != 0)
                {
                    int64_t rcx_12 = *(arg1 + 0x220);
                    int64_t rax_53 = *(arg1 + 0x260);
                    
                    if ((rcx_12 == -1 || rcx_12 >= rax_53))
                        *(arg1 + 0x220) = (rax_53 - 1);
                }
                
                char* rbx_6 = *r14_1;
                void* rax_56 = &rbx_6[strlen(rbx_6)];
                uint64_t rdx_12 = data_193d8;
                void* enc_tab_1 = enc_tab;
                uint64_t rsi_16 = data_193f8;
                char const (* rcx_13)[0x3] = data_193f0;
                uint64_t rcx_14 = data_19418;
                void* rdi_42 = data_19410;
                uint64_t var_11a8_1 = rcx_14;
                int64_t rbp_6 = !(rdx_12);
                int32_t var_11d8_1 = 0;
                int64_t i_2 = 1;
                char const* const var_11a0_1 = "text/plain; charset=%s";
                char* var_11e8_2;
                char* rdi_44;
                
                while (true)
                {
                    void* r12_2 = rax_56;
                    int64_t r15_4 = 0;
                    char* rax_58;
                    
                    do
                    {
                        rax_58 = ((r12_2 + r15_4) - 1);
                        
                        if (rax_58 < rbx_6)
                            goto label_d326;
                        
                        r15_4 -= 1;
                    } while (*rax_58 != 0x2e);
                    rdi_44 = ((r12_2 + r15_4) + 1);
                    var_11e8_2 = rdi_44;
                    int32_t rax_59;
                    
                    if (rbp_6 == r15_4)
                    {
                        rax_59 = strncasecmp(var_11e8_2, enc_tab_1, rdx_12);
                        rdi_44 = var_11e8_2;
                    }
                    
                    int32_t rcx_16;
                    
                    if ((rbp_6 == r15_4 && rax_59 == 0))
                        rcx_16 = 0;
                    else
                    {
                        int32_t rax_60;
                        
                        if (!(rsi_16) == r15_4)
                        {
                            rax_60 = strncasecmp(var_11e8_2, rcx_13, rsi_16);
                            rdi_44 = var_11e8_2;
                        }
                        
                        if ((!(rsi_16) == r15_4 && rax_60 == 0))
                            rcx_16 = 1;
                        else
                        {
                            if (!(rcx_14) != r15_4)
                            {
                                var_11a8_1 = !(r15_4);
                                break;
                            }
                            
                            rcx_16 = 2;
                            
                            if (strncasecmp(rdi_44, rdi_42, var_11a8_1) != 0)
                                break;
                        }
                    }
                    
                    rax_56 = (r12_2 + r15_4);
                    
                    if (var_11d8_1 <= 0x63)
                    {
                        *(&var_1038 + (var_11d8_1 << 2)) = rcx_16;
                        var_11d8_1 += 1;
                        i_2 += 1;
                        rax_56 = (r12_2 + r15_4);
                    }
                }
                
                int32_t r12_5 = 0xc0;
                int32_t r15_6 = 0;
                
                do
                {
                    int32_t rax_97 = (r12_5 + r15_6);
                    int32_t rbx_13 = (((rax_97 >> 0x1f) + rax_97) >> 1);
                    int64_t rbp_9 = (rbx_13 << 5);
                    int32_t rax_98 = strncasecmp(rdi_44, *(rbp_9 + &typ_tab), var_11a8_1);
                    
                    if (rax_98 < 0)
                    {
                        r12_5 = (rbx_13 - 1);
                        rdi_44 = var_11e8_2;
                    }
                    else
                    {
                        rdi_44 = var_11e8_2;
                        
                        if (rax_98 != 0)
                            r15_6 = (rbx_13 + 1);
                        else
                        {
                            int64_t temp3_1 = *(rbp_9 + 0x19438);
                            
                            if (var_11a8_1 >= temp3_1)
                            {
                                if (var_11a8_1 <= temp3_1)
                                {
                                    var_11a0_1 = *(rbp_9 + &data_19440);
                                    break;
                                }
                                
                                r15_6 = (rbx_13 + 1);
                            }
                            else
                                r12_5 = (rbx_13 - 1);
                        }
                    }
                } while (r12_5 >= r15_6);
                
            label_d326:
                *(arg1 + 0x1f8) = var_11a0_1;
                **(arg1 + 0xf8) = 0;
                
                if (var_11d8_1 != 0)
                {
                    int64_t r12_6 = 0;
                    
                    do
                    {
                        int64_t r15_8 = (*(&var_1038 + ((i_2 - 2) << 2)) << 5);
                        int64_t rbp_10 = (r12_6 + 1);
                        httpd_realloc_str((arg1 + 0xf8), (arg1 + 0x190), (*(r15_8 + &data_193e8) + rbp_10));
                        char* rdi_61 = *(arg1 + 0xf8);
                        
                        if (*rdi_61 != 0)
                        {
                            *(rdi_61 + r12_6) = 0x2c;
                            rdi_61 = *(arg1 + 0xf8);
                        }
                        else
                            rbp_10 = r12_6;
                        
                        strcpy(&rdi_61[rbp_10], *(r15_8 + &data_193e0));
                        i_2 -= 1;
                        r12_6 = (rbp_10 + *(r15_8 + &data_193e8));
                    } while (i_2 > 1);
                }
                
                rbx_2 = arg1;
                
                if (*(rbx_2 + 0xb4) == 2)
                {
                label_d41d:
                    rcx_5 = *(rbx_2 + 0xf8);
                    r9_2 = *(rbx_2 + 0x1f8);
                    rdx_4 = &data_15488;
                    rdi_20 = rbx_2;
                    rsi_8 = 0xc8;
                    var_11f0_1 = *(rbx_2 + 0x288);
                    var_11f8_1 = *(rbx_2 + 0x260);
                    goto label_d44d;
                }
                
                int64_t rcx_37 = *(rbx_2 + 0x1e0);
                time_t rax_106;
                
                if (rcx_37 != -1)
                    rax_106 = *(rbx_2 + 0x288);
                
                if ((rcx_37 == -1 || rcx_37 < rax_106))
                {
                    int64_t rax_107 = mmc_map(*(rbx_2 + 0xf0), rsi, arg2);
                    *(rbx_2 + 0x2c8) = rax_107;
                    
                    if (rax_107 == 0)
                        goto label_d45d;
                    
                    goto label_d41d;
                }
                
                rcx_5 = *(rbx_2 + 0xf8);
                r9_2 = *(rbx_2 + 0x1f8);
                rdx_4 = "Not Modified";
                rdi_20 = rbx_2;
                rsi_8 = 0x130;
                var_11f0_1 = rax_106;
                var_11f8_1 = -1;
                goto label_d44d;
            }
            
            void* rax_43 = *(arg1 + 8);
            int32_t rdx_9 = *(rax_43 + 0x20);
            int32_t rcx_7 = *(rax_43 + 0x24);
            
            if ((rdx_9 != 0 && rcx_7 >= rdx_9))
            {
                httpd_send_err(arg1, 0x1f7, httpd_err503title, &data_13553, httpd_err503form, *(arg1 + 0xd0));
                return rbp_2;
            }
            
            *(rax_43 + 0x24) = (rcx_7 + 1);
            int32_t rbx_7 = *(arg1 + 0x2c0);
            int32_t rax_72 = fcntl(rbx_7, 3, 0);
            
            if (rax_72 != 0xffffffff)
            {
                int32_t rdx_23 = (rax_72 & 0xfffff7ff);
                
                if (rdx_23 != rax_72)
                    fcntl(rbx_7, 4, rdx_23);
            }
            
            pid_t rax_74 = fork();
            
            if (rax_74 < 0)
            {
                syslog(3, "fork - %m");
                httpd_send_err(arg1, 0x1f4, "Internal Error", &data_13553, "There was an unusual problem serâ€¦", *(arg1 + 0xd0));
                return rbp_2;
            }
            
            if (rax_74 != 0)
            {
                syslog(7, "spawned CGI process %d for file â€¦", rax_74, *r14_1);
                
                if (tmr_create(nullptr, cgi_kill, rax_74, 0x7530, 0) == 0)
                {
                    fmt = "tmr_create(cgi_kill child) faileâ€¦";
                label_d663:
                    pri = 2;
                label_d66a:
                    syslog(pri, fmt);
                    exit(1);
                    /* no return */
                }
                
                *(arg1 + 0xb8) = 0xc8;
                *(arg1 + 0xc8) = 0x61a8;
                *(arg1 + 0x22c) = 0;
                return 0;
            }
            
            sub_process = 1;
            void* rbx_16 = *(arg1 + 8);
            int32_t fd_1 = *(rbx_16 + 0x48);
            
            if (fd_1 != 0xffffffff)
            {
                close(fd_1);
                *(rbx_16 + 0x48) = 0xffffffff;
            }
            
            int32_t fd_2 = *(rbx_16 + 0x4c);
            
            if (fd_2 != 0xffffffff)
            {
                close(fd_2);
                *(rbx_16 + 0x4c) = 0xffffffff;
            }
            
            fcntl(*(arg1 + 0x2c0), 2, 0);
            closelog();
            int32_t rdi_66 = *(arg1 + 0x2c0);
            
            if (rdi_66 <= 2)
            {
                int32_t rax_109 = dup2(rdi_66, 3);
                
                if (rax_109 >= 0)
                    *(arg1 + 0x2c0) = rax_109;
            }
            
            make_envp.envp = build_env("PATH=%s", "/usr/local/bin:/usr/ucb:/bin:/usâ€¦");
            data_1b308 = build_env("SERVER_SOFTWARE=%s", "thttpd/2.29 23May2018");
            void* rax_113 = *(arg1 + 8);
            char* rsi_27;
            
            if (*(rax_113 + 0x64) != 0)
                rsi_27 = *(arg1 + 0x200);
            
            int32_t r12_9;
            
            if (((*(rax_113 + 0x64) == 0 || rsi_27 == 0) || *rsi_27 == 0))
            {
                rsi_27 = *(arg1 + 0x150);
                
                if ((rsi_27 == 0 || *rsi_27 == 0))
                {
                    rsi_27 = *(arg1 + 0x148);
                    
                    if ((rsi_27 == 0 || *rsi_27 == 0))
                    {
                        rsi_27 = *(rax_113 + 8);
                        r12_9 = 2;
                        
                        if (rsi_27 != 0)
                        {
                            data_1b310 = build_env("SERVER_NAME=%s", rsi_27);
                            r12_9 = 3;
                        }
                    }
                    else
                    {
                        data_1b310 = build_env("SERVER_NAME=%s", rsi_27);
                        r12_9 = 3;
                    }
                }
                else
                {
                    data_1b310 = build_env("SERVER_NAME=%s", rsi_27);
                    r12_9 = 3;
                }
            }
            else
            {
                data_1b310 = build_env("SERVER_NAME=%s", rsi_27);
                r12_9 = 3;
            }
            
            uint64_t rbp_12 = r12_9;
            &make_envp.envp[rbp_12] = "GATEWAY_INTERFACE=CGI/1.1";
            &data_1b308[rbp_12] = build_env("SERVER_PROTOCOL=%s", *(arg1 + 0xe0));
            *(*(arg1 + 8) + 0x10);
            my_snprintf(&var_1038, 0x100, "%d", 0);
            &data_1b310[rbp_12] = build_env("SERVER_PORT=%s", &var_1038);
            int32_t rax_119 = (*(arg1 + 0xb4) - 1);
            char* rsi_30;
            
            if (rax_119 > 5)
                rsi_30 = "UNKNOWN";
            else
                rsi_30 = &data_18da0[rax_119];
            
            int32_t rbp_13 = (r12_9 + 4);
            &make_envp.envp[(r12_9 + 3)] = build_env("REQUEST_METHOD=%s", rsi_30);
            char* rsi_31 = *(arg1 + 0x100);
            
            if (*rsi_31 != 0)
            {
                var_11e0 = (r12_9 + 5);
                &make_envp.envp[rbp_13] = build_env("PATH_INFO=/%s", rsi_31);
                size_t n_1 = ((strlen(*(*(arg1 + 8) + 0x40)) + strlen(*(arg1 + 0x100))) + 1);
                char* rax_128 = malloc(n_1);
                
                if (rax_128 != 0)
                {
                    my_snprintf(rax_128, n_1, "%s%s", 0);
                    &make_envp.envp[var_11e0] = build_env("PATH_TRANSLATED=%s", rax_128);
                    rbp_13 = (r12_9 + 6);
                }
                else
                    rbp_13 = var_11e0;
            }
            
            void* rbx_21 = *(arg1 + 0xe8);
            void* const rsi_34 = &data_13553;
            
            if (strcmp(rbx_21, &data_13c3c) != 0)
                rsi_34 = rbx_21;
            
            int32_t rbx_22 = (rbp_13 + 1);
            &make_envp.envp[rbp_13] = build_env("SCRIPT_NAME=/%s", rsi_34);
            char* rsi_35 = *(arg1 + 0x108);
            
            if (*rsi_35 != 0)
            {
                &make_envp.envp[rbx_22] = build_env("QUERY_STRING=%s", rsi_35);
                rbx_22 = (rbp_13 + 2);
            }
            
            int16_t rax_135 = *(arg1 + 0x10);
            socklen_t addrlen_13 = 0x1c;
            
            if (rax_135 != 0xa)
                addrlen_13 = 0;
            
            socklen_t addrlen_6 = 0x10;
            
            if (rax_135 != 2)
                addrlen_6 = addrlen_13;
            
            if (getnameinfo((arg1 + 0x10), addrlen_6, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                httpd_ntoa.str = 0x3f;
            else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
            
            int32_t rbp_16 = (rbx_22 + 1);
            &make_envp.envp[rbx_22] = build_env("REMOTE_ADDR=%s", &httpd_ntoa.str);
            char* rsi_36 = *(arg1 + 0x110);
            
            if (*rsi_36 != 0)
            {
                &make_envp.envp[rbp_16] = build_env("HTTP_REFERER=%s", rsi_36);
                &make_envp.envp[(rbx_22 + 2)] = build_env("HTTP_REFERRER=%s", *(arg1 + 0x110));
                rbp_16 = (rbx_22 + 3);
            }
            
            char* rsi_38 = *(arg1 + 0x118);
            
            if (*rsi_38 != 0)
            {
                uint64_t rcx_54 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_54] = build_env("HTTP_USER_AGENT=%s", rsi_38);
            }
            
            char* rsi_39 = *(arg1 + 0x120);
            
            if (*rsi_39 != 0)
            {
                uint64_t rcx_55 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_55] = build_env("HTTP_ACCEPT=%s", rsi_39);
            }
            
            char* rsi_40 = *(arg1 + 0x128);
            
            if (*rsi_40 != 0)
            {
                uint64_t rcx_56 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_56] = build_env("HTTP_ACCEPT_ENCODING=%s", rsi_40);
            }
            
            char* rsi_41 = *(arg1 + 0x130);
            
            if (*rsi_41 != 0)
            {
                uint64_t rcx_57 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_57] = build_env("HTTP_ACCEPT_LANGUAGE=%s", rsi_41);
            }
            
            char* rsi_42 = *(arg1 + 0x138);
            
            if (*rsi_42 != 0)
            {
                uint64_t rcx_58 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_58] = build_env("HTTP_COOKIE=%s", rsi_42);
            }
            
            char* rsi_43 = *(arg1 + 0x140);
            
            if (*rsi_43 != 0)
            {
                uint64_t rcx_59 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_59] = build_env("CONTENT_TYPE=%s", rsi_43);
            }
            
            char* rsi_44 = *(arg1 + 0x150);
            
            if (*rsi_44 != 0)
            {
                uint64_t rcx_60 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_60] = build_env("HTTP_HOST=%s", rsi_44);
            }
            
            if (*(arg1 + 0x1f0) != -1)
            {
                my_snprintf(&var_1038, 0x100, &data_153b4, 0);
                uint64_t rcx_62 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_62] = build_env("CONTENT_LENGTH=%s", &var_1038);
            }
            
            char* rsi_46 = *(arg1 + 0x168);
            
            if (*rsi_46 != 0)
            {
                uint64_t rcx_63 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_63] = build_env("REMOTE_USER=%s", rsi_46);
            }
            
            if (**(arg1 + 0x160) != 0)
            {
                uint64_t rcx_64 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_64] = build_env("AUTH_TYPE=%s", "Basic");
            }
            
            char* rax_168 = getenv(&data_153ec);
            
            if (rax_168 != 0)
            {
                uint64_t rcx_65 = rbp_16;
                rbp_16 += 1;
                &make_envp.envp[rcx_65] = build_env("TZ=%s", rax_168);
            }
            
            &make_envp.envp[rbp_16] = build_env("CGI_PATTERN=%s", *(*(arg1 + 8) + 0x18));
            &make_envp.envp[(rbp_16 + 1)] = 0;
            char* r15_10 = *(arg1 + 0x108);
            int64_t* rax_173 = malloc(&&nullptr->type[(strlen(r15_10) * 4)]);
            int64_t* var_11e0_1 = rax_173;
            
            if (rax_173 != 0)
            {
                void* r14_6 = *r14_1;
                char* rax_175 = strrchr(r14_6, 0x2f);
                void* rcx_67 = &rax_175[1];
                
                if (rax_175 == 0)
                    rcx_67 = r14_6;
                
                *var_11e0_1 = rcx_67;
                int32_t r14_7 = 1;
                
                if (strchr(r15_10, 0x3d) == 0)
                {
                    r14_7 = 1;
                    char* rbp_18 = r15_10;
                    
                    while (true)
                    {
                        char* rax_177;
                        rax_177 = *rbp_18;
                        
                        if (rax_177 == 0x2b)
                        {
                            *rbp_18 = 0;
                            char* rbx_25 = r15_10;
                            char* r13_3 = r15_10;
                            
                            while (true)
                            {
                                char rdx_37 = *r13_3;
                                
                                if (rdx_37 == 0x25)
                                {
                                    uint16_t* rcx_69 = *__ctype_b_loc();
                                    int64_t rsi_49 = r13_3[1];
                                    rdx_37 = 0x25;
                                    
                                    if ((*(&rcx_69[rsi_49] + 1) & 0x10) != 0)
                                    {
                                        int64_t rax_179 = r13_3[2];
                                        
                                        if ((*(&rcx_69[rax_179] + 1) & 0x10) != 0)
                                        {
                                            char rcx_70 = (rsi_49 - 0x30);
                                            
                                            if (rcx_70 >= 0xa)
                                            {
                                                if ((rsi_49 - 0x61) > 5)
                                                {
                                                    char rcx_72 = (rsi_49 - 0x41);
                                                    rsi_49 -= 0x37;
                                                    rcx_70 = rsi_49;
                                                    
                                                    if (rcx_72 >= 6)
                                                        rcx_70 = 0;
                                                }
                                                else
                                                {
                                                    rsi_49 -= 0x57;
                                                    rcx_70 = rsi_49;
                                                }
                                            }
                                            
                                            rdx_37 = (rax_179 - 0x30);
                                            
                                            if (rdx_37 >= 0xa)
                                            {
                                                if ((rax_179 - 0x61) > 5)
                                                {
                                                    char rdx_39 = (rax_179 - 0x41);
                                                    rax_179 -= 0x37;
                                                    rdx_37 = rax_179;
                                                    
                                                    if (rdx_39 >= 6)
                                                        rdx_37 = 0;
                                                }
                                                else
                                                {
                                                    rax_179 -= 0x57;
                                                    rdx_37 = rax_179;
                                                }
                                            }
                                            
                                            rdx_37 += (rcx_70 << 4);
                                            r13_3 = &r13_3[2];
                                        }
                                    }
                                }
                                else if (rdx_37 == 0)
                                    break;
                                
                                *rbx_25 = rdx_37;
                                rbx_25 = &rbx_25[1];
                                r13_3 = &r13_3[1];
                            }
                            
                            *rbx_25 = 0;
                            rax_177 = r14_7;
                            r14_7 += 1;
                            var_11e0_1[rax_177] = r15_10;
                            r15_10 = &rbp_18[1];
                        }
                        else if (rax_177 == 0)
                            break;
                        
                        rbp_18 = &rbp_18[1];
                    }
                    
                    if (rbp_18 != r15_10)
                    {
                        char* rbx_26 = r15_10;
                        char* rbp_19 = r15_10;
                        
                        while (true)
                        {
                            char rdx_40 = *rbp_19;
                            
                            if (rdx_40 == 0x25)
                            {
                                uint16_t* rcx_73 = *__ctype_b_loc();
                                int64_t rsi_50 = rbp_19[1];
                                rdx_40 = 0x25;
                                
                                if ((*(&rcx_73[rsi_50] + 1) & 0x10) != 0)
                                {
                                    int64_t rax_181 = rbp_19[2];
                                    
                                    if ((*(&rcx_73[rax_181] + 1) & 0x10) != 0)
                                    {
                                        char rcx_74 = (rsi_50 - 0x30);
                                        
                                        if (rcx_74 >= 0xa)
                                        {
                                            if ((rsi_50 - 0x61) > 5)
                                            {
                                                char rcx_76 = (rsi_50 - 0x41);
                                                rsi_50 -= 0x37;
                                                rcx_74 = rsi_50;
                                                
                                                if (rcx_76 >= 6)
                                                    rcx_74 = 0;
                                            }
                                            else
                                            {
                                                rsi_50 -= 0x57;
                                                rcx_74 = rsi_50;
                                            }
                                        }
                                        
                                        rdx_40 = (rax_181 - 0x30);
                                        
                                        if (rdx_40 >= 0xa)
                                        {
                                            if ((rax_181 - 0x61) > 5)
                                            {
                                                char rdx_42 = (rax_181 - 0x41);
                                                rax_181 -= 0x37;
                                                rdx_40 = rax_181;
                                                
                                                if (rdx_42 >= 6)
                                                    rdx_40 = 0;
                                            }
                                            else
                                            {
                                                rax_181 -= 0x57;
                                                rdx_40 = rax_181;
                                            }
                                        }
                                        
                                        rdx_40 += (rcx_74 << 4);
                                        rbp_19 = &rbp_19[2];
                                    }
                                }
                            }
                            else if (rdx_40 == 0)
                                break;
                            
                            *rbx_26 = rdx_40;
                            rbx_26 = &rbx_26[1];
                            rbp_19 = &rbp_19[1];
                        }
                        
                        *rbx_26 = 0;
                        int64_t rax_182 = r14_7;
                        r14_7 += 1;
                        var_11e0_1[rax_182] = r15_10;
                    }
                }
                
                var_11e0_1[r14_7] = 0;
            }
            else
                var_11e0_1 = nullptr;
            
            char const* const fmt_1;
            int32_t fd;
            
            if ((*(arg1 + 0xb4) != 3 || *(arg1 + 0xa0) <= *(arg1 + 0xa8)))
            {
                int32_t rdi_82 = *(arg1 + 0x2c0);
                
                if (rdi_82 != 0)
                    dup2(rdi_82, 0);
                
            label_ddef:
                
                if ((strncmp(*var_11e0_1, "nph-", 4) == 0 || *(arg1 + 0x208) == 0))
                {
                    int32_t rax_193 = *(arg1 + 0x2c0);
                    int32_t rdi_84 = 1;
                    
                    if (rax_193 != 1)
                    {
                        dup2(rax_193, 1);
                        rdi_84 = *(arg1 + 0x2c0);
                    }
                    
                    if ((rax_193 == 1 || rdi_84 != 2))
                        dup2(rdi_84, 2);
                    
                label_de47:
                    nice(0xa);
                    void* s = *r14_1;
                    char* rax_196 = strdup(s);
                    
                    if (rax_196 != 0)
                    {
                        char* rax_197 = strrchr(rax_196, 0x2f);
                        
                        if (rax_197 != 0)
                        {
                            s = &rax_197[1];
                            *rax_197 = 0;
                            chdir(rax_196);
                        }
                    }
                    
                    sigset(0xd, nullptr);
                    execve(s, var_11e0_1, &make_envp.envp);
                    syslog(3, "execve %.80s - %m", *(arg1 + 0xf0));
                    httpd_send_err(arg1, 0x1f4, "Internal Error", &data_13553, "There was an unusual problem serâ€¦", *(arg1 + 0xd0));
                    httpd_write_response(arg1);
                    _exit(1);
                    /* no return */
                }
                
                if (pipe(&var_1038) >= 0)
                {
                    pid_t rax_203 = fork();
                    
                    if (rax_203 >= 0)
                    {
                        if (rax_203 == 0)
                        {
                            sub_process = 1;
                            close(fd);
                            cgi_interpose_output(arg1, var_1038);
                            exit(0);
                            /* no return */
                        }
                        
                        close(var_1038);
                        int32_t fd_5 = 1;
                        
                        if (fd == 1)
                        {
                        label_e36a:
                            dup2(fd_5, 2);
                            
                            if ((fd - 3) <= 0xfffffffd)
                                close(fd);
                        }
                        else
                        {
                            dup2(fd, 1);
                            fd_5 = fd;
                            
                            if (fd_5 != 2)
                                goto label_e36a;
                        }
                        
                        goto label_de47;
                    }
                    
                    fmt_1 = "fork - %m";
                }
                else
                    fmt_1 = "pipe - %m";
            }
            else if (pipe(&var_1038) < 0)
                fmt_1 = "pipe - %m";
            else
            {
                pid_t rax_187 = fork();
                
                if (rax_187 >= 0)
                {
                    if (rax_187 == 0)
                    {
                        sub_process = 1;
                        close(var_1038);
                        cgi_interpose_input(arg1, fd);
                        exit(0);
                        /* no return */
                    }
                    
                    close(fd);
                    int32_t rdi_109 = var_1038;
                    
                    if (rdi_109 != 0)
                    {
                        dup2(rdi_109, 0);
                        close(var_1038);
                    }
                    
                    goto label_ddef;
                }
                
                fmt_1 = "fork - %m";
            }
            syslog(3, fmt_1);
            httpd_send_err(arg1, 0x1f4, "Internal Error", &data_13553, "There was an unusual problem serâ€¦", *(arg1 + 0xd0));
            httpd_write_response(arg1);
            exit(1);
            /* no return */
        }
        
        if (strcmp(*r14_1, ".htpasswd") != 0)
            goto label_c8b7;
        
    label_c839:
        int16_t rax_37 = *(arg1 + 0x10);
        socklen_t addrlen_9 = 0x1c;
        
        if (rax_37 != 0xa)
            addrlen_9 = 0;
        
        socklen_t addrlen_2 = 0x10;
        
        if (rax_37 != 2)
            addrlen_2 = addrlen_9;
        
        if (getnameinfo((arg1 + 0x10), addrlen_2, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
            httpd_ntoa.str = 0x3f;
        else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
            memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
        
        syslog(5, "%.80s URL "%.80s" tried to retriâ€¦", &httpd_ntoa.str, *(arg1 + 0xd0));
        r9_1 = *(arg1 + 0xd0);
        httpd_err503title_1 = "Forbidden";
        httpd_err503form_1 = "The requested URL '%.80s' is an â€¦";
    }
    
label_c3e4:
    rdi_2 = arg1;
    rsi_1 = 0x193;
    goto label_c5cc;
}

uint64_t httpd_read_fully(int32_t arg1, int64_t arg2, int64_t arg3)
{
    int32_t rbp;
    
    if (arg3 == 0)
        rbp = 0;
    else
    {
        int64_t rax_1 = 0;
        rbp = 0;
        
        do
        {
            int32_t rax_2 = read(arg1, (arg2 + rax_1), (arg3 - rax_1));
            
            if (rax_2 < 0)
            {
                int32_t rax_4 = *__errno_location();
                
                if ((rax_4 != 0xb && rax_4 != 4))
                {
                    rbp = rax_2;
                    break;
                }
                
                sleep(1);
            }
            else
            {
                rbp += rax_2;
                
                if (rax_2 == 0)
                    break;
            }
            
            rax_1 = rbp;
        } while (rax_1 < arg3);
    }
    
    return rbp;
}

void httpd_logstats()
{
    uint32_t str_alloc_count_1 = str_alloc_count;
    
    if (str_alloc_count_1 <= 0)
        return;
    
    uint64_t str_alloc_size_1 = str_alloc_size;
    float zmm0;
    
    if (str_alloc_size_1 < 0)
    {
        zmm0 = ((str_alloc_size_1 & 1) | (str_alloc_size_1 >> 1));
        zmm0 = (zmm0 + zmm0);
    }
    else
        zmm0 = str_alloc_size_1;
    
    uint64_t rax;
    rax = 1;
    /* tailcall */
    return syslog(5, "  libhttpd - %d strings allocateâ€¦", (zmm0 / str_alloc_count_1));
}

void send_mime(void* arg1, int32_t arg2, char* arg3, char* arg4, char* arg5, char* arg6, int64_t arg7, time_t arg8)
{
    int32_t r14 = arg2;
    time_t rbp = arg8;
    *(arg1 + 0xb8) = r14;
    *(arg1 + 0xc0) = arg7;
    
    if (*(arg1 + 0x208) != 0)
    {
        char var_794_1;
        char const* const var_790_1;
        int16_t* rax;
        
        if ((r14 != 0xc8 || *(arg1 + 0x210) == 0))
        {
        label_e9fe:
            var_790_1 = arg3;
            *(arg1 + 0x210) = 0;
            rax = 1;
            var_794_1 = rax;
        }
        else
        {
            rax = *(arg1 + 0x218);
            int64_t rcx = *(arg1 + 0x220);
            
            if ((rcx < rax || (rcx == (arg7 - 1) && rax == 0)))
                goto label_e9fe;
            
            rax = *(arg1 + 0x1e8);
            
            if ((rax != -1 && rax != *(arg1 + 0x288)))
                goto label_e9fe;
            
            *(arg1 + 0xb8) = 0xce;
            r14 = 0xce;
            var_790_1 = "Partial Content";
            var_794_1 = 0;
        }
        time_t t_2 = time(nullptr);
        time_t t = t_2;
        
        if (rbp == 0)
            arg8 = t_2;
        
        void s;
        strftime(&s, 0x64, "%a, %d %b %Y %H:%M:%S GMT", gmtime(&t));
        void s_2;
        strftime(&s_2, 0x64, "%a, %d %b %Y %H:%M:%S GMT", gmtime(&arg8));
        *(*(arg1 + 8) + 0x28);
        void var_228;
        my_snprintf(&var_228, 0x1f4, arg6, 0);
        *(arg1 + 0xe0);
        void* var_7a0_1 = &s_2;
        void* var_7a8_1 = &s;
        void* var_7b0_1 = &var_228;
        char const* const var_7b8_1 = "thttpd/2.29 23May2018";
        void var_618;
        my_snprintf(&var_618, 0x3e8, "%.20s %d %s\r\nServer: %s\r\nConâ€¦", 0);
        uint64_t rax_4 = strlen(&var_618);
        httpd_realloc_str((arg1 + 0x170), (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_4));
        memmove((*(arg1 + 0x170) + *(arg1 + 0x1d8)), &var_618, rax_4);
        int64_t r13_2 = (rax_4 + *(arg1 + 0x1d8));
        *(arg1 + 0x1d8) = r13_2;
        void* r14_2 = (arg1 + 0x170);
        
        if ((r14 - 0x190) <= 0xffffff37)
        {
            my_snprintf(&var_618, 0x3e8, "Cache-Control: no-cache,no-storeâ€¦", 0);
            uint64_t rax_5 = strlen(&var_618);
            httpd_realloc_str(r14_2, (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_5));
            memmove((*r14_2 + *(arg1 + 0x1d8)), &var_618, rax_5);
            r13_2 = (rax_5 + *(arg1 + 0x1d8));
            *(arg1 + 0x1d8) = r13_2;
        }
        
        if (*arg4 != 0)
        {
            my_snprintf(&var_618, 0x3e8, "Content-Encoding: %s\r\n", 0);
            uint64_t rax_6 = strlen(&var_618);
            httpd_realloc_str(r14_2, (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_6));
            memmove((*r14_2 + *(arg1 + 0x1d8)), &var_618, rax_6);
            r13_2 = (rax_6 + *(arg1 + 0x1d8));
            *(arg1 + 0x1d8) = r13_2;
        }
        
        if (var_794_1 == 0)
        {
            int64_t var_7a8_2 = ((*(arg1 + 0x220) - *(arg1 + 0x218)) + 1);
            my_snprintf(&var_618, 0x3e8, "Content-Range: bytes %lld-%lld/%â€¦", 0);
        label_ec84:
            uint64_t rax_7 = strlen(&var_618);
            httpd_realloc_str(r14_2, (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_7));
            memmove((*r14_2 + *(arg1 + 0x1d8)), &var_618, rax_7);
            r13_2 = (rax_7 + *(arg1 + 0x1d8));
            *(arg1 + 0x1d8) = r13_2;
        }
        else if (arg7 >= 0)
        {
            my_snprintf(&var_618, 0x3e8, "Content-Length: %lld\r\n", 0);
            goto label_ec84;
        }
        
        void* rax_9 = *(arg1 + 8);
        
        if (**(rax_9 + 0x30) != 0)
        {
            my_snprintf(&var_618, 0x3e8, "P3P: %s\r\n", 0);
            uint64_t rax_8 = strlen(&var_618);
            httpd_realloc_str(r14_2, (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_8));
            memmove((*(arg1 + 0x170) + *(arg1 + 0x1d8)), &var_618, rax_8);
            r13_2 = (rax_8 + *(arg1 + 0x1d8));
            *(arg1 + 0x1d8) = r13_2;
            rax_9 = *(arg1 + 8);
        }
        
        uint64_t rax_10 = *(rax_9 + 0x38);
        
        if (rax_10 >= 0)
        {
            int64_t t_1 = (rax_10 + t);
            void s_1;
            strftime(&s_1, 0x64, "%a, %d %b %Y %H:%M:%S GMT", gmtime(&t_1));
            *(*(arg1 + 8) + 0x38);
            my_snprintf(&var_618, 0x3e8, "Cache-Control: max-age=%d\r\nExpâ€¦", 0);
            uint64_t rax_14 = strlen(&var_618);
            httpd_realloc_str(r14_2, (arg1 + 0x1d0), (*(arg1 + 0x1d8) + rax_14));
            memmove((*(arg1 + 0x170) + *(arg1 + 0x1d8)), &var_618, rax_14);
            r13_2 = (rax_14 + *(arg1 + 0x1d8));
            *(arg1 + 0x1d8) = r13_2;
        }
        
        if (*arg5 != 0)
        {
            uint64_t rax_15 = strlen(arg5);
            httpd_realloc_str(r14_2, (arg1 + 0x1d0), (r13_2 + rax_15));
            memmove((*r14_2 + *(arg1 + 0x1d8)), arg5, rax_15);
            int64_t rbx_3 = (rax_15 + *(arg1 + 0x1d8));
            *(arg1 + 0x1d8) = rbx_3;
            r13_2 = rbx_3;
        }
        
        httpd_realloc_str(r14_2, (arg1 + 0x1d0), (r13_2 + 2));
        *(*r14_2 + *(arg1 + 0x1d8)) = 0xa0d;
        *(arg1 + 0x1d8) += 2;
    }
}

int64_t ext_compare(int64_t* arg1, int64_t* arg2)
{
    /* tailcall */
    return strcmp(*arg1, *arg2);
}

uint64_t check_referrer(void* arg1)
{
    void* r14 = *(arg1 + 8);
    char* rbx = *(r14 + 0x70);
    int32_t rbp = 1;
    
    if (rbx != 0)
    {
        char* rdi = *(arg1 + 0x110);
        char* rax_1;
        
        if ((rdi != 0 && *rdi != 0))
            rax_1 = strstr(rdi, "//");
        
        char* rsi_1;
        char* rdi_1;
        
        if (((rdi != 0 && *rdi != 0) && rax_1 != 0))
        {
            void* i = &rax_1[2];
            int64_t rbp_1 = 2;
            
            while (true)
            {
                uint64_t rcx_1 = rax_1[rbp_1];
                
                if ((rcx_1 <= 0x3a && (TEST_BITQ(0x400800000000001, rcx_1))))
                    break;
                
                rbp_1 += 1;
            }
            
            httpd_realloc_str(&really_check_referrer.refhost, &really_check_referrer.refhost_size, (rbp_1 - 2));
            uint64_t really_check_referrer.refhost_1 = really_check_referrer.refhost;
            
            if (rbp_1 >= 3)
            {
                uint16_t** rax_2 = __ctype_b_loc();
                
                do
                {
                    char rax_3 = *i;
                    int64_t rbp_2 = rax_3;
                    
                    if ((*(&*rax_2[rbp_2] + 1) & 1) != 0)
                        rax_3 = *__ctype_tolower_loc()[rbp_2];
                    
                    *really_check_referrer.refhost_1 = rax_3;
                    i += 1;
                    really_check_referrer.refhost_1 += 1;
                } while (i < &rax_1[rbp_1]);
            }
            
            *really_check_referrer.refhost_1 = 0;
            char* rdi_3 = *(r14 + 0x78);
            rbp = 1;
            
            if (rdi_3 != 0)
            {
            label_f0fb:
                
                if (match(rdi_3, really_check_referrer.refhost) == 0)
                {
                    rdi_1 = *(r14 + 0x70);
                    rsi_1 = *(arg1 + 0xe8);
                    goto label_ef7c;
                }
            }
            else if (*(r14 + 0x64) == 0)
            {
                rdi_3 = *(r14 + 8);
                
                if (rdi_3 != 0)
                    goto label_f0fb;
            }
            else
            {
                rdi_3 = *(arg1 + 0x200);
                
                if (rdi_3 != 0)
                    goto label_f0fb;
            }
        }
        else if (*(r14 + 0x80) != 0)
        {
            rsi_1 = *(arg1 + 0xe8);
            rdi_1 = rbx;
        label_ef7c:
            
            if (match(rdi_1, rsi_1) != 0)
            {
                void* rcx_3 = *(arg1 + 8);
                void* rax_7;
                
                if (*(rcx_3 + 0x64) != 0)
                    rax_7 = *(arg1 + 0x200);
                
                if ((*(rcx_3 + 0x64) == 0 || rax_7 == 0))
                    rax_7 = *(rcx_3 + 8);
                
                void* const r14_1 = &data_13553;
                
                if (rax_7 != 0)
                    r14_1 = rax_7;
                
                int16_t rax_8 = *(arg1 + 0x10);
                socklen_t addrlen_1 = 0x1c;
                
                if (rax_8 != 0xa)
                    addrlen_1 = 0;
                
                socklen_t addrlen = 0x10;
                
                if (rax_8 != 2)
                    addrlen = addrlen_1;
                
                if (getnameinfo((arg1 + 0x10), addrlen, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                    httpd_ntoa.str = 0x3f;
                else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                    memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                
                rbp = 0;
                syslog(6, "%.80s non-local referrer "%.80s%â€¦", &httpd_ntoa.str, r14_1, *(arg1 + 0xd0), *(arg1 + 0x110));
                httpd_send_err(arg1, 0x193, "Forbidden", &data_13553, "You must supply a local referrerâ€¦", *(arg1 + 0xd0));
            }
        }
    }
    
    return rbp;
}

uint64_t auth_check2(void* arg1, char* arg2)
{
    httpd_realloc_str(&auth_check2.authpath, &auth_check2.maxauthpath, (strlen(arg2) + 0xb));
    int32_t rbx = 0;
    my_snprintf(auth_check2.authpath, auth_check2.maxauthpath, "%s/%s", 0);
    void var_4b8;
    
    if (stat(auth_check2.authpath, &var_4b8) >= 0)
    {
        char* rbx_1 = *(arg1 + 0x160);
        
        if (*rbx_1 == 0)
            goto label_f1e9;
        
        if (strncmp(rbx_1, "Basic ", 6) != 0)
            goto label_f1e9;
        
        int32_t rax_2;
        rax_2 = rbx_1[6];
        void var_428;
        int32_t rcx_3;
        
        if (rax_2 == 0)
            rcx_3 = 0;
        else
        {
            void* rbx_2 = &rbx_1[7];
            uint64_t rbp_1 = 0;
            int32_t rsi_3 = 0;
            rcx_3 = 0;
            
            do
            {
                int32_t rdi_7 = *(&b64_decode_table + (rax_2 << 2));
                char rax_12;
                
                if (rdi_7 == 0xffffffff)
                    rdi_7 = rbp_1;
                else
                    switch (rsi_3)
                    {
                        case 0:
                        {
                            rsi_3 = 1;
                            break;
                        }
                        case 1:
                        {
                            rsi_3 = 2;
                            
                            if (rcx_3 <= 0x1f2)
                            {
                                rax_12 = (((rdi_7 >> 4) & 3) + (rbp_1 << 2));
                            label_f2fa:
                                int64_t rbp_3 = rcx_3;
                                rcx_3 += 1;
                                *(&var_428 + rbp_3) = rax_12;
                            }
                            break;
                        }
                        case 2:
                        {
                            rsi_3 = 3;
                            
                            if (rcx_3 <= 0x1f2)
                            {
                                rax_12 = (((rdi_7 >> 2) & 0xf) | (rbp_1 << 4));
                                goto label_f2fa;
                            }
                            break;
                        }
                        case 3:
                        {
                            rsi_3 = 0;
                            
                            if (rcx_3 <= 0x1f2)
                            {
                                int64_t rax_16 = rcx_3;
                                rcx_3 += 1;
                                *(&var_428 + rax_16) = ((rbp_1 << 6) | rdi_7);
                            }
                            break;
                        }
                    }
                rax_2 = *rbx_2;
                rbx_2 += 1;
                rbp_1 = rdi_7;
            } while (rax_2 != 0);
        }
        
        *(&var_428 + rcx_3) = 0;
        char* rax_18 = strchr(&var_428, 0x3a);
        
        if (rax_18 == 0)
            goto label_f1e9;
        
        *rax_18 = 0;
        char* rax_19 = strchr(&rax_18[1], 0x3a);
        
        if (rax_19 != 0)
            *rax_19 = 0;
        
        uint64_t auth_check2.authpath_1 = auth_check2.authpath;
        uint64_t var_460;
        
        if (auth_check2.maxprevauthpath == 0)
        {
        label_f3ce:
            FILE* fp = fopen(auth_check2.authpath_1, &data_1251b);
            void buf;
            
            if (fp == 0)
            {
                int16_t rax_37 = *(arg1 + 0x10);
                socklen_t addrlen_1 = 0x1c;
                
                if (rax_37 != 0xa)
                    addrlen_1 = 0;
                
                socklen_t addrlen = 0x10;
                
                if (rax_37 != 2)
                    addrlen = addrlen_1;
                
                if (getnameinfo((arg1 + 0x10), addrlen, &httpd_ntoa.str, 0xc8, nullptr, 0, 1) != 0)
                    httpd_ntoa.str = 0x3f;
                else if ((*(arg1 + 0x18) == 0 && (*(arg1 + 0x1c) == 0 && (*(arg1 + 0x20) == 0xffff0000 && ((0x3a666666 ^ data_1b113) | (0x66663a3a ^ *httpd_ntoa.str)) == 0))))
                    memmove(&httpd_ntoa.str, &data_1b117, (strlen(&data_1b117) + 1));
                
                syslog(3, "%.80s auth file %.80s could not â€¦", &httpd_ntoa.str, auth_check2.authpath);
                httpd_send_err(arg1, 0x193, "Forbidden", &data_13553, "The requested URL '%.80s' is proâ€¦", *(arg1 + 0xd0));
                rbx = -1;
            }
            else if (fgets(&buf, 0x1f4, fp) == 0)
            {
            label_f57f:
                fclose(fp);
            label_f1e9:
                httpd_realloc_str(&send_authenticate.header, &send_authenticate.maxheader, (strlen(arg2) + 0x23));
                my_snprintf(send_authenticate.header, send_authenticate.maxheader, "%s%s"\r\n", 0);
                httpd_send_err(arg1, 0x191, "Unauthorized", send_authenticate.header, "Authorization required for the Uâ€¦", *(arg1 + 0xd0));
                rbx = -1;
                
                if (*(arg1 + 0xb4) == 3)
                    *(arg1 + 0x22c) = 1;
            }
            else
            {
                char* rax_28;
                
                while (true)
                {
                    int64_t rax_27 = (strlen(&buf) - 1);
                    
                    if (*(&buf + rax_27) == 0xa)
                        *(&buf + rax_27) = 0;
                    
                    rax_28 = strchr(&buf, 0x3a);
                    
                    if (rax_28 != 0)
                    {
                        *rax_28 = 0;
                        
                        if (strcmp(&buf, &var_428) == 0)
                            break;
                    }
                    
                    if (fgets(&buf, 0x1f4, fp) == 0)
                        goto label_f57f;
                }
                
                fclose(fp);
                
                if (strcmp(crypt(&rax_18[1], &rax_28[1]), &rax_28[1]) != 0)
                {
                    send_authenticate(arg1, arg2);
                    rbx = -1;
                }
                else
                {
                    httpd_realloc_str((arg1 + 0x168), (arg1 + 0x1c8), strlen(&buf));
                    strcpy(*(arg1 + 0x168), &buf);
                    httpd_realloc_str(&auth_check2.prevauthpath, &auth_check2.maxprevauthpath, strlen(auth_check2.authpath));
                    strcpy(auth_check2.prevauthpath, auth_check2.authpath);
                    auth_check2.prevmtime = var_460;
                    httpd_realloc_str(&auth_check2.prevuser, &auth_check2.maxprevuser, strlen(&var_428));
                    strcpy(auth_check2.prevuser, &var_428);
                    httpd_realloc_str(&auth_check2.prevcryp, &auth_check2.maxprevcryp, strlen(&rax_28[1]));
                    strcpy(auth_check2.prevcryp, &rax_28[1]);
                    rbx = 1;
                }
            }
        }
        else
        {
            if ((strcmp(auth_check2.authpath_1, auth_check2.prevauthpath) != 0 || var_460 != auth_check2.prevmtime))
                goto label_f3ce;
            
            if (strcmp(&var_428, auth_check2.prevuser) != 0)
                goto label_f3ce;
            
            if (strcmp(crypt(&rax_18[1], auth_check2.prevcryp), auth_check2.prevcryp) == 0)
            {
                httpd_realloc_str((arg1 + 0x168), (arg1 + 0x1c8), strlen(&var_428));
                strcpy(*(arg1 + 0x168), &var_428);
                rbx = 1;
            }
            else
            {
                send_authenticate(arg1, arg2);
                rbx = -1;
            }
        }
    }
    
    return rbx;
}

int64_t send_authenticate(void* arg1, char* arg2)
{
    int64_t rax;
    int64_t var_18 = rax;
    httpd_realloc_str(&send_authenticate.header, &send_authenticate.maxheader, (strlen(arg2) + 0x23));
    my_snprintf(send_authenticate.header, send_authenticate.maxheader, "%s%s"\r\n", 0);
    int64_t result = httpd_send_err(arg1, 0x191, "Unauthorized", send_authenticate.header, "Authorization required for the Uâ€¦", *(arg1 + 0xd0));
    
    if (*(arg1 + 0xb4) == 3)
        *(arg1 + 0x22c) = 1;
    
    return result;
}

int64_t name_compare(int64_t* arg1, int64_t* arg2)
{
    /* tailcall */
    return strcmp(*arg1, *arg2);
}

uint64_t cgi_kill(int64_t arg1, int128_t* arg2)
{
    int64_t rax;
    int64_t var_18 = rax;
    uint64_t result = kill();
    
    if (result == 0)
    {
        syslog(4, "killed CGI process %d", arg1);
        result = tmr_create(arg2, cgi_kill2, arg1, 0x1388, 0);
        
        if (result == 0)
        {
            syslog(2, "tmr_create(cgi_kill2) failed");
            exit(1);
            /* no return */
        }
    }
    
    return result;
}

int64_t cgi_kill2(int32_t arg1)
{
    int32_t result = kill();
    
    if (result == 0)
        /* tailcall */
        return syslog(4, "hard-killed CGI process %d", arg1);
    
    return result;
}

int64_t cgi_interpose_input(void* arg1, int32_t arg2)
{
    int64_t r13 = *(arg1 + 0xa0);
    int64_t r14 = *(arg1 + 0xa8);
    int64_t r13_1 = (r13 - r14);
    int64_t result;
    
    if (r13 != r14)
    {
        int64_t r14_1 = (r14 + *(arg1 + 0x90));
        int64_t result_4 = 0;
        int32_t result_1 = 0;
        
        do
        {
            int32_t result_5 = write(arg2, (r14_1 + result_4), (r13_1 - result_4));
            
            if (result_5 < 0)
            {
                int32_t rax_2 = *__errno_location();
                
                if ((rax_2 != 0xb && rax_2 != 4))
                {
                    result_1 = result_5;
                    break;
                }
                
                sleep(1);
            }
            else
            {
                result_1 += result_5;
                
                if (result_5 == 0)
                    break;
            }
            
            result_4 = result_1;
        } while (r13_1 > result_4);
        
        result = result_1;
        
        if (r13_1 != result)
            return result;
    }
    
    for (int64_t i = *(arg1 + 0x1f0); i > r13_1; i = *(arg1 + 0x1f0))
    {
        uint64_t nbytes = (i - r13_1);
        
        if (nbytes >= 0x400)
            nbytes = 0x400;
        
        void buf_1;
        result = read(*(arg1 + 0x2c0), &buf_1, nbytes);
        
        if (result >= 0)
        {
            if (result == 0)
                return result;
            
            int64_t result_2 = result;
            int64_t result_6 = 0;
            int32_t result_3 = 0;
            
            do
            {
                void var_448;
                int32_t result_7 = write(arg2, ((&var_448 + result_6) + 0x10), (result_2 - result_6));
                
                if (result_7 < 0)
                {
                    int32_t rax_5 = *__errno_location();
                    
                    if ((rax_5 != 0xb && rax_5 != 4))
                    {
                        result_3 = result_7;
                        break;
                    }
                    
                    sleep(1);
                }
                else
                {
                    result_3 += result_7;
                    
                    if (result_7 == 0)
                        break;
                }
                
                result_6 = result_3;
            } while (result_2 > result_6);
            
            result = result_3;
            
            if (result_2 != result)
                return result;
            
            r13_1 += result_2;
        }
        else
        {
            result = *__errno_location();
            
            if ((result != 0xb && result != 4))
                return result;
            
            sleep(1);
        }
    }
    
    if (sub_process == 1)
    {
        int32_t rbp_2 = *(arg1 + 0x2c0);
        int32_t rax_7 = fcntl(rbp_2, 3, 0);
        
        if (rax_7 != 0xffffffff)
        {
            int32_t rdx_6 = (rax_7 | 0x800);
            
            if (rdx_6 != rax_7)
                fcntl(rbp_2, 4, rdx_6);
        }
    }
    
    void buf;
    return read(*(arg1 + 0x2c0), &buf, 2);
}

ssize_t cgi_interpose_output(void* arg1, int32_t arg2)
{
    int32_t rbx = *(arg1 + 0x2c0);
    int32_t rax_1 = fcntl(rbx, 3, 0);
    
    if (rax_1 != 0xffffffff)
    {
        int32_t rdx_2 = (rax_1 & 0xfffff7ff);
        
        if (rdx_2 != rax_1)
            fcntl(rbx, 4, rdx_2);
    }
    
    int64_t var_440 = 0x258;
    char* rax_3 = malloc(0x259);
    char* var_448 = rax_3;
    str_alloc_count += 1;
    str_alloc_size += 0x258;
    
    if (rax_3 == 0)
    {
        syslog(3, "out of memory reallocating a strâ€¦", 0x258);
        exit(1);
        /* no return */
    }
    
    char* r15 = rax_3;
    void* r12 = nullptr;
    void buf;
    ssize_t result_1;
    
    while (true)
    {
        ssize_t result = read(arg2, &buf, 0x400);
        
        if ((result & 0x80000000) != 0)
        {
            int32_t* rax_4 = __errno_location();
            
            do
            {
                result = *rax_4;
                
                if ((result != 0xb && result != 4))
                    goto label_fbd1;
                
                sleep(1);
                result = read(arg2, &buf, 0x400);
            } while ((result & 0x80000000) != 0);
        }
        
        if (result == 0)
        {
        label_fbd1:
            result_1 = (r15 + r12);
            
            if (*r15 != 0)
                break;
        }
        else
        {
            int64_t rbx_1 = result;
            void* r13_1 = (rbx_1 + r12);
            httpd_realloc_str(&var_448, &var_440, r13_1);
            r15 = var_448;
            memcpy((r12 + r15), &buf, rbx_1);
            *(r15 + r13_1) = 0;
            result = strstr(r15, "\r\n\r\n");
            
            if (result == 0)
            {
                result = strstr(r15, &data_15434);
                r12 = r13_1;
                
                if (result == 0)
                    continue;
            }
            
            result_1 = result;
            r12 = r13_1;
            
            if (*r15 != 0)
                break;
        }
        
        return result;
    }
    
    int64_t r13_2 = 0xc8;
    
    if (strncmp(r15, "HTTP/", 5) == 0)
        r13_2 = strtol(&r15[strcspn(r15, &data_13551)], nullptr, 0xa);
    
    char* rax_8 = strstr(r15, "Location:");
    
    if ((rax_8 != 0 && (rax_8 < result_1 && (rax_8 == r15 || rax_8[-1] == 0xa))))
        r13_2 = 0x12e;
    
    char* rax_9 = strstr(r15, "Status:");
    
    if ((rax_9 != 0 && (rax_9 < result_1 && (rax_9 == r15 || rax_9[-1] == 0xa))))
        r13_2 = strtol(&rax_9[(strspn(&rax_9[7], &data_13551) + 7)], nullptr, 0xa);
    
    if (r13_2 > 0x18f)
    {
        if (r13_2 <= 0x1f3)
        {
            uint64_t rax_12 = (r13_2 - 0x190);
            
            if (rax_12 <= 0x33)
                switch (rax_12)
                {
                    case 0:
                    {
                        httpd_err400title;
                        break;
                    }
                    case 8:
                    {
                        httpd_err408title;
                        break;
                    }
                }
        }
        else if ((r13_2 != 0x1f4 && (r13_2 != 0x1f5 && r13_2 == 0x1f7)))
            httpd_err503title;
    }
    
    int32_t r13_3 = 0;
    my_snprintf(&buf, 0x400, "HTTP/1.0 %d %s\r\n", 0);
    int32_t fd = *(arg1 + 0x2c0);
    uint64_t rax_16 = strlen(&buf);
    void var_458;
    
    if (rax_16 != 0)
    {
        int64_t rax_17 = 0;
        
        do
        {
            int32_t rax_18 = write(fd, ((&var_458 + rax_17) + 0x20), (rax_16 - rax_17));
            
            if (rax_18 < 0)
            {
                int32_t rax_20 = *__errno_location();
                
                if ((rax_20 != 0xb && rax_20 != 4))
                    break;
                
                sleep(1);
            }
            else
            {
                if (rax_18 == 0)
                    break;
                
                r13_3 += rax_18;
            }
            
            rax_17 = r13_3;
        } while (rax_16 > rax_17);
        
        fd = *(arg1 + 0x2c0);
    }
    
    if (r12 != 0)
    {
        int64_t rax_22 = 0;
        int32_t rbp_3 = 0;
        
        do
        {
            int32_t rax_23 = write(fd, &r15[rax_22], (r12 - rax_22));
            
            if (rax_23 < 0)
            {
                int32_t rax_25 = *__errno_location();
                
                if ((rax_25 != 0xb && rax_25 != 4))
                    break;
                
                sleep(1);
            }
            else
            {
                if (rax_23 == 0)
                    break;
                
                rbp_3 += rax_23;
            }
            
            rax_22 = rbp_3;
        } while (r12 > rax_22);
    }
    
    while (true)
    {
        ssize_t rax_26 = read(arg2, &buf, 0x400);
        int32_t temp0_1 = rax_26;
        
        if (temp0_1 < 0)
        {
            int32_t rax_35 = *__errno_location();
            
            if ((rax_35 != 0xb && rax_35 != 4))
                break;
            
            sleep(1);
        }
        else
        {
            if (temp0_1 == 0)
                break;
            
            if ((rax_26 << 0x20) == 0)
            {
                if (0 != rax_26)
                    break;
            }
            else
            {
                int32_t fd_1 = *(arg1 + 0x2c0);
                int64_t r15_1 = rax_26;
                int64_t rax_30 = 0;
                int32_t rbx_3 = 0;
                
                do
                {
                    int32_t rax_31 = write(fd_1, ((&var_458 + rax_30) + 0x20), (r15_1 - rax_30));
                    
                    if (rax_31 < 0)
                    {
                        int32_t rax_33 = *__errno_location();
                        
                        if ((rax_33 != 0xb && rax_33 != 4))
                        {
                            rbx_3 = rax_31;
                            break;
                        }
                        
                        sleep(1);
                    }
                    else
                    {
                        rbx_3 += rax_31;
                        
                        if (rax_31 == 0)
                            break;
                    }
                    
                    rax_30 = rbx_3;
                } while (r15_1 > rax_30);
                
                if (rbx_3 != rax_26)
                    break;
            }
        }
    }
    
    /* tailcall */
    return shutdown(*(arg1 + 0x2c0), 1);
}

char* build_env(char* arg1, char* arg2)
{
    uint64_t rax = strlen(arg1);
    uint64_t rax_2 = (strlen(arg2) + rax);
    uint64_t build_env.maxbuf_1 = build_env.maxbuf;
    
    if (rax_2 > build_env.maxbuf_1)
    {
        httpd_realloc_str(&build_env.buf, &build_env.maxbuf, rax_2);
        build_env.maxbuf_1 = build_env.maxbuf;
    }
    
    my_snprintf(build_env.buf, build_env.maxbuf_1, arg1, 0);
    char* result = strdup(build_env.buf);
    
    if (result != 0)
        return result;
    
    syslog(3, "out of memory copying environmenâ€¦");
    exit(1);
    /* no return */
}

uint64_t fdwatch_get_nfiles()
{
    nfiles = getdtablesize();
    int64_t rlimits;
    int32_t rax_1 = getrlimit(RLIMIT_NOFILE, &rlimits);
    int32_t rax_3;
    
    if (rax_1 == 0)
    {
        int64_t rlimits_2 = rlimits;
        nfiles = rlimits_2;
        int64_t rlimits_1;
        
        if (rlimits_1 == -1)
            rlimits = 0x2000;
        else if (rlimits_1 > rlimits_2)
            rlimits = rlimits_1;
        
        rax_3 = setrlimit(RLIMIT_NOFILE, &rlimits);
    }
    
    uint32_t nfiles_1;
    
    if ((rax_1 == 0 && rax_3 == 0))
    {
        nfiles_1 = rlimits;
        nfiles = nfiles_1;
    }
    else
        nfiles_1 = nfiles;
    
    nwatches = 0;
    int64_t nfiles_2 = nfiles_1;
    int64_t n_1 = (nfiles_2 << 2);
    uint64_t rax_4 = malloc(n_1);
    fd_rw = rax_4;
    int64_t n = (nfiles_2 << 3);
    uint64_t rax_5 = malloc(n);
    fd_data = rax_5;
    uint64_t result = 0xffffffff;
    
    if ((rax_4 != 0 && rax_5 != 0))
    {
        uint64_t nfiles_3 = nfiles_1;
        
        if (nfiles_1 > 0)
            memset(rax_4, 0xff, (nfiles_3 << 2));
        
        uint64_t rax_6 = malloc(n);
        pollfds = rax_6;
        uint64_t rax_7 = malloc(n_1);
        poll_fdidx = rax_7;
        uint64_t rax_8 = malloc(n_1);
        poll_rfdidx = rax_8;
        rax_8 = rax_8 == 0;
        rax_8 |= (rax_7 == 0 | rax_6 == 0);
        result = 0xffffffff;
        
        if (rax_8 == 0)
            result = nfiles_1;
        
        if ((rax_8 == 0 && nfiles_1 > 0))
        {
            memset(rax_7, 0xff, (nfiles_3 << 2));
            uint64_t rax_10 = (nfiles_3 & 7);
            int64_t i;
            
            if ((nfiles_3 - 1) >= 7)
            {
                i = 0;
                
                do
                {
                    *(rax_6 + (i << 3)) = 0xffffffff;
                    *((rax_6 + (i << 3)) + 8) = 0xffffffff;
                    *((rax_6 + (i << 3)) + 0x10) = 0xffffffff;
                    *((rax_6 + (i << 3)) + 0x18) = 0xffffffff;
                    *((rax_6 + (i << 3)) + 0x20) = 0xffffffff;
                    *((rax_6 + (i << 3)) + 0x28) = 0xffffffff;
                    *((rax_6 + (i << 3)) + 0x30) = 0xffffffff;
                    *((rax_6 + (i << 3)) + 0x38) = 0xffffffff;
                    i += 8;
                } while ((nfiles_3 & 0xfffffff8) != i);
            }
            else
                i = 0;
            
            if (rax_10 != 0)
            {
                int64_t rdx_4 = 0;
                
                do
                {
                    *((rax_6 + (i << 3)) + (rdx_4 << 3)) = 0xffffffff;
                    rdx_4 += 1;
                } while (rax_10 != rdx_4);
            }
            
            return nfiles_1;
        }
    }
    
    return result;
}

uint64_t fdwatch_add_fd(int32_t arg1, int64_t arg2, int32_t arg3)
{
    if (arg1 >= 0)
    {
        uint32_t nfiles_1 = nfiles;
        
        if (nfiles_1 > arg1)
        {
            uint64_t fd_rw_1 = fd_rw;
            uint64_t rbx_1 = arg1;
            
            if (*(fd_rw_1 + (rbx_1 << 2)) == 0xffffffff)
            {
                uint32_t npoll_fds_1 = npoll_fds;
                
                if (npoll_fds_1 >= nfiles_1)
                {
                    syslog(3, "too many fds in poll_add_fd!");
                    fd_rw_1 = fd_rw;
                }
                else
                {
                    int64_t npoll_fds_2 = npoll_fds_1;
                    uint64_t pollfds_1 = pollfds;
                    *(pollfds_1 + (npoll_fds_2 << 3)) = arg1;
                    int32_t rdx;
                    
                    if (arg3 == 0)
                    {
                        rdx = 1;
                        *((pollfds_1 + (npoll_fds_2 << 3)) + 4) = rdx;
                    }
                    else if (arg3 == 1)
                    {
                        rdx = 4;
                        *((pollfds_1 + (npoll_fds_2 << 3)) + 4) = rdx;
                    }
                    *(poll_fdidx + (rbx_1 << 2)) = npoll_fds_1;
                    npoll_fds = (npoll_fds_1 + 1);
                }
                
                *(fd_rw_1 + (rbx_1 << 2)) = arg3;
                uint64_t fd_data_1 = fd_data;
                *(fd_data_1 + (rbx_1 << 3)) = arg2;
                return fd_data_1;
            }
        }
    }
    
    /* tailcall */
    return syslog(3, "bad fd (%d) passed to fdwatch_adâ€¦", arg1);
}

uint64_t fdwatch_del_fd(int32_t arg1)
{
    if (arg1 >= 0)
    {
        uint32_t nfiles_1 = nfiles;
        
        if (nfiles_1 > arg1)
        {
            uint64_t fd_rw_1 = fd_rw;
            uint64_t rbx_1 = arg1;
            
            if (*(fd_rw_1 + (rbx_1 << 2)) != 0xffffffff)
            {
                uint64_t poll_fdidx_1 = poll_fdidx;
                uint64_t rdx_1 = *(poll_fdidx_1 + (rbx_1 << 2));
                
                if ((rdx_1 < 0 || rdx_1 >= nfiles_1))
                {
                    syslog(3, "bad idx (%d) in poll_del_fd!", rdx_1);
                    fd_rw_1 = fd_rw;
                }
                else
                {
                    int64_t npoll_fds_1 = npoll_fds;
                    npoll_fds = (npoll_fds_1 - 1);
                    uint64_t pollfds_1 = pollfds;
                    int64_t r8_1 = *((pollfds_1 + (npoll_fds_1 << 3)) - 8);
                    *(pollfds_1 + (rdx_1 << 3)) = r8_1;
                    *(poll_fdidx_1 + (r8_1 << 2)) = rdx_1;
                    *((pollfds_1 + (npoll_fds_1 << 3)) - 8) = 0xffffffff;
                    *(poll_fdidx_1 + (rbx_1 << 2)) = 0xffffffff;
                }
                
                *(fd_rw_1 + (rbx_1 << 2)) = 0xffffffff;
                uint64_t fd_data_1 = fd_data;
                *(fd_data_1 + (rbx_1 << 3)) = 0;
                return fd_data_1;
            }
        }
    }
    
    /* tailcall */
    return syslog(3, "bad fd (%d) passed to fdwatch_deâ€¦", arg1);
}

uint64_t fdwatch(int32_t arg1)
{
    int64_t rax;
    int64_t var_8 = rax;
    nwatches += 1;
    int32_t rax_1 = poll(pollfds, npoll_fds, arg1);
    int32_t rcx_1;
    
    if (rax_1 <= 0)
        rcx_1 = rax_1;
    else
    {
        uint64_t npoll_fds_1 = npoll_fds;
        
        if (npoll_fds_1 <= 0)
            rcx_1 = 0;
        else
        {
            uint64_t pollfds_1 = pollfds;
            int64_t rdi_1 = 0;
            uint64_t poll_rfdidx_1 = poll_rfdidx;
            rcx_1 = 0;
            
            while (true)
            {
                if ((*((pollfds_1 + (rdi_1 << 3)) + 6) & 0x3d) != 0)
                {
                    int64_t rsi_1 = rcx_1;
                    rcx_1 += 1;
                    *(poll_rfdidx_1 + (rsi_1 << 2)) = *(pollfds_1 + (rdi_1 << 3));
                    
                    if (rcx_1 == rax_1)
                        break;
                }
                
                rdi_1 += 1;
                
                if (npoll_fds_1 == rdi_1)
                    goto label_10489;
            }
            
            rcx_1 = rax_1;
        }
    }
    
label_10489:
    nreturned = rcx_1;
    next_ridx = 0;
    return rcx_1;
}

uint64_t fdwatch_check_fd(int32_t arg1)
{
    uint64_t rdx = arg1;
    int32_t rbx;
    uint32_t nfiles_1;
    
    if (arg1 < 0)
    {
    label_104f5:
        rbx = 0;
        syslog(3, "bad fd (%d) passed to fdwatch_châ€¦", rdx, nfiles_1);
    }
    else
    {
        nfiles_1 = nfiles;
        
        if (nfiles_1 <= rdx)
            goto label_104f5;
        
        uint64_t rsi_1 = rdx;
        int32_t rax_2 = *(fd_rw + (rsi_1 << 2));
        
        if (rax_2 == 0xffffffff)
            goto label_104f5;
        
        rdx = *(poll_fdidx + (rsi_1 << 2));
        
        if ((rdx < 0 || rdx >= nfiles_1))
        {
            rbx = 0;
            syslog(3, "bad fdidx (%d) in poll_check_fd!", rdx, nfiles_1);
        }
        else
        {
            uint32_t rcx_1 = *((pollfds + (rdx << 3)) + 6);
            rbx = 0;
            
            if ((rcx_1 & 8) == 0)
            {
                if (rax_2 == 1)
                    rbx = (rcx_1 & 0x34);
                else if (rax_2 == 0)
                    rbx = (rcx_1 & 0x31);
            }
        }
    }
    return rbx;
}

int64_t fdwatch_get_next_client_data()
{
    uint64_t next_ridx_1 = next_ridx;
    int64_t result = -1;
    
    if (next_ridx_1 < nreturned)
    {
        next_ridx = (next_ridx_1 + 1);
        uint32_t nfiles_1;
        
        if (next_ridx_1 >= 0)
            nfiles_1 = nfiles;
        
        if ((next_ridx_1 < 0 || nfiles_1 <= next_ridx_1))
        {
            result = 0;
            syslog(3, "bad ridx (%d) in poll_get_fd!");
        }
        else
        {
            uint64_t rax_3 = *(poll_rfdidx + (next_ridx_1 << 2));
            result = 0;
            
            if ((rax_3 >= 0 && rax_3 < nfiles_1))
                return *(fd_data + (rax_3 << 3));
        }
    }
    
    return result;
}

void fdwatch_logstats(int64_t arg1)
{
    if (arg1 > 0)
    {
        int64_t rax;
        rax = 1;
        syslog(5, "  fdwatch - %ld %ss (%g/sec)", (nwatches / arg1));
    }
    
    nwatches = 0;
}

int64_t mmc_map(char* arg1, int64_t arg2, int64_t* arg3)
{
    int64_t result;
    int64_t var_c0;
    
    if (arg2 == 0)
    {
        if (stat(arg1, &var_c0) == 0)
            goto label_1061e;
        
        result = 0;
        syslog(3, "stat - %m");
    }
    else
    {
        memcpy(&var_c0, arg2, 0x90);
    label_1061e:
        time_t rax_1;
        
        if (arg3 == 0)
            rax_1 = time(nullptr);
        else
            rax_1 = *arg3;
        
        uint64_t hash_table_2 = hash_table;
        uint32_t hash_size_1;
        uint32_t hash_mask_2;
        
        if (hash_table_2 == 0)
        {
            hash_size = 0x400;
            hash_mask_2 = 0x3ff;
            hash_size_1 = 0x400;
        label_106b7:
            hash_mask = hash_mask_2;
            uint64_t hash_table_3 = malloc((hash_size_1 << 3));
            hash_table = hash_table_3;
            
            if (hash_table_3 != 0)
            {
                hash_table_2 = hash_table_3;
                
                if (hash_size_1 > 0)
                    memset(hash_table_2, 0, (hash_size_1 << 3));
                
                for (int32_t* maps_1 = maps; maps_1 != 0; maps_1 = *(maps_1 + 0x40))
                {
                    uint64_t rsi_10 = ((((((((*maps_1 ^ 0x2b5a5) * 0x21) ^ maps_1[2]) * 0x21) ^ maps_1[4]) * 0x21) ^ maps_1[6]) & hash_mask_2);
                    uint64_t rdx_2 = rsi_10;
                    uint64_t rdi_6 = rsi_10;
                    
                    if (*(hash_table_2 + (rsi_10 << 3)) != 0)
                    {
                        rdi_6 = rsi_10;
                        
                        do
                        {
                            if (rdi_6 == (((hash_size_1 - 1) + rsi_10) & hash_mask_2))
                                goto label_10775;
                            
                            rdi_6 = ((rdi_6 + 1) & hash_mask_2);
                        } while (*(hash_table_2 + (rdi_6 << 3)) != 0);
                        
                        rdx_2 = rdi_6;
                    }
                    
                    *(hash_table_2 + (rdx_2 << 3)) = maps_1;
                    maps_1[0xe] = rsi_10;
                    maps_1[0xf] = rdi_6;
                }
                
                goto label_10788;
            }
            
        label_10775:
            result = 0;
            syslog(3, "check_hash_size() failure");
        }
        else
        {
            hash_size_1 = hash_size;
            uint64_t map_count_1 = map_count;
            
            if (hash_size_1 < (map_count_1 * 3))
            {
                free(hash_table_2);
                
                do
                    hash_size_1 *= 2;
                 while (hash_size_1 < (map_count_1 * 6));
                
                hash_size = hash_size_1;
                hash_mask_2 = (hash_size_1 - 1);
                goto label_106b7;
            }
            
            hash_mask_2 = hash_mask;
        label_10788:
            int64_t r14_2 = var_c0;
            int64_t var_b8;
            uint64_t len;
            int32_t rcx_11 = ((len ^ ((r14_2 ^ ((var_b8 ^ 0x2b5a5) * 0x21)) * 0x21)) * 0x21);
            int64_t var_58;
            uint64_t rax_12 = ((var_58 ^ rcx_11) & hash_mask_2);
            int64_t* i = *(hash_table_2 + (rax_12 << 3));
            
            if (i != 0)
            {
                rcx_11 = (((rax_12 + hash_size_1) - 1) & hash_mask_2);
                uint64_t rsi_11 = rax_12;
                
                do
                {
                    if ((i[7] == rax_12 && (*i == var_b8 && (i[1] == r14_2 && (i[2] == len && i[3] == var_58)))))
                    {
                        i[4] += 1;
                        i[5] = rax_1;
                        return i[6];
                    }
                    
                    if (rsi_11 == rcx_11)
                        break;
                    
                    rsi_11 = ((rsi_11 + 1) & hash_mask_2);
                    i = *(hash_table_2 + (rsi_11 << 3));
                } while (i != 0);
            }
            
            int32_t fd = open(arg1, 0, i, rcx_11);
            
            if (fd < 0)
            {
                result = 0;
                syslog(3, "open - %m");
            }
            else
            {
                uint64_t free_maps_1 = free_maps;
                int32_t rax_15;
                uint32_t* rcx_14;
                
                if (free_maps_1 == 0)
                {
                    uint64_t free_maps_2 = malloc(0x48);
                    
                    if (free_maps_2 != 0)
                    {
                        free_maps_1 = free_maps_2;
                        rax_15 = 1;
                        rcx_14 = &alloc_count;
                        goto label_108ac;
                    }
                    
                    close(fd);
                    result = 0;
                    syslog(3, "out of memory allocating a Map");
                }
                else
                {
                    free_maps = *(free_maps_1 + 0x40);
                    rax_15 = -1;
                    rcx_14 = &free_count;
                label_108ac:
                    *rcx_14 += rax_15;
                    *free_maps_1 = var_b8;
                    *(free_maps_1 + 8) = r14_2;
                    *(free_maps_1 + 0x10) = len;
                    *(free_maps_1 + 0x18) = var_58;
                    *(free_maps_1 + 0x20) = 1;
                    *(free_maps_1 + 0x28) = rax_1;
                    
                    if (len == 0)
                    {
                        *(free_maps_1 + 0x30) = 1;
                    label_10956:
                        close(fd);
                        int64_t r8_3 = *(free_maps_1 + 0x10);
                        uint32_t hash_mask_1 = hash_mask;
                        uint64_t rcx_23 = ((((r8_3 ^ ((((0x2b5a5 ^ *free_maps_1) * 0x21) ^ *(free_maps_1 + 8)) * 0x21)) * 0x21) ^ *(free_maps_1 + 0x18)) & hash_mask_1);
                        uint64_t hash_table_1 = hash_table;
                        uint64_t rbp_2 = rcx_23;
                        uint64_t rdi_12 = rcx_23;
                        
                        if (*(hash_table_1 + (rcx_23 << 3)) != 0)
                        {
                            rdi_12 = rcx_23;
                            
                            do
                            {
                                if (rdi_12 == (((hash_size + rcx_23) - 1) & hash_mask_1))
                                {
                                    result = 0;
                                    syslog(3, "add_hash() failure");
                                    goto label_10a21;
                                }
                                
                                rdi_12 = (hash_mask_1 & (rdi_12 + 1));
                            } while (*(hash_table_1 + (rdi_12 << 3)) != 0);
                            
                            rbp_2 = rdi_12;
                        }
                        
                        *(hash_table_1 + (rbp_2 << 3)) = free_maps_1;
                        *(free_maps_1 + 0x38) = rcx_23;
                        *(free_maps_1 + 0x3c) = rdi_12;
                        *(free_maps_1 + 0x40) = maps;
                        maps = free_maps_1;
                        map_count += 1;
                        mapped_bytes += r8_3;
                        return *(free_maps_1 + 0x30);
                    }
                    
                    int64_t rax_19 = mmap(nullptr, len, 1, 2, fd, 0);
                    *(free_maps_1 + 0x30) = rax_19;
                    
                    if (rax_19 != -1)
                        goto label_10956;
                    
                    int32_t* rax_20 = __errno_location();
                    int64_t rax_21;
                    
                    if (*rax_20 == 0xc)
                    {
                        panic();
                        rax_21 = mmap(nullptr, len, 1, 2, fd, 0);
                        *(free_maps_1 + 0x30) = rax_21;
                    }
                    
                    if ((*rax_20 == 0xc && rax_21 != -1))
                        goto label_10956;
                    
                    result = 0;
                    syslog(3, "mmap - %m");
                    close(fd);
                label_10a21:
                    free(free_maps_1);
                    alloc_count -= 1;
                }
            }
        }
    }
    return result;
}

uint64_t panic()
{
    uint64_t hash_table_1 = syslog(3, "mmc panic - freeing all unrefereâ€¦");
    uint64_t maps_1 = maps;
    
    if (maps_1 != 0)
    {
        uint64_t* r15_1 = &maps;
        
        do
        {
            if (*(maps_1 + 0x20) != 0)
                r15_1 = (maps_1 + 0x40);
            else
            {
                int64_t rsi_1 = *(maps_1 + 0x10);
                
                if ((rsi_1 != 0 && munmap(*(maps_1 + 0x30), rsi_1) < 0))
                    syslog(3, "munmap - %m");
                
                mapped_bytes -= *(maps_1 + 0x10);
                *r15_1 = *(maps_1 + 0x40);
                map_count -= 1;
                *(maps_1 + 0x40) = free_maps;
                free_count += 1;
                free_maps = maps_1;
                hash_table_1 = hash_table;
                *(hash_table_1 + (*(maps_1 + 0x3c) << 3)) = 0;
            }
            
            maps_1 = *r15_1;
        } while (maps_1 != 0);
    }
    
    return hash_table_1;
}

time_t mmc_unmap(int64_t arg1, int64_t* arg2, int64_t* arg3)
{
    int64_t rax;
    int64_t var_28 = rax;
    int64_t* maps_1;
    uint64_t rsi_2;
    int64_t r8_1;
    int64_t r9_1;
    int64_t r10_1;
    int64_t r11_1;
    uint32_t hash_mask_1;
    uint64_t hash_table_1;
    
    if (arg2 != 0)
    {
        r10_1 = *arg2;
        r11_1 = arg2[1];
        r8_1 = arg2[6];
        r9_1 = arg2[0xd];
        hash_mask_1 = hash_mask;
        rsi_2 = ((r9_1 ^ ((r8_1 ^ ((r10_1 ^ ((r11_1 ^ 0x2b5a5) * 0x21)) * 0x21)) * 0x21)) & hash_mask_1);
        hash_table_1 = hash_table;
        maps_1 = *(hash_table_1 + (rsi_2 << 3));
    }
    
    if ((arg2 != 0 && maps_1 != 0))
    {
        int32_t rax_8 = rsi_2;
        
        while (true)
        {
            if ((maps_1[7] == rsi_2 && (*maps_1 == r11_1 && (maps_1[1] == r10_1 && (maps_1[2] == r8_1 && maps_1[3] == r9_1)))))
            {
                if (maps_1[6] != arg1)
                    goto label_10be7;
                
                break;
            }
            
            if (rax_8 == (((hash_size + rsi_2) - 1) & hash_mask_1))
                goto label_10be7;
            
            uint64_t rcx_11 = (hash_mask_1 & (rax_8 + 1));
            maps_1 = *(hash_table_1 + (rcx_11 << 3));
            rax_8 = rcx_11;
            
            if (maps_1 == 0)
                goto label_10be7;
        }
        
        goto label_10c32;
    }
    
label_10be7:
    maps_1 = maps;
    char const* const rsi_3;
    
    if (maps_1 == 0)
    {
    label_10c0f:
        rsi_3 = "mmc_unmap failed to find entry!";
    }
    else
    {
        while (maps_1[6] != arg1)
        {
            maps_1 = maps_1[8];
            
            if (maps_1 == 0)
                goto label_10c0f;
        }
        
    label_10c32:
        int32_t rax_12 = maps_1[4];
        
        if (rax_12 > 0)
        {
            maps_1[4] = (rax_12 - 1);
            time_t result;
            
            if (arg3 == 0)
                result = time(nullptr);
            else
                result = *arg3;
            
            maps_1[5] = result;
            return result;
        }
        
        rsi_3 = "mmc_unmap found zero or negativeâ€¦";
    }
    
    /* tailcall */
    return syslog(3, rsi_3);
}

uint64_t mmc_cleanup(int64_t* arg1)
{
    time_t r15;
    
    if (arg1 == 0)
        r15 = time(nullptr);
    else
        r15 = *arg1;
    
    uint64_t maps_1 = maps;
    
    if (maps_1 != 0)
    {
        uint64_t* r12_1 = &maps;
        
        do
        {
            if ((*(maps_1 + 0x20) != 0 || (r15 - *(maps_1 + 0x28)) < expire_age))
                r12_1 = (maps_1 + 0x40);
            else
            {
                int64_t rsi_1 = *(maps_1 + 0x10);
                
                if ((rsi_1 != 0 && munmap(*(maps_1 + 0x30), rsi_1) < 0))
                    syslog(3, "munmap - %m");
                
                mapped_bytes -= *(maps_1 + 0x10);
                *r12_1 = *(maps_1 + 0x40);
                map_count -= 1;
                *(maps_1 + 0x40) = free_maps;
                free_count += 1;
                free_maps = maps_1;
                *(hash_table + (*(maps_1 + 0x3c) << 3)) = 0;
            }
            
            maps_1 = *r12_1;
        } while (maps_1 != 0);
    }
    
    uint64_t result;
    
    if (mapped_bytes < 0x3b9aca01)
        result = map_count;
    
    int64_t rcx_2;
    
    if ((mapped_bytes >= 0x3b9aca01 || result >= 0x3e9))
    {
        result = expire_age;
        rcx_2 = 0x3c;
        
        if (result >= 0x5c)
        {
            int64_t rdx_1;
            rdx_1 = HIGHQ(((result * 2) * 0x5555555555555556));
            result = LOWQ(((result * 2) * 0x5555555555555556));
            rcx_2 = ((rdx_1 >> 0x3f) + rdx_1);
        }
        
        expire_age = rcx_2;
    }
    else if (result <= 0x1f3)
    {
        result = (expire_age * 5);
        rcx_2 = 0x708;
        
        if (result <= 0x1c1f)
        {
            uint64_t result_1 = (result + 3);
            
            if (result >= 0)
                result_1 = result;
            
            rcx_2 = (result_1 >> 2);
        }
        
        expire_age = rcx_2;
    }
    uint32_t free_count_1 = free_count;
    
    if (free_count_1 >= 0x65)
    {
        uint64_t free_maps_1 = free_maps;
        int32_t i = (free_count_1 + 1);
        uint32_t rbp_2 = (alloc_count - 1);
        
        do
        {
            uint64_t free_maps_2 = *(free_maps_1 + 0x40);
            free_maps = free_maps_2;
            free_count = (i - 2);
            result = free(free_maps_1);
            alloc_count = rbp_2;
            i -= 1;
            rbp_2 -= 1;
            free_maps_1 = free_maps_2;
        } while (i > 0x65);
    }
    
    return result;
}

uint64_t mmc_term()
{
    int64_t rax;
    int64_t var_28 = rax;
    uint64_t maps_1 = maps;
    uint32_t free_count_1;
    uint64_t free_maps_1;
    
    if (maps_1 == 0)
    {
        free_maps_1 = free_maps;
        
        if (free_maps_1 != 0)
        {
            free_count_1 = free_count;
        label_10ef2:
            uint32_t rbp_2 = (free_count_1 - 1);
            uint32_t rbx_2 = (alloc_count - 1);
            uint64_t i;
            
            do
            {
                i = *(free_maps_1 + 0x40);
                free_maps = i;
                free_count = rbp_2;
                maps_1 = free(free_maps_1);
                alloc_count = rbx_2;
                rbp_2 -= 1;
                rbx_2 -= 1;
                free_maps_1 = i;
            } while (i != 0);
        }
        
        return maps_1;
    }
    
    do
    {
        free_maps_1 = maps_1;
        int64_t rsi_1 = *(maps_1 + 0x10);
        
        if ((rsi_1 != 0 && munmap(*(free_maps_1 + 0x30), rsi_1) < 0))
            syslog(3, "munmap - %m");
        
        mapped_bytes -= *(free_maps_1 + 0x10);
        uint64_t rax_2 = *(free_maps_1 + 0x40);
        map_count -= 1;
        maps = rax_2;
        *(free_maps_1 + 0x40) = free_maps;
        free_maps = free_maps_1;
        free_count_1 = (free_count + 1);
        free_count = free_count_1;
        *(hash_table + (*(free_maps_1 + 0x3c) << 3)) = 0;
        maps_1 = maps;
    } while (maps_1 != 0);
    
    goto label_10ef2;
}

int64_t mmc_logstats(int64_t arg1 @ rax)
{
    syslog(5, "  map cache - %d allocated, %d aâ€¦", alloc_count, map_count, mapped_bytes, free_count, hash_size, expire_age, arg1);
    
    if ((free_count + map_count) != alloc_count)
        /* tailcall */
        return syslog(3, "map counts don't add up!");
    
    return arg1;
}

int64_t tmr_init()
{
    int64_t result = memset(&timers, 0, 0x218);
    free_timers = 0;
    free_count = 0;
    active_count = 0;
    alloc_count = 0;
    return result;
}

uint64_t tmr_create(int128_t* arg1, int64_t arg2, int64_t arg3, int64_t arg4, int32_t arg5)
{
    int64_t rax;
    int64_t var_38 = rax;
    uint64_t free_timers_1 = free_timers;
    int32_t rax_2;
    uint32_t* rcx;
    
    if (free_timers_1 == 0)
    {
        uint64_t free_timers_2 = malloc(0x48);
        
        if (free_timers_2 == 0)
            return 0;
        
        free_timers_1 = free_timers_2;
        rax_2 = 1;
        rcx = &alloc_count;
    }
    else
    {
        free_timers = *(free_timers_1 + 0x38);
        rax_2 = -1;
        rcx = &free_count;
    }
    
    *rcx += rax_2;
    *free_timers_1 = arg2;
    *(free_timers_1 + 8) = arg3;
    *(free_timers_1 + 0x10) = arg4;
    *(free_timers_1 + 0x18) = arg5;
    
    if (arg1 == 0)
        gettimeofday((free_timers_1 + 0x20), nullptr);
    else
        *(free_timers_1 + 0x20) = *arg1;
    
    int64_t rcx_4 = ((arg4 / 0x3e8) + *(free_timers_1 + 0x20));
    *(free_timers_1 + 0x20) = rcx_4;
    int64_t rsi_1 = (((arg4 % 0x3e8) * 0x3e8) + *(free_timers_1 + 0x28));
    *(free_timers_1 + 0x28) = rsi_1;
    
    if (rsi_1 >= 0xf4240)
    {
        rcx_4 += (rsi_1 / 0xf4240);
        *(free_timers_1 + 0x20) = rcx_4;
        rsi_1 = (rsi_1 % 0xf4240);
        *(free_timers_1 + 0x28) = rsi_1;
    }
    
    uint64_t rdx_5 = ((rsi_1 ^ rcx_4) % 0x43);
    *(free_timers_1 + 0x40) = rdx_5;
    void* rax_15 = *(&timers + (rdx_5 << 3));
    
    if (rax_15 == 0)
    {
        *(&timers + (rdx_5 << 3)) = free_timers_1;
        *(free_timers_1 + 0x30) = {0};
    }
    else
    {
        int64_t temp0_1 = *(rax_15 + 0x20);
        
        if ((rcx_4 >= temp0_1 && (rcx_4 != temp0_1 || rsi_1 > *(rax_15 + 0x28))))
        {
            void* rdx_6 = *(rax_15 + 0x38);
            
            if (rdx_6 == 0)
            {
            label_111ac:
                *(rax_15 + 0x38) = free_timers_1;
                *(free_timers_1 + 0x30) = rax_15;
                *(free_timers_1 + 0x38) = 0;
            }
            else
            {
                int64_t rbp_1 = *(rdx_6 + 0x20);
                void* rdi_1;
                
                if (rcx_4 >= rbp_1)
                {
                    while (true)
                    {
                        rdi_1 = rdx_6;
                        
                        if ((rcx_4 == rbp_1 && rsi_1 <= *(rdi_1 + 0x28)))
                        {
                            rdx_6 = rdi_1;
                            break;
                        }
                        
                        rdx_6 = *(rdi_1 + 0x38);
                        
                        if (rdx_6 == 0)
                        {
                            rax_15 = rdi_1;
                            goto label_111ac;
                        }
                        
                        rbp_1 = *(rdx_6 + 0x20);
                        rax_15 = rdi_1;
                        
                        if (rcx_4 < rbp_1)
                            goto label_11193;
                    }
                }
                
                rdi_1 = rax_15;
            label_11193:
                *(rdi_1 + 0x38) = free_timers_1;
                *(free_timers_1 + 0x30) = rdi_1;
                *(free_timers_1 + 0x38) = rdx_6;
                *(rdx_6 + 0x30) = free_timers_1;
            }
        }
        else
        {
            *(&timers + (rdx_5 << 3)) = free_timers_1;
            *(free_timers_1 + 0x30) = 0;
            *(free_timers_1 + 0x38) = rax_15;
            *(rax_15 + 0x30) = free_timers_1;
        }
    }
    
    active_count += 1;
    return free_timers_1;
}

uint64_t tmr_timeout(int64_t* arg1)
{
    int64_t i = 0;
    void* r11 = nullptr;
    int32_t r10 = 0;
    uint64_t result;
    
    do
    {
        result = *(i + &timers);
        
        if (result != 0)
        {
            int64_t rcx_1 = ((*(result + 0x20) - *arg1) * 0x3e8);
            int64_t rax_3;
            int64_t rdx_3;
            rdx_3 = HIGHQ(((*(result + 0x28) - arg1[1]) * 0x20c49ba5e353f7cf));
            rax_3 = LOWQ(((*(result + 0x28) - arg1[1]) * 0x20c49ba5e353f7cf));
            result = (rdx_3 >> 0x3f);
            void* rdx_6 = (((rdx_3 >> 7) + result) + rcx_1);
            
            if (r10 != 0)
            {
                if (rdx_6 < r11)
                    r11 = rdx_6;
                
                r10 = 1;
            }
            else
            {
                r10 = 1;
                r11 = rdx_6;
            }
        }
        
        i += 8;
    } while (i != 0x218);
    
    if (r11 < 0)
        r11 = nullptr;
    
    if (r10 != 0)
    {
        int64_t rdi_1 = ((arg1 - arg1) | r11);
        tmr_timeout.timeout = (rdi_1 / 0x3e8);
        result = &tmr_timeout.timeout;
        data_1b768 = ((rdi_1 % 0x3e8) * 0x3e8);
    }
    
    return result;
}

int64_t tmr_mstimeout(int64_t* arg1)
{
    int64_t i = 0;
    void* r11 = nullptr;
    int32_t r10 = 0;
    uint64_t rax_1;
    
    do
    {
        rax_1 = *(i + &timers);
        
        if (rax_1 != 0)
        {
            int64_t rsi_1 = ((*(rax_1 + 0x20) - *arg1) * 0x3e8);
            int64_t rax_4;
            int64_t rdx_3;
            rdx_3 = HIGHQ(((*(rax_1 + 0x28) - arg1[1]) * 0x20c49ba5e353f7cf));
            rax_4 = LOWQ(((*(rax_1 + 0x28) - arg1[1]) * 0x20c49ba5e353f7cf));
            rax_1 = (rdx_3 >> 0x3f);
            void* rdx_6 = (((rdx_3 >> 7) + rax_1) + rsi_1);
            
            if (r10 != 0)
            {
                if (rdx_6 < r11)
                    r11 = rdx_6;
                
                r10 = 1;
            }
            else
            {
                r10 = 1;
                r11 = rdx_6;
            }
        }
        
        i += 8;
    } while (i != 0x218);
    
    void* rcx = nullptr;
    
    if (r11 >= 0)
        rcx = r11;
    
    return ((rax_1 - rax_1) | rcx);
}

void tmr_run(int64_t* arg1)
{
    uint64_t rax;
    uint64_t var_38 = rax;
    
    for (int64_t i = 0; i != 0x43; i += 1)
    {
        uint64_t j_1 = *(&timers + (i << 3));
        
        if (j_1 != 0)
        {
            uint64_t j;
            
            do
            {
                rax = *arg1;
                int64_t temp0_1 = *(j_1 + 0x20);
                
                if (temp0_1 > rax)
                    break;
                
                j = *(j_1 + 0x38);
                
                if ((temp0_1 == rax && *(j_1 + 0x28) > arg1[1]))
                    break;
                
                *j_1(*(j_1 + 8), arg1);
                
                if (*(j_1 + 0x18) == 0)
                {
                    void* rax_9 = *(j_1 + 0x30);
                    void* rcx_7;
                    
                    if (rax_9 == 0)
                    {
                        rcx_7 = *(j_1 + 0x38);
                        *(&timers + (*(j_1 + 0x40) << 3)) = rcx_7;
                        
                        if (rcx_7 != 0)
                            *(rcx_7 + 0x30) = rax_9;
                    }
                    else
                    {
                        *(rax_9 + 0x38) = *(j_1 + 0x38);
                        rcx_7 = *(j_1 + 0x38);
                        
                        if (rcx_7 != 0)
                            *(rcx_7 + 0x30) = rax_9;
                    }
                    active_count -= 1;
                    *(j_1 + 0x38) = free_timers;
                    free_timers = j_1;
                    free_count += 1;
                    *(j_1 + 0x30) = 0;
                }
                else
                {
                    int64_t rsi_2 = *(j_1 + 0x10);
                    int64_t rcx_4 = ((rsi_2 / 0x3e8) + *(j_1 + 0x20));
                    *(j_1 + 0x20) = rcx_4;
                    int64_t rsi_5 = (((rsi_2 % 0x3e8) * 0x3e8) + *(j_1 + 0x28));
                    *(j_1 + 0x28) = rsi_5;
                    
                    if (rsi_5 >= 0xf4240)
                    {
                        *(j_1 + 0x20) = (rcx_4 + (rsi_5 / 0xf4240));
                        *(j_1 + 0x28) = (rsi_5 % 0xf4240);
                    }
                    
                    l_resort(j_1);
                }
                
                j_1 = j;
            } while (j != 0);
        }
    }
}

uint64_t l_resort(void* arg1)
{
    void* rax_3 = *(arg1 + 0x30);
    void* rcx_1;
    
    if (rax_3 == 0)
    {
        rcx_1 = *(arg1 + 0x38);
        *(&timers + (*(arg1 + 0x40) << 3)) = rcx_1;
        
        if (rcx_1 != 0)
            *(rcx_1 + 0x30) = rax_3;
    }
    else
    {
        *(rax_3 + 0x38) = *(arg1 + 0x38);
        rcx_1 = *(arg1 + 0x38);
        
        if (rcx_1 != 0)
            *(rcx_1 + 0x30) = rax_3;
    }
    int64_t r9 = *(arg1 + 0x20);
    int64_t r8 = *(arg1 + 0x28);
    int32_t rsi_1 = (r8 ^ r9);
    uint64_t result = ((rsi_1 / 0x43) * 0x43);
    uint64_t rsi_2 = (rsi_1 - result);
    *(arg1 + 0x40) = rsi_2;
    void* rdx_1 = *(&timers + (rsi_2 << 3));
    
    if (rdx_1 == 0)
    {
        *(&timers + (rsi_2 << 3)) = arg1;
        *(arg1 + 0x30) = {0};
        return result;
    }
    
    int64_t temp0 = *(rdx_1 + 0x20);
    
    if ((r9 < temp0 || (r9 == temp0 && r8 <= *(rdx_1 + 0x28))))
    {
        *(&timers + (rsi_2 << 3)) = arg1;
        *(arg1 + 0x30) = 0;
        *(arg1 + 0x38) = rdx_1;
        *(rdx_1 + 0x30) = arg1;
        return result;
    }
    
    void* rsi_3 = *(rdx_1 + 0x38);
    
    if (rsi_3 == 0)
    {
    label_115c7:
        *(rdx_1 + 0x38) = arg1;
        *(arg1 + 0x30) = rdx_1;
        *(arg1 + 0x38) = 0;
        return result;
    }
    
    result = *(rsi_3 + 0x20);
    void* rcx_2;
    
    if (r9 >= result)
    {
        while (true)
        {
            rcx_2 = rsi_3;
            
            if ((r9 == result && r8 <= *(rcx_2 + 0x28)))
            {
                rsi_3 = rcx_2;
                break;
            }
            
            rsi_3 = *(rcx_2 + 0x38);
            
            if (rsi_3 == 0)
            {
                rdx_1 = rcx_2;
                goto label_115c7;
            }
            
            result = *(rsi_3 + 0x20);
            rdx_1 = rcx_2;
            
            if (r9 < result)
                goto label_115b3;
        }
    }
    
    rcx_2 = rdx_1;
label_115b3:
    *(rcx_2 + 0x38) = arg1;
    *(arg1 + 0x30) = rcx_2;
    *(arg1 + 0x38) = rsi_3;
    *(rsi_3 + 0x30) = arg1;
    return result;
}

uint64_t tmr_cancel(uint64_t arg1)
{
    void* rax = *(arg1 + 0x30);
    void* rcx_1;
    
    if (rax == 0)
    {
        rcx_1 = *(arg1 + 0x38);
        *(&timers + (*(arg1 + 0x40) << 3)) = rcx_1;
        
        if (rcx_1 != 0)
            *(rcx_1 + 0x30) = rax;
    }
    else
    {
        *(rax + 0x38) = *(arg1 + 0x38);
        rcx_1 = *(arg1 + 0x38);
        
        if (rcx_1 != 0)
            *(rcx_1 + 0x30) = rax;
    }
    active_count -= 1;
    uint64_t free_timers_1 = free_timers;
    *(arg1 + 0x38) = free_timers_1;
    free_timers = arg1;
    free_count += 1;
    *(arg1 + 0x30) = 0;
    return free_timers_1;
}

int64_t tmr_reset(int128_t* arg1, void* arg2)
{
    *(arg2 + 0x20) = *arg1;
    int64_t rdi = *(arg2 + 0x10);
    int64_t rcx_3 = ((rdi / 0x3e8) + *(arg2 + 0x20));
    *(arg2 + 0x20) = rcx_3;
    int64_t rdi_3 = (((rdi % 0x3e8) * 0x3e8) + *(arg2 + 0x28));
    *(arg2 + 0x28) = rdi_3;
    
    if (rdi_3 >= 0xf4240)
    {
        *(arg2 + 0x20) = (rcx_3 + (rdi_3 / 0xf4240));
        *(arg2 + 0x28) = (rdi_3 % 0xf4240);
    }
    
    /* tailcall */
    return l_resort(arg2);
}

void tmr_cleanup()
{
    uint64_t free_timers_1 = free_timers;
    
    if (free_timers_1 != 0)
    {
        uint32_t rbp_2 = (free_count - 1);
        uint32_t rbx_2 = (alloc_count - 1);
        uint64_t i;
        
        do
        {
            i = *(free_timers_1 + 0x38);
            free_timers = i;
            free_count = rbp_2;
            free(free_timers_1);
            alloc_count = rbx_2;
            rbp_2 -= 1;
            rbx_2 -= 1;
            free_timers_1 = i;
        } while (i != 0);
    }
}

uint32_t tmr_term()
{
    uint32_t active_count_1 = active_count;
    uint64_t free_timers_1 = free_timers;
    uint32_t free_count_1 = free_count;
    
    for (int64_t i = 0; i != 0x43; i += 1)
    {
        uint64_t j = *(&timers + (i << 3));
        
        if (j != 0)
        {
            uint64_t rdx_1;
            
            do
            {
                rdx_1 = j;
                void* rbp_1 = *(j + 0x30);
                void* rsi_1;
                
                if (rbp_1 == 0)
                {
                    rsi_1 = *(rdx_1 + 0x38);
                    *(&timers + (*(rdx_1 + 0x40) << 3)) = rsi_1;
                    
                    if (rsi_1 != 0)
                        *(rsi_1 + 0x30) = rbp_1;
                }
                else
                {
                    *(rbp_1 + 0x38) = *(rdx_1 + 0x38);
                    rsi_1 = *(rdx_1 + 0x38);
                    
                    if (rsi_1 != 0)
                        *(rsi_1 + 0x30) = rbp_1;
                }
                active_count_1 -= 1;
                *(rdx_1 + 0x38) = free_timers_1;
                free_count_1 += 1;
                *(rdx_1 + 0x30) = 0;
                j = *(&timers + (i << 3));
                free_timers_1 = rdx_1;
            } while (j != 0);
            
            active_count = active_count_1;
            free_timers = rdx_1;
            free_count = free_count_1;
            free_timers_1 = rdx_1;
        }
    }
    
    if (free_timers_1 != 0)
    {
        uint32_t rbx = (free_count_1 - 1);
        uint32_t rbp_3 = (alloc_count - 1);
        uint64_t i_1;
        
        do
        {
            i_1 = *(free_timers_1 + 0x38);
            free_timers = i_1;
            free_count = rbx;
            active_count_1 = free(free_timers_1);
            alloc_count = rbp_3;
            rbx -= 1;
            rbp_3 -= 1;
            free_timers_1 = i_1;
        } while (i_1 != 0);
    }
    
    return active_count_1;
}

int64_t tmr_logstats(int64_t arg1 @ rax)
{
    syslog(5, "  timers - %d allocated, %d actiâ€¦", alloc_count, active_count, free_count);
    
    if ((free_count + active_count) != alloc_count)
        /* tailcall */
        return syslog(3, "timer counts don't add up!");
    
    return arg1;
}

int64_t match(char* arg1, char* arg2)
{
    void* rbx = arg1;
    char* i_2 = strchr(arg1, 0x7c);
    
    if (i_2 != 0)
    {
        char* i_1 = i_2;
        char* i;
        
        do
        {
            if (match_one(rbx, (i_1 - rbx), arg2) != 0)
                return 1;
            
            rbx = &i_1[1];
            i = strchr(rbx, 0x7c);
            i_1 = i;
        } while (i != 0);
    }
    
    /* tailcall */
    return match_one(rbx, strlen(rbx), arg2);
}

uint64_t match_one(void* arg1, int32_t arg2, char* arg3)
{
    int64_t rax;
    int64_t var_38 = rax;
    char* r15 = arg3;
    int32_t r13;
    
    if (arg2 > 0)
    {
        int64_t rcx_1 = arg2;
        void* rbx_1 = (arg1 + 1);
        int64_t rdx = 0;
        
        while (true)
        {
            char rax_1 = *(rbx_1 - 1);
            
            if (rax_1 != 0x3f)
            {
                if (rax_1 != 0x2a)
                {
                    if (rax_1 == r15[rdx])
                        goto label_11957;
                    
                    return 0;
                }
                
                void* r15_1 = &r15[rdx];
                int32_t rax_3;
                
                if (*rbx_1 != 0x2a)
                    rax_3 = strcspn(r15_1, "/");
                else
                {
                    rbx_1 += 1;
                    rax_3 = strlen(r15_1);
                }
                
                r13 = 0;
                
                if ((rax_3 & 0x80000000) == 0)
                {
                    uint64_t rbp_1 = rax_3;
                    bool cond:0_1;
                    
                    do
                    {
                        if (match_one(rbx_1, ((arg1 - rbx_1) + arg2), (r15_1 + rbp_1)) != 0)
                        {
                            r13 = 1;
                            break;
                        }
                        
                        cond:0_1 = rbp_1 > 0;
                        rbp_1 -= 1;
                    } while (cond:0_1);
                }
                
                return r13;
            }
            
            if (r15[rdx] == 0)
                return 0;
            
        label_11957:
            rbx_1 += 1;
            rdx += 1;
            
            if (rdx >= rcx_1)
            {
                r15 = &r15[rcx_1];
                break;
            }
        }
    }
    
    r13 = *r15 == 0;
    return r13;
}

int64_t tdate_parse(char* arg1)
{
    char* s = arg1;
    
    while (true)
    {
        char rax_1 = *s;
        
        if ((rax_1 != 0x20 && rax_1 != 9))
        {
            int32_t var_44c;
            int32_t var_448;
            int32_t var_444;
            int32_t var_438;
            int32_t var_434;
            void var_428;
            int32_t rax_3 = __isoc99_sscanf(s, "%d-%400[a-zA-Z]-%d %d:%d:%d GMT", &var_44c, &var_428, &var_444, &var_448, &var_438, &var_434);
            int64_t var_440;
            int32_t rax_4;
            
            if (rax_3 == 6)
                rax_4 = scan_mon(&var_428, &var_440);
            
            if ((rax_3 != 6 || rax_4 == 0))
            {
                int32_t rax_6 = __isoc99_sscanf(s, "%d %400[a-zA-Z] %d %d:%d:%d GMT", &var_44c, &var_428, &var_444, &var_448, &var_438, &var_434);
                int32_t rax_7;
                
                if (rax_6 == 6)
                    rax_7 = scan_mon(&var_428, &var_440);
                
                if ((rax_6 != 6 || rax_7 == 0))
                {
                    int32_t rax_9 = __isoc99_sscanf(s, "%d:%d:%d GMT %d-%400[a-zA-Z]-%d", &var_448, &var_438, &var_434, &var_44c, &var_428, &var_444);
                    int32_t rax_10;
                    
                    if (rax_9 == 6)
                        rax_10 = scan_mon(&var_428, &var_440);
                    
                    if ((rax_9 != 6 || rax_10 == 0))
                    {
                        int32_t rax_12 = __isoc99_sscanf(s, "%d:%d:%d GMT %d %400[a-zA-Z] %d", &var_448, &var_438, &var_434, &var_44c, &var_428, &var_444);
                        int32_t rax_13;
                        
                        if (rax_12 == 6)
                            rax_13 = scan_mon(&var_428, &var_440);
                        
                        void var_228;
                        
                        if ((rax_12 != 6 || rax_13 == 0))
                        {
                            void var_430;
                            
                            if (__isoc99_sscanf(s, "%400[a-zA-Z], %d-%400[a-zA-Z]-%dâ€¦", &var_228, &var_44c, &var_428, &var_444, &var_448, &var_438, &var_434) != 7)
                            {
                            label_11c10:
                                
                                if (__isoc99_sscanf(s, "%400[a-zA-Z], %d %400[a-zA-Z] %dâ€¦", &var_228, &var_44c, &var_428, &var_444, &var_448, &var_438, &var_434) != 7)
                                {
                                label_11c73:
                                    int64_t result = -1;
                                    
                                    if (__isoc99_sscanf(s, "%400[a-zA-Z] %400[a-zA-Z] %d %d:â€¦", &var_228, &var_428, &var_44c, &var_448, &var_438, &var_434, &var_444) != 7)
                                        return result;
                                    
                                    if (scan_wday(&var_228, &var_430) == 0)
                                        return result;
                                    
                                    if (scan_mon(&var_428, &var_440) == 0)
                                        return result;
                                }
                                else
                                {
                                    if (scan_wday(&var_228, &var_430) == 0)
                                        goto label_11c73;
                                    
                                    if (scan_mon(&var_428, &var_440) == 0)
                                        goto label_11c73;
                                }
                            }
                            else
                            {
                                if (scan_wday(&var_228, &var_430) == 0)
                                    goto label_11c10;
                                
                                if (scan_mon(&var_428, &var_440) == 0)
                                    goto label_11c10;
                            }
                        }
                    }
                }
            }
            
            int32_t rbx = var_444;
            int32_t rdi_17 = (rbx + 0x64);
            
            if (rbx >= 0x46)
                rdi_17 = rbx;
            
            if (rbx >= 0x76d)
                rdi_17 = (rbx - 0x76c);
            
            int32_t rcx_7 = (rdi_17 - 0x42);
            
            if ((rdi_17 - 0x45) >= 0)
                rcx_7 = (rdi_17 - 0x45);
            
            int64_t rax_30 = var_440;
            int64_t rbp_3 = (*(&tm_to_time.monthtab + (rax_30 << 2)) + ((rcx_7 >> 2) + ((rdi_17 * 0x16d) - 0x63ce)));
            
            if (rax_30 >= 2)
            {
                if ((RORD((((rdi_17 + 0x76c) * 0xc28f5c29) + 0x51eb850), 4)) <= 0xa3d70a)
                    rbp_3 += 1;
                else if (((RORD((((rdi_17 + 0x76c) * 0xc28f5c29) + 0x51eb850), 2)) >= 0x28f5c29 && (rdi_17 & 3) == 0))
                    rbp_3 += 1;
            }
            
            return ((((((var_448 + ((var_44c + rbp_3) * 0x18)) * 0x3c) + var_438) * 0x3c) + var_434) - 0x15180);  {  // {"2x"}}
        }
        
        s = &s[1];
    }
}

int64_t scan_mon(char* arg1, int64_t* arg2)
{
    int64_t rax;
    int64_t var_38 = rax;
    
    if (scan_mon.sorted == 0)
    {
        qsort(&scan_mon.mon_tab, 0x17, 0x10, strlong_compare);
        scan_mon.sorted = 1;
    }
    
    uint64_t rbx;
    rbx = *arg1;
    
    if (rbx != 0)
    {
        uint16_t** rax_1 = __ctype_b_loc();
        void* rbp_1 = &arg1[1];
        
        do
        {
            int64_t rbx_1 = rbx;
            
            if ((*(&*rax_1[rbx_1] + 1) & 1) != 0)
                *(rbp_1 - 1) = *__ctype_tolower_loc()[rbx_1];
            
            rbx = *rbp_1;
            rbp_1 += 1;
        } while (rbx != 0);
    }
    
    int32_t rbx_2 = 0;
    int32_t r13 = 0x16;
    
    while (true)
    {
        int32_t rax_6 = (rbx_2 + r13);
        int32_t rbp_6 = (((rax_6 >> 0x1f) + rax_6) >> 1);
        int64_t r14_2 = (rbp_6 << 4);
        int32_t rax_7 = strcmp(arg1, *(r14_2 + &scan_mon.mon_tab));
        
        if (rax_7 < 0)
        {
            r13 = (rbp_6 - 1);
            
            if (r13 < rbx_2)
                break;
        }
        else
        {
            if (rax_7 == 0)
            {
                *arg2 = *(r14_2 + 0x1ac98);
                return 1;
            }
            
            rbx_2 = (rbp_6 + 1);
            
            if (r13 < rbx_2)
                break;
        }
    }
    
    return 0;
}

int64_t scan_wday(char* arg1, int64_t* arg2)
{
    int64_t rax;
    int64_t var_38 = rax;
    
    if (scan_wday.sorted == 0)
    {
        qsort(&scan_wday.wday_tab, 0xe, 0x10, strlong_compare);
        scan_wday.sorted = 1;
    }
    
    uint64_t rbx;
    rbx = *arg1;
    
    if (rbx != 0)
    {
        uint16_t** rax_1 = __ctype_b_loc();
        void* rbp_1 = &arg1[1];
        
        do
        {
            int64_t rbx_1 = rbx;
            
            if ((*(&*rax_1[rbx_1] + 1) & 1) != 0)
                *(rbp_1 - 1) = *__ctype_tolower_loc()[rbx_1];
            
            rbx = *rbp_1;
            rbp_1 += 1;
        } while (rbx != 0);
    }
    
    int32_t rbx_2 = 0;
    int32_t r13 = 0xd;
    
    while (true)
    {
        int32_t rax_6 = (rbx_2 + r13);
        int32_t rbp_6 = (((rax_6 >> 0x1f) + rax_6) >> 1);
        int64_t r14_2 = (rbp_6 << 4);
        int32_t rax_7 = strcmp(arg1, *(r14_2 + &scan_wday.wday_tab));
        
        if (rax_7 < 0)
        {
            r13 = (rbp_6 - 1);
            
            if (r13 < rbx_2)
                break;
        }
        else
        {
            if (rax_7 == 0)
            {
                *arg2 = *(r14_2 + 0x1ae08);
                return 1;
            }
            
            rbx_2 = (rbp_6 + 1);
            
            if (r13 < rbx_2)
                break;
        }
    }
    
    return 0;
}

int64_t strlong_compare(int64_t* arg1, int64_t* arg2)
{
    /* tailcall */
    return strcmp(*arg1, *arg2);
}

int64_t _fini() __pure
{
    return;
}


