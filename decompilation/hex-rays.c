/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_5020();
// char *getenv(const char *name);
// void free(void *ptr);
// int strcasecmp(const char *s1, const char *s2);
// void closelog(void);
// struct tm *localtime(const time_t *timer);
// void __noreturn abort(void);
// int *__errno_location(void);
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// void __noreturn _exit(int status);
// char *strcpy(char *dest, const char *src);
// int chroot(const char *path);
// ssize_t writev(int fd, const struct iovec *iovec, int count);
// int puts(const char *s);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fcntl(int fd, int cmd, ...);
// ssize_t write(int fd, const void *buf, size_t n);
// __pid_t getpid(void);
// int fclose(FILE *stream);
// DIR *opendir(const char *name);
// char *ctime(const time_t *timer);
// int shutdown(int fd, int how);
// size_t strlen(const char *s);
// int chdir(const char *path);
// __uid_t getuid(void);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int dup2(int fd, int fd2);
// char *strchr(const char *s, int c);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// const char *gai_strerror(int ecode);
// char *strrchr(const char *s, int c);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void *memset(void *s, int c, size_t n);
// char *getcwd(char *buf, size_t size);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// int setgroups(size_t n, const __gid_t *groups);
// int pipe(int pipedes[2]);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags);
// __pid_t setsid(void);
// size_t strspn(const char *s, const char *accept);
// int closedir(DIR *dirp);
// size_t strcspn(const char *s, const char *reject);
// void *memchr(const void *s, int c, size_t n);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int lstat(const char *file, struct stat *buf);
// char *fgets(char *s, int n, FILE *stream);
// int execve(const char *path, char *const argv[], char *const envp[]);
// int strcmp(const char *s1, const char *s2);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// struct passwd *getpwnam(const char *name);
// int fprintf(FILE *stream, const char *format, ...);
// int stat(const char *file, struct stat *buf);
// __int64 strtol(const char *nptr, char **endptr, int base);
// void *memcpy(void *dest, const void *src, size_t n);
// void tzset(void);
// int kill(__pid_t pid, int sig);
// time_t time(time_t *timer);
// int fileno(FILE *stream);
// struct dirent *readdir(DIR *dirp);
// void *malloc(size_t size);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int fflush(FILE *stream);
// int nice(int inc);
// __int64 __isoc99_sscanf(_QWORD, const char *, ...); weak
// void syslog(int pri, const char *fmt, ...);
// int listen(int fd, int n);
// int daemon(int nochdir, int noclose);
// char *strpbrk(const char *s, const char *accept);
// int setrlimit(__rlimit_resource_t resource, const struct rlimit *rlimits);
// void *realloc(void *ptr, size_t size);
// FILE *fdopen(int fd, const char *modes);
// int munmap(void *addr, size_t len);
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __sighandler_t sigset(int sig, __sighandler_t disp);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// void *memmove(void *dest, const void *src, size_t n);
// int setgid(__gid_t gid);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int open(const char *file, int oflag, ...);
// int fchown(int fd, __uid_t owner, __gid_t group);
// FILE *fopen(const char *filename, const char *modes);
// void perror(const char *s);
// struct tm *gmtime(const time_t *timer);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// char *strcat(char *dest, const char *src);
// void openlog(const char *ident, int option, int facility);
// int gethostname(char *name, size_t len);
// int sprintf(char *s, const char *format, ...);
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int getrlimit(__rlimit_resource_t resource, struct rlimit *rlimits);
// int setuid(__uid_t uid);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// char *strdup(const char *s);
// int initgroups(const char *user, __gid_t group);
// char *crypt(const char *key, const char *salt);
// unsigned int sleep(unsigned int seconds);
// __pid_t fork(void);
// char *strstr(const char *haystack, const char *needle);
// int getdtablesize(void);
// const __int32_t **__ctype_tolower_loc(void);
// const unsigned __int16 **__ctype_b_loc(void);
// void freeaddrinfo(struct addrinfo *ai);
// int socket(int domain, int type, int protocol);
// int __fastcall _cxa_finalize(void *);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
char *deregister_tm_clones();
__int64 register_tm_clones();
char *_do_global_dtors_aux();
__int64 frame_dummy(); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
void __fastcall __noreturn handle_term(unsigned int a1);
void __fastcall handle_chld();
void handle_hup();
void handle_usr1();
void handle_usr2();
void handle_alrm();
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm4,xmm5> occasional(__int64 a1, time_t *a2);
__int64 __fastcall idle(__int64 a1, struct timeval *a2);
__int64 __fastcall update_throttles(); // weak
void __fastcall show_stats(__int64 a1, struct timeval *a2);
__int64 __fastcall handle_newconnect(_QWORD *a1, int a2);
struct timeval *__fastcall clear_connection(__int64 a1, struct timeval *a2);
void shut_down();
void __fastcall logstats(struct timeval *a1);
void __noreturn usage();
void __fastcall wakeup_connection(__int64 a1);
__int64 __fastcall really_clear_connection(__int64 a1, time_t *a2);
__int64 __fastcall linger_clear_connection(__int64 a1, time_t *a2);
_OWORD *__fastcall httpd_initialize(char *s, struct sockaddr *a2, struct sockaddr *a3, __int16 a4, _BYTE *a5, int a6, char *sa, char *a8, int a9, char *a10, int a11, __int64 a12, int a13, int a14, int a15, char *a16, char *a17, int a18);
int __fastcall httpd_set_logfp(__int64 a1, __int64 a2);
__int64 __fastcall initialize_listen_socket(struct sockaddr *sa); // idb
void __fastcall free_httpd_server(void **ptr);
char *__fastcall httpd_ntoa(__int64 a1);
void __fastcall httpd_terminate(_DWORD *ptr);
int __fastcall httpd_unlisten(__int64 a1);
void __fastcall httpd_write_response(__int64 a1);
int __fastcall httpd_clear_ndelay(int fd);
__int64 __fastcall httpd_write_fully(int fd, __int64 a2, unsigned __int64 a3);
int __fastcall httpd_set_ndelay(int fd);
unsigned __int64 __fastcall httpd_realloc_str(void **a1, __int64 *a2, unsigned __int64 a3);
void *__fastcall httpd_send_err(__int64 a1, unsigned int a2, const char *a3, char *a4, const char *a5, char *a6);
int my_snprintf(char *a1, size_t a2, const char *a3, ...);
__int64 __fastcall send_err_file(__int64 a1, unsigned int a2, const char *a3, char *a4, char *filename);
void *__fastcall send_response(__int64 a1, unsigned int a2, const char *a3, char *a4, const char *a5, char *a6);
const char *__fastcall httpd_method_str(int a1);
__int64 __fastcall httpd_get_conn(__int64 a1, int a2, __int64 a3);
__int64 __fastcall httpd_got_request(__int64 a1);
__int64 __fastcall httpd_parse_request(__int64 a1);
char *__fastcall expand_symlinks(char *src, char **a2, int a3, int a4);
void __fastcall httpd_close_conn(__int64 a1, time_t *a2);
void __fastcall httpd_destroy_conn(__int64 a1);
__int64 __fastcall httpd_start_request(__int64 a1, time_t *a2);
__int64 __fastcall httpd_read_fully(int fd, __int64 a2, unsigned __int64 a3);
void httpd_logstats();
void __fastcall send_mime(__int64 a1, unsigned int a2, const char *a3, const char *a4, char *a5, const char *a6, __int64 a7, time_t a8);
int __fastcall ext_compare(const char **a1, const char **a2);
__int64 __fastcall check_referrer(__int64 a1);
__int64 __fastcall auth_check2(__int64 a1, char *s);
void *__fastcall send_authenticate(__int64 a1, char *s);
int __fastcall name_compare(const char **a1, const char **a2);
int __fastcall cgi_kill(__suseconds_t a1, struct timeval *a2);
void __fastcall cgi_kill2(unsigned int a1);
__int64 __fastcall cgi_interpose_input(__int64 a1, int a2);
int __fastcall cgi_interpose_output(__int64 a1, int a2);
char *__fastcall build_env(const char *a1, const char *a2);
__int64 fdwatch_get_nfiles();
void __fastcall fdwatch_add_fd(int a1, __int64 a2, int a3);
void __fastcall fdwatch_del_fd(unsigned int a1);
__int64 __fastcall fdwatch(int timeout); // idb
__int64 __fastcall fdwatch_check_fd(int a1);
__int64 fdwatch_get_next_client_data();
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm0,xmm4,xmm5> fdwatch_logstats(__int64 a1);
__ino_t __fastcall mmc_map(char *file, const void *a2, time_t *a3);
void __noreturn panic();
void __fastcall mmc_unmap(__int64 a1, __int64 *a2, time_t *a3);
void __fastcall mmc_cleanup(time_t *a1);
void mmc_term();
void mmc_logstats();
void tmr_init();
struct timeval *__fastcall tmr_create(struct timeval *a1, __time_t a2, __suseconds_t a3, __time_t a4, int a5);
__int64 *__fastcall tmr_timeout(_QWORD *a1);
__int64 __fastcall tmr_mstimeout(_QWORD *a1);
_QWORD *__fastcall tmr_run(__int64 a1);
_QWORD *__fastcall l_resort(__int64 a1);
void *__fastcall tmr_cancel(__int64 a1);
_QWORD *__fastcall tmr_reset(_OWORD *a1, __int64 a2);
void tmr_cleanup();
void tmr_term();
void tmr_logstats();
__int64 __fastcall match(char *s, _BYTE *a2);
__int64 __fastcall match_one(__int64 a1, int a2, _BYTE *a3);
__int64 __fastcall tdate_parse(_BYTE *a1);
__int64 __fastcall scan_mon(char *s1, _QWORD *a2);
__int64 __fastcall scan_wday(char *s1, _QWORD *a2);
int __fastcall strlong_compare(const char **a1, const char **a2);
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
_DWORD b64_decode_table[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  62,
  -1,
  -1,
  -1,
  63,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
int dword_13280[4] = { 620, 625, 629, 636 }; // weak
int tm_to_time_monthtab[12] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 }; // weak
char *really_start_request_index_names = "index.html"; // weak
char *off_18DA0 = "GET"; // weak
void *_dso_handle = &_dso_handle; // idb
int httpd_err400title = 78741; // idb
char *httpd_err400form[5] =
{
  "Your request has bad syntax or is inherently impossible to satisfy.\n",
  "Request Timeout",
  "No request appeared within a reasonable time period.\n",
  "Service Temporarily Overloaded",
  "The requested URL '%.80s' is temporarily overloaded.  Please try again later.\n"
}; // weak
char *httpd_err408title[4] =
{
  "Request Timeout",
  "No request appeared within a reasonable time period.\n",
  "Service Temporarily Overloaded",
  "The requested URL '%.80s' is temporarily overloaded.  Please try again later.\n"
}; // weak
char *httpd_err408form[3] =
{
  "No request appeared within a reasonable time period.\n",
  "Service Temporarily Overloaded",
  "The requested URL '%.80s' is temporarily overloaded.  Please try again later.\n"
}; // weak
int httpd_err503title = 78892; // idb
char *httpd_err503form = "The requested URL '%.80s' is temporarily overloaded.  Please try again later.\n"; // weak
char *enc_tab = (char *)0x153EDLL; // idb
__int64 qword_193D8 = 0LL; // weak
char *off_193E0 = "compress"; // idb
__int64 qword_193E8 = 0LL; // weak
char *off_193F0 = (char *)0x14588LL; // idb
__int64 qword_193F8 = 0LL; // weak
char *off_19400 = "gzip"; // idb
__int64 qword_19408 = 0LL; // weak
char *off_19410 = "uu"; // idb
__int64 qword_19418 = 0LL; // weak
char *off_19420 = "x-uuencode"; // idb
__int64 qword_19428 = 0LL; // weak
void *typ_tab = (void *)0x141C4LL; // weak
char send_dirredirect_headstr[11] = "Location: "; // weak
char send_authenticate_headstr[32] = "WWW-Authenticate: Basic realm=\""; // weak
__int64 *expire_age = &qword_258; // weak
char *scan_mon_mon_tab = "jan"; // weak
char *scan_wday_wday_tab = "sun"; // weak
char _bss_start; // weak
int terminate; // weak
__int64 argv0; // weak
int numthrottles; // weak
int maxthrottles; // weak
void *throttles; // idb
char *throttlefile; // idb
char *user; // idb
char *logfile; // idb
char no_log; // weak
char *dir; // idb
char debug; // weak
char *pidfile; // idb
int max_connects; // weak
char do_chroot; // weak
char *data_dir; // idb
int got_hup; // weak
int got_usr1; // weak
int watchdog_flag; // weak
char *hostname; // idb
__int16 port; // weak
__int64 cgi_pattern; // weak
int cgi_limit; // weak
char *charset; // idb
char *p3p; // idb
int max_age; // weak
char no_symlink_check; // weak
char do_vhost; // weak
char do_global_passwd; // weak
char *url_pattern; // idb
char *local_pattern; // idb
char no_empty_referrers; // weak
void *hs; // idb
__int64 stats_time; // weak
__int64 start_time; // weak
__int64 stats_connections; // weak
__int64 stats_bytes; // weak
int stats_simultaneous; // weak
void *connects; // idb
int first_free_connect; // weak
int num_connects; // weak
int httpd_conn_count; // weak
char httpd_initialize_ghnbuf; // idb
char sub_process; // weak
int str_alloc_count; // weak
__int64 str_alloc_size; // weak
char httpd_ntoa_str[]; // idb
char src[193]; // idb
char *vhost_map_tempfilename; // idb
__int64 vhost_map_maxtempfilename; // weak
char *expand_symlinks_checked; // idb
char *expand_symlinks_rest; // idb
__int64 expand_symlinks_maxchecked; // weak
__int64 expand_symlinks_maxrest; // weak
char *really_start_request_indexname; // idb
__int64 really_start_request_maxindexname; // weak
char *really_start_request_dirname; // idb
__int64 really_start_request_maxdirname; // weak
char *send_dirredirect_location; // idb
__int64 send_dirredirect_header; // weak
__int64 send_dirredirect_maxlocation; // weak
__int64 send_dirredirect_maxheader; // weak
char *auth_check2_authpath; // idb
__int64 auth_check2_maxauthpath; // weak
char *auth_check2_prevauthpath; // idb
__int64 auth_check2_maxprevauthpath; // weak
__int64 auth_check2_prevmtime; // weak
char *auth_check2_prevuser; // idb
__int64 auth_check2_maxprevuser; // weak
char *auth_check2_prevcryp; // idb
__int64 auth_check2_maxprevcryp; // weak
int send_authenticate_header; // idb
__int64 send_authenticate_maxheader; // weak
__int64 really_check_referrer_refhost; // weak
__int64 really_check_referrer_refhost_size; // weak
int ls_maxnames; // weak
void *ls_names; // idb
void *ls_nameptrs; // idb
char *ls_name; // idb
__int64 ls_maxname; // weak
char *ls_rname; // idb
__int64 ls_maxrname; // weak
char *ls_encrname; // idb
int ls_maxencrname; // weak
char *make_envp_envp; // idb
__int64 qword_1B308; // weak
__int64 qword_1B310; // weak
char *build_env_buf; // idb
__int64 build_env_maxbuf; // weak
int nfiles; // weak
__int64 nwatches; // weak
__int64 fd_rw; // weak
__int64 fd_data; // weak
int nreturned; // weak
int next_ridx; // weak
struct pollfd *pollfds; // idb
__int64 poll_fdidx; // weak
__int64 poll_rfdidx; // weak
int npoll_fds; // weak
void *free_maps; // idb
int free_count; // weak
int alloc_count; // weak
void *maps; // idb
int map_count; // weak
__int64 mapped_bytes; // weak
int hash_size; // weak
void *hash_table; // idb
int hash_mask; // weak
_QWORD timers[67]; // weak
void *free_timers; // idb
int free_count_0; // weak
int active_count; // weak
int alloc_count_0; // weak
__int64 tmr_timeout_timeout; // weak
__int64 qword_1B768; // weak
_UNKNOWN JunkClientData; // weak
char scan_mon_sorted; // weak
char scan_wday_sorted; // weak
// extern struct _IO_FILE *stdout;
// extern struct _IO_FILE *stdin;
// extern struct _IO_FILE *stderr;


//----- (0000000000005000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 1BB30: using guessed type __int64 _gmon_start__(void);

//----- (0000000000005020) ----------------------------------------------------
void sub_5020()
{
  JUMPOUT(0LL);
}
// 5026: control flows out of bounds to 0

//----- (0000000000005730) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, 0LL, 0LL, a3, &v5);
  __halt();
}
// 573A: positive sp value 8 has been found
// 5741: variable 'v3' is possibly undefined

//----- (0000000000005760) ----------------------------------------------------
char *deregister_tm_clones()
{
  return &_bss_start;
}
// 1AEE0: using guessed type char _bss_start;

//----- (0000000000005790) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0LL;
}

//----- (00000000000057D0) ----------------------------------------------------
char *_do_global_dtors_aux()
{
  char *result; // rax

  if ( !_bss_start )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    _bss_start = 1;
  }
  return result;
}
// 1AEE0: using guessed type char _bss_start;

//----- (0000000000005810) ----------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}
// 5810: using guessed type __int64 frame_dummy();

//----- (0000000000005820) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v4; // rbx
  char *v5; // rax
  const char *v6; // rdi
  int v7; // edx
  int v8; // ebp
  __int64 v9; // r12
  int v10; // edx
  const char *v11; // rbx
  const char *v12; // rbx
  FILE *v13; // rax
  FILE *v14; // rbp
  char *v15; // rax
  size_t v16; // rax
  const char *v17; // rbp
  const char *i; // rbx
  unsigned __int64 v19; // rax
  char *v20; // rax
  char *v21; // r14
  const char *v22; // r14
  char *v23; // rax
  char *v24; // rax
  char *v25; // rax
  char *v26; // rax
  char *v27; // rax
  char *v28; // rax
  char *v29; // rax
  char *v30; // rax
  char *v31; // rax
  char *v32; // rax
  char *v33; // rax
  char *v34; // rax
  __int16 v35; // ax
  int v36; // eax
  int v37; // r14d
  int v38; // eax
  struct addrinfo *tv_sec; // rbx
  __time_t v40; // rbp
  __time_t v41; // rcx
  __time_t v42; // rax
  int v43; // edx
  unsigned __int64 v44; // r8
  FILE *v45; // rax
  FILE *v46; // r15
  __gid_t pw_gid; // r12d
  __uid_t pw_uid; // r15d
  struct passwd *v49; // rax
  const char *v50; // rbp
  FILE *v51; // rax
  struct _IO_FILE *v52; // rbp
  int v53; // eax
  int v54; // eax
  const char *v55; // rdi
  FILE *v56; // rax
  __int64 v57; // rbp
  char *v58; // rax
  int v59; // eax
  __int64 v60; // rax
  unsigned __int64 v61; // rdx
  bool v62; // cf
  size_t v63; // rax
  char *v64; // rax
  char *v65; // r15
  void *v66; // r12
  const char *v67; // r15
  size_t v68; // rax
  __int64 v69; // r12
  __int64 v70; // rax
  void *v71; // rax
  char *v72; // rax
  char *v73; // rcx
  __int64 v74; // rdx
  FILE *v75; // rbx
  unsigned int v76; // eax
  int nfiles; // eax
  char *v78; // r14
  size_t v79; // rbx
  struct sockaddr *v80; // rsi
  struct sockaddr *v81; // rdx
  int v82; // ebp
  __int64 v83; // rbx
  _QWORD *v84; // rax
  __int64 v85; // rcx
  _QWORD *v86; // rsi
  __int64 v87; // rdx
  _DWORD *v88; // rax
  int v89; // edi
  int v90; // edi
  FILE *v91; // rax
  __int64 v92; // rbp
  int v93; // eax
  int v94; // eax
  int v95; // eax
  int v96; // ebp
  int v97; // edi
  int v98; // edi
  const char *v99; // rdx
  const char *v100; // r8
  __int64 v101; // rdi
  unsigned int v102; // esi
  char *v103; // r9
  __int64 v104; // rdi
  __int64 next_client_data; // rax
  __int64 v106; // r14
  int v107; // eax
  __int64 v108; // r12
  unsigned __int64 v109; // rdx
  unsigned __int64 v110; // rsi
  int v111; // eax
  int v112; // eax
  __int64 v113; // rbx
  __int64 v114; // rbp
  char *v115; // rdx
  signed __int64 v116; // rax
  __int64 v117; // rsi
  __int64 v118; // rcx
  __int64 v119; // rsi
  __int64 v120; // rsi
  __int64 v121; // rax
  __int64 v122; // rdx
  __int64 v123; // rsi
  __int64 v124; // rdi
  __int64 v125; // rax
  __int64 v126; // rax
  __int64 v127; // rcx
  __int64 v128; // rax
  unsigned __int64 v129; // rax
  int v130; // eax
  __int64 v131; // r12
  size_t v132; // rcx
  __int64 v133; // rcx
  unsigned __int64 v134; // rdx
  int v135; // eax
  bool v136; // zf
  unsigned __int64 v137; // rcx
  int v138; // edx
  size_t v139; // rbp
  __int64 v140; // rcx
  size_t v141; // rdx
  int v142; // eax
  __time_t v143; // rcx
  struct timeval *v144; // rax
  int v145; // eax
  int v146; // eax
  __int64 v147; // rdx
  __int64 v148; // r9
  signed __int64 v149; // rax
  int v150; // r8d
  char *v151; // rbp
  __int64 v152; // rsi
  __int64 v153; // rcx
  __int64 v154; // rcx
  __int64 v155; // rcx
  __int64 v156; // rcx
  __int64 v157; // rcx
  __time_t v158; // rbp
  __int64 v159; // rcx
  __int64 v160; // rax
  __int64 v161; // rdx
  __int64 v162; // rbx
  int v163; // ebx
  int v164; // ecx
  __int64 v165; // rax
  char *v166; // rdx
  __int64 v167; // rsi
  __int64 v168; // rbp
  __int64 v169; // rbp
  __int64 v170; // rcx
  int v171; // eax
  _DWORD *v172; // rdi
  unsigned int v173; // eax
  unsigned int v174; // eax
  int v175; // ebx
  const char *v176; // rbp
  const char *v177; // rax
  FILE *v178; // rbp
  const char *v179; // r14
  const char *v180; // r15
  const char *v181; // rax
  const char *v182; // rbx
  size_t v183; // rax
  int v185; // [rsp+0h] [rbp-3C08h]
  int v186; // [rsp+8h] [rbp-3C00h]
  const char *v187; // [rsp+8h] [rbp-3C00h]
  int v188; // [rsp+14h] [rbp-3BF4h]
  char v189; // [rsp+14h] [rbp-3BF4h]
  FILE *stream; // [rsp+18h] [rbp-3BF0h]
  FILE *streama; // [rsp+18h] [rbp-3BF0h]
  struct timeval pai; // [rsp+20h] [rbp-3BE8h] BYREF
  __int64 v193; // [rsp+30h] [rbp-3BD8h] BYREF
  __int64 v194; // [rsp+38h] [rbp-3BD0h] BYREF
  __int128 dest[8]; // [rsp+40h] [rbp-3BC8h] BYREF
  __int128 v196[8]; // [rsp+C0h] [rbp-3B48h] BYREF
  struct addrinfo s[208]; // [rsp+140h] [rbp-3AC8h] BYREF
  struct iovec service; // [rsp+2850h] [rbp-13B8h] BYREF
  __int64 v199; // [rsp+2860h] [rbp-13A8h]
  unsigned __int64 v200; // [rsp+2868h] [rbp-13A0h]

  v4 = *argv;
  argv0 = (__int64)v4;
  v5 = strrchr(v4, 47);
  v6 = v5 + 1;
  if ( !v5 )
    v6 = v4;
  openlog(v6, 9, 24);
  debug = 0;
  port = 80;
  dir = 0LL;
  data_dir = 0LL;
  do_chroot = 0;
  no_log = 0;
  no_symlink_check = 0;
  do_vhost = 0;
  do_global_passwd = 0;
  cgi_pattern = 0LL;
  cgi_limit = 0;
  url_pattern = 0LL;
  no_empty_referrers = 0;
  local_pattern = 0LL;
  throttlefile = 0LL;
  hostname = 0LL;
  logfile = 0LL;
  pidfile = 0LL;
  user = "nobody";
  charset = "UTF-8";
  p3p = (char *)"";
  max_age = -1;
  v7 = 1;
  v186 = argc;
  if ( argc >= 2 )
  {
    v8 = 1;
    v9 = 0x100002600LL;
    while ( 1 )
    {
      v11 = argv[v8];
      if ( *v11 != 45 )
      {
        v7 = v8;
        goto LABEL_169;
      }
      if ( !strcmp(argv[v8], "-V") )
      {
        puts("thttpd/2.29 23May2018");
        exit(0);
      }
      if ( strcmp(v11, "-C") || v8 + 1 >= v186 )
        break;
      v188 = v8 + 1;
      v12 = argv[v8 + 1];
      v13 = fopen(v12, "r");
      if ( !v13 )
        goto LABEL_472;
      v14 = v13;
      stream = v13;
      if ( fgets((char *)s, 10000, v13) )
      {
        while ( 1 )
        {
          v15 = strchr((const char *)s, 35);
          if ( v15 )
            *v15 = 0;
          v16 = strspn((const char *)s, " \t\n\r");
          if ( *((_BYTE *)&s[0].ai_flags + v16) )
            break;
LABEL_16:
          v14 = stream;
          if ( !fgets((char *)s, 10000, stream) )
            goto LABEL_15;
        }
        v17 = (char *)s + v16;
        while ( 2 )
        {
          for ( i = &v17[strcspn(v17, " \t\n\r")]; ; ++i )
          {
            v19 = *(unsigned __int8 *)i;
            if ( v19 > 0x20 || !_bittest64(&v9, v19) )
              break;
            *i = 0;
          }
          v20 = strchr(v17, 61);
          if ( v20 )
          {
            v21 = v20;
            *v20 = 0;
            if ( !strcasecmp(v17, "debug") )
              goto LABEL_273;
            v22 = v21 + 1;
            if ( !strcasecmp(v17, "port") )
            {
              port = strtol(v22, 0LL, 10);
            }
            else
            {
              if ( !strcasecmp(v17, "dir") )
              {
                v24 = strdup(v22);
                if ( !v24 )
                  goto LABEL_284;
                dir = v24;
                goto LABEL_22;
              }
              if ( !strcasecmp(v17, "chroot") || !strcasecmp(v17, "nochroot") )
              {
LABEL_273:
                fprintf(stderr, "%s: no value required for %s option\n", argv0, v17);
                goto LABEL_280;
              }
              if ( !strcasecmp(v17, "data_dir") )
              {
                v25 = strdup(v22);
                if ( !v25 )
                  goto LABEL_284;
                data_dir = v25;
                goto LABEL_22;
              }
              if ( !strcasecmp(v17, "nosymlinkcheck") || !strcasecmp(v17, "symlinkcheck") )
                goto LABEL_273;
              if ( !strcasecmp(v17, "user") )
              {
                v26 = strdup(v22);
                if ( !v26 )
                  goto LABEL_284;
                user = v26;
                goto LABEL_22;
              }
              if ( !strcasecmp(v17, "cgipat") )
              {
                v27 = strdup(v22);
                if ( !v27 )
                  goto LABEL_284;
                cgi_pattern = (__int64)v27;
                goto LABEL_22;
              }
              if ( strcasecmp(v17, "cgilimit") )
              {
                if ( !strcasecmp(v17, "urlpat") )
                {
                  v23 = strdup(v22);
                  if ( !v23 )
                    goto LABEL_284;
                  url_pattern = v23;
                  goto LABEL_22;
                }
LABEL_55:
                if ( !strcasecmp(v17, "noemptyreferers") || !strcasecmp(v17, "noemptyreferrers") )
                {
                  if ( v22 )
                    goto LABEL_273;
                  no_empty_referrers = 1;
                }
                else if ( !strcasecmp(v17, "localpat") )
                {
                  if ( !v22 )
                    goto LABEL_279;
                  v28 = strdup(v22);
                  if ( !v28 )
                    goto LABEL_284;
                  local_pattern = v28;
                }
                else if ( !strcasecmp(v17, "throttles") )
                {
                  if ( !v22 )
                    goto LABEL_279;
                  v29 = strdup(v22);
                  if ( !v29 )
                    goto LABEL_284;
                  throttlefile = v29;
                }
                else if ( !strcasecmp(v17, "host") )
                {
                  if ( !v22 )
                    goto LABEL_279;
                  v30 = strdup(v22);
                  if ( !v30 )
                    goto LABEL_284;
                  hostname = v30;
                }
                else if ( !strcasecmp(v17, "logfile") )
                {
                  if ( !v22 )
                    goto LABEL_279;
                  v31 = strdup(v22);
                  if ( !v31 )
                    goto LABEL_284;
                  logfile = v31;
                }
                else if ( !strcasecmp(v17, "vhost") )
                {
                  if ( v22 )
                    goto LABEL_273;
                  do_vhost = 1;
                }
                else if ( !strcasecmp(v17, "novhost") )
                {
                  if ( v22 )
                    goto LABEL_273;
                  do_vhost = 0;
                }
                else if ( !strcasecmp(v17, "globalpasswd") )
                {
                  if ( v22 )
                    goto LABEL_273;
                  do_global_passwd = 1;
                }
                else if ( !strcasecmp(v17, "noglobalpasswd") )
                {
                  if ( v22 )
                    goto LABEL_273;
                  do_global_passwd = 0;
                }
                else if ( !strcasecmp(v17, "pidfile") )
                {
                  if ( !v22 )
                    goto LABEL_279;
                  v32 = strdup(v22);
                  if ( !v32 )
                    goto LABEL_284;
                  pidfile = v32;
                }
                else if ( !strcasecmp(v17, "charset") )
                {
                  if ( !v22 )
                    goto LABEL_279;
                  v33 = strdup(v22);
                  if ( !v33 )
                    goto LABEL_284;
                  charset = v33;
                }
                else if ( !strcasecmp(v17, "p3p") )
                {
                  if ( !v22 )
                    goto LABEL_279;
                  v34 = strdup(v22);
                  if ( !v34 )
                  {
LABEL_284:
                    syslog(2, "out of memory copying a string");
                    fprintf(stderr, "%s: out of memory copying a string\n", argv0);
                    goto LABEL_285;
                  }
                  p3p = v34;
                }
                else
                {
                  if ( strcasecmp(v17, "max_age") )
                  {
                    fprintf(stderr, "%s: unknown config option '%s'\n", argv0, v17);
LABEL_280:
                    exit(1);
                  }
                  if ( !v22 )
                    goto LABEL_279;
                  max_age = strtol(v22, 0LL, 10);
                }
                goto LABEL_22;
              }
              cgi_limit = strtol(v22, 0LL, 10);
            }
LABEL_22:
            v17 = &i[strspn(i, " \t\n\r")];
            if ( !*v17 )
              goto LABEL_16;
            continue;
          }
          break;
        }
        if ( !strcasecmp(v17, "debug") )
        {
          debug = 1;
          goto LABEL_22;
        }
        if ( !strcasecmp(v17, "port") || !strcasecmp(v17, "dir") )
        {
LABEL_279:
          fprintf(stderr, "%s: value required for %s option\n", argv0, v17);
          goto LABEL_280;
        }
        if ( !strcasecmp(v17, "chroot") )
        {
          do_chroot = 1;
          no_symlink_check = 1;
          goto LABEL_22;
        }
        if ( !strcasecmp(v17, "nochroot") )
        {
          do_chroot = 0;
        }
        else
        {
          if ( !strcasecmp(v17, "data_dir") )
            goto LABEL_279;
          if ( !strcasecmp(v17, "nosymlinkcheck") )
          {
            no_symlink_check = 1;
            goto LABEL_22;
          }
          if ( strcasecmp(v17, "symlinkcheck") )
          {
            if ( !strcasecmp(v17, "user")
              || !strcasecmp(v17, "cgipat")
              || !strcasecmp(v17, "cgilimit")
              || !strcasecmp(v17, "urlpat") )
            {
              goto LABEL_279;
            }
            v22 = 0LL;
            goto LABEL_55;
          }
        }
        no_symlink_check = 0;
        goto LABEL_22;
      }
LABEL_15:
      fclose(v14);
      v10 = v188;
LABEL_8:
      v7 = v10 + 1;
      v8 = v7;
      if ( v7 >= v186 )
        goto LABEL_169;
    }
    if ( !strcmp(v11, "-p") && v8 + 1 < v186 )
    {
      v35 = strtol(argv[v8 + 1], 0LL, 10);
      v10 = v8 + 1;
      port = v35;
      goto LABEL_8;
    }
    if ( !strcmp(v11, "-d") )
    {
      v10 = v8 + 1;
      if ( v8 + 1 < v186 )
      {
        dir = (char *)argv[v10];
        goto LABEL_8;
      }
    }
    if ( strcmp(v11, "-r") )
    {
      if ( !strcmp(v11, "-nor") )
      {
        do_chroot = 0;
      }
      else
      {
        if ( !strcmp(v11, "-dd") )
        {
          v10 = v8 + 1;
          if ( v8 + 1 < v186 )
          {
            data_dir = (char *)argv[v10];
            goto LABEL_8;
          }
        }
        if ( strcmp(v11, "-s") )
        {
          if ( strcmp(v11, "-nos") )
          {
            if ( !strcmp(v11, "-u") )
            {
              v10 = v8 + 1;
              if ( v8 + 1 < v186 )
              {
                user = (char *)argv[v10];
                goto LABEL_8;
              }
            }
            if ( !strcmp(v11, "-c") )
            {
              v10 = v8 + 1;
              if ( v8 + 1 < v186 )
              {
                cgi_pattern = (__int64)argv[v10];
                goto LABEL_8;
              }
            }
            if ( !strcmp(v11, "-t") )
            {
              v10 = v8 + 1;
              if ( v8 + 1 < v186 )
              {
                throttlefile = (char *)argv[v10];
                goto LABEL_8;
              }
            }
            if ( !strcmp(v11, "-h") )
            {
              v10 = v8 + 1;
              if ( v8 + 1 < v186 )
              {
                hostname = (char *)argv[v10];
                goto LABEL_8;
              }
            }
            if ( !strcmp(v11, "-l") )
            {
              v10 = v8 + 1;
              if ( v8 + 1 < v186 )
              {
                logfile = (char *)argv[v10];
                goto LABEL_8;
              }
            }
            if ( !strcmp(v11, "-v") )
            {
              do_vhost = 1;
            }
            else if ( !strcmp(v11, "-nov") )
            {
              do_vhost = 0;
            }
            else if ( !strcmp(v11, "-g") )
            {
              do_global_passwd = 1;
            }
            else if ( !strcmp(v11, "-nog") )
            {
              do_global_passwd = 0;
            }
            else
            {
              if ( !strcmp(v11, "-i") )
              {
                v10 = v8 + 1;
                if ( v8 + 1 < v186 )
                {
                  pidfile = (char *)argv[v10];
                  goto LABEL_8;
                }
              }
              if ( !strcmp(v11, "-T") )
              {
                v10 = v8 + 1;
                if ( v8 + 1 < v186 )
                {
                  charset = (char *)argv[v10];
                  goto LABEL_8;
                }
              }
              if ( !strcmp(v11, "-P") )
              {
                v10 = v8 + 1;
                if ( v8 + 1 < v186 )
                {
                  p3p = (char *)argv[v10];
                  goto LABEL_8;
                }
              }
              if ( !strcmp(v11, "-M") && v8 + 1 < v186 )
              {
                v36 = strtol(argv[v8 + 1], 0LL, 10);
                v10 = v8 + 1;
                max_age = v36;
                goto LABEL_8;
              }
              if ( strcmp(v11, "-D") )
                usage();
              debug = 1;
            }
            goto LABEL_7;
          }
          goto LABEL_128;
        }
      }
      no_symlink_check = 0;
LABEL_7:
      v10 = v8;
      goto LABEL_8;
    }
    do_chroot = 1;
LABEL_128:
    no_symlink_check = 1;
    goto LABEL_7;
  }
LABEL_169:
  if ( v7 != v186 )
  {
    fprintf(
      stderr,
      "usage:  %s [-C configfile] [-p port] [-d dir] [-r|-nor] [-dd data_dir] [-s|-nos] [-v|-nov] [-g|-nog] [-u user] [-c"
      " cgipat] [-t throttles] [-h host] [-l logfile] [-i pidfile] [-T charset] [-P P3P] [-M maxage] [-V] [-D]\n",
      argv0);
LABEL_285:
    exit(1);
  }
  tzset();
  memset(s, 0, 48);
  s[0].ai_flags = 1;
  s[0].ai_socktype = 1;
  v37 = 0;
  snprintf((char *)&service, 0xAuLL, "%d", (unsigned __int16)port);
  v38 = getaddrinfo(hostname, (const char *)&service, s, (struct addrinfo **)&pai);
  if ( v38 )
  {
    v175 = v38;
    v176 = hostname;
    v177 = gai_strerror(v38);
    syslog(2, "getaddrinfo %.80s - %.80s", v176, v177);
    v178 = stderr;
    v179 = (const char *)argv0;
    v180 = hostname;
    v181 = gai_strerror(v175);
    fprintf(v178, "%s: getaddrinfo %s - %s\n", v179, v180, v181);
    exit(1);
  }
  tv_sec = (struct addrinfo *)pai.tv_sec;
  if ( !pai.tv_sec )
    goto LABEL_185;
  v40 = 0LL;
  v41 = pai.tv_sec;
  v42 = 0LL;
  do
  {
    v43 = *(_DWORD *)(v41 + 4);
    if ( v43 == 2 )
    {
      if ( !v40 )
        v40 = v41;
    }
    else if ( v43 == 10 && !v42 )
    {
      v42 = v41;
    }
    v41 = *(_QWORD *)(v41 + 40);
  }
  while ( v41 );
  v37 = 0;
  if ( v42 )
  {
    v44 = *(unsigned int *)(v42 + 16);
    if ( v44 >= 0x81 )
      goto LABEL_470;
    memset(dest, 0, sizeof(dest));
    memmove(dest, *(const void **)(v42 + 24), *(unsigned int *)(v42 + 16));
    v37 = 1;
  }
  if ( !v40 )
  {
LABEL_185:
    freeaddrinfo(tv_sec);
    v189 = 1;
    if ( !v37 )
    {
      syslog(3, "can't find any valid address");
      fprintf(stderr, "%s: can't find any valid address\n", argv0);
      goto LABEL_285;
    }
    goto LABEL_189;
  }
  v44 = *(unsigned int *)(v40 + 16);
  if ( v44 < 0x81 )
  {
    memset(v196, 0, sizeof(v196));
    memmove(v196, *(const void **)(v40 + 24), *(unsigned int *)(v40 + 16));
    freeaddrinfo(tv_sec);
    v189 = 0;
LABEL_189:
    numthrottles = 0;
    maxthrottles = 0;
    throttles = 0LL;
    if ( !throttlefile )
    {
LABEL_193:
      pw_gid = 0x7FFF;
      pw_uid = 0x7FFF;
      if ( !getuid() )
      {
        v49 = getpwnam(user);
        if ( !v49 )
        {
          syslog(2, "unknown user - '%.80s'", user);
          fprintf(stderr, "%s: unknown user - '%s'\n", argv0, user);
          goto LABEL_280;
        }
        pw_uid = v49->pw_uid;
        pw_gid = v49->pw_gid;
      }
      v50 = logfile;
      if ( logfile )
      {
        if ( !strcmp(logfile, "/dev/null") )
        {
          no_log = 1;
          v52 = 0LL;
        }
        else if ( !strcmp(v50, "-") )
        {
          v52 = stdout;
        }
        else
        {
          v51 = fopen(v50, "a");
          if ( !v51 )
          {
            syslog(2, "%.80s - %m", logfile);
            v55 = logfile;
            goto LABEL_208;
          }
          v52 = v51;
          if ( *logfile != 47 )
          {
            syslog(4, "logfile is not an absolute path, you may not be able to re-open it", logfile);
            fprintf(
              stderr,
              "%s: logfile is not an absolute path, you may not be able to re-open it\n",
              (const char *)argv0);
          }
          v53 = fileno(v52);
          fcntl(v53, 2, 1LL);
          if ( !getuid() )
          {
            v54 = fileno(v52);
            if ( fchown(v54, pw_uid, pw_gid) < 0 )
            {
              syslog(4, "fchown logfile - %m");
              perror("fchown logfile");
            }
          }
        }
      }
      else
      {
        v52 = 0LL;
      }
      if ( dir && chdir(dir) < 0 )
      {
        syslog(2, "chdir - %m");
        v55 = "chdir";
        goto LABEL_208;
      }
      getcwd((char *)s, 0x1000uLL);
      if ( *((_BYTE *)s + strlen((const char *)s) - 1) != 47 )
        *(_WORD *)((char *)&s[0].ai_flags + strlen((const char *)s)) = 47;
      if ( debug )
      {
        setsid();
      }
      else
      {
        fclose(stdin);
        if ( v52 != stdout )
          fclose(stdout);
        fclose(stderr);
        if ( daemon(1, 1) < 0 )
        {
          syslog(2, "daemon - %m");
          goto LABEL_250;
        }
      }
      if ( pidfile )
      {
        v56 = fopen(pidfile, "w");
        if ( !v56 )
        {
          syslog(2, "%.80s - %m", pidfile);
          goto LABEL_268;
        }
        v75 = v56;
        v76 = getpid();
        fprintf(v75, "%d\n", v76);
        fclose(v75);
      }
      nfiles = fdwatch_get_nfiles();
      max_connects = nfiles;
      if ( nfiles < 0 )
      {
        syslog(2, "fdwatch initialization failure");
        goto LABEL_250;
      }
      max_connects = nfiles - 10;
      if ( do_chroot != 1 )
        goto LABEL_261;
      if ( chroot((const char *)s) < 0 )
      {
        syslog(2, "chroot - %m");
        v55 = "chroot";
        goto LABEL_208;
      }
      v185 = v37;
      v78 = logfile;
      if ( logfile && strcmp(logfile, "-") )
      {
        v79 = strlen((const char *)s);
        if ( !strncmp(v78, (const char *)s, v79) )
        {
          v182 = &v78[v79 - 1];
          v183 = strlen(v182);
          memmove(v78, v182, v183 + 1);
        }
        else
        {
          syslog(4, "logfile is not within the chroot tree, you will not be able to re-open it");
          fprintf(
            stderr,
            "%s: logfile is not within the chroot tree, you will not be able to re-open it\n",
            (const char *)argv0);
        }
      }
      strcpy((char *)s, "/");
      v37 = v185;
      if ( chdir((const char *)s) < 0 )
      {
        syslog(2, "chroot chdir - %m");
        v55 = "chroot chdir";
      }
      else
      {
LABEL_261:
        if ( !data_dir || chdir(data_dir) >= 0 )
        {
          sigset(15, (__sighandler_t)handle_term);
          sigset(2, (__sighandler_t)handle_term);
          sigset(17, (__sighandler_t)handle_chld);
          sigset(13, (__sighandler_t)((char *)&dword_0 + 1));
          sigset(1, (__sighandler_t)handle_hup);
          sigset(10, (__sighandler_t)handle_usr1);
          sigset(12, (__sighandler_t)handle_usr2);
          sigset(14, (__sighandler_t)handle_alrm);
          got_hup = 0;
          got_usr1 = 0;
          watchdog_flag = 0;
          alarm(0x168u);
          tmr_init();
          v80 = (struct sockaddr *)v196;
          if ( v189 )
            v80 = 0LL;
          v81 = (struct sockaddr *)dest;
          if ( !v37 )
            v81 = 0LL;
          hs = httpd_initialize(
                 hostname,
                 v80,
                 v81,
                 port,
                 (_BYTE *)cgi_pattern,
                 cgi_limit,
                 charset,
                 p3p,
                 max_age,
                 (char *)s,
                 (unsigned __int8)no_log,
                 (__int64)v52,
                 (unsigned __int8)no_symlink_check,
                 (unsigned __int8)do_vhost,
                 (unsigned __int8)do_global_passwd,
                 url_pattern,
                 local_pattern,
                 (unsigned __int8)no_empty_referrers);
          if ( hs )
          {
            if ( !tmr_create(0LL, (__time_t)occasional, JunkClientData, 120000LL, 1) )
            {
              syslog(2, "tmr_create(occasional) failed");
              goto LABEL_250;
            }
            if ( !tmr_create(0LL, (__time_t)idle, JunkClientData, 5000LL, 1) )
            {
              syslog(2, "tmr_create(idle) failed");
              goto LABEL_250;
            }
            if ( numthrottles > 0 && !tmr_create(0LL, (__time_t)update_throttles, JunkClientData, 2000LL, 1) )
            {
              syslog(2, "tmr_create(update_throttles) failed");
              goto LABEL_250;
            }
            if ( !tmr_create(0LL, (__time_t)show_stats, JunkClientData, 3600000LL, 1) )
            {
              syslog(2, "tmr_create(show_stats) failed");
              goto LABEL_250;
            }
            stats_time = time(0LL);
            start_time = stats_time;
            stats_connections = 0LL;
            stats_bytes = 0LL;
            stats_simultaneous = 0;
            if ( !getuid() )
            {
              if ( setgroups(0LL, 0LL) < 0 )
              {
                syslog(2, "setgroups - %m");
                goto LABEL_250;
              }
              if ( setgid(pw_gid) < 0 )
              {
                syslog(2, "setgid - %m");
                goto LABEL_250;
              }
              if ( initgroups(user, pw_gid) < 0 )
                syslog(4, "initgroups - %m");
              if ( setuid(pw_uid) < 0 )
              {
                syslog(2, "setuid - %m");
                goto LABEL_250;
              }
              if ( !do_chroot )
                syslog(4, "started as root without requesting chroot(), warning only");
            }
            v82 = max_connects;
            v83 = max_connects;
            v84 = malloc(144LL * max_connects);
            connects = v84;
            if ( !v84 )
            {
              syslog(2, "out of memory allocating a connecttab");
              goto LABEL_250;
            }
            if ( v82 > 0 )
            {
              if ( v82 == 1 )
              {
                v85 = 0LL;
              }
              else
              {
                v86 = v84 + 19;
                v85 = 0LL;
                do
                {
                  *((_DWORD *)v86 - 38) = 0;
                  *((_DWORD *)v86 - 37) = v85 + 1;
                  *(v86 - 18) = 0LL;
                  *((_DWORD *)v86 - 2) = 0;
                  v85 += 2LL;
                  *((_DWORD *)v86 - 1) = v85;
                  *v86 = 0LL;
                  v86 += 36;
                }
                while ( (v82 & 0xFFFFFFFE) != v85 );
              }
              if ( (v82 & 1) != 0 )
              {
                v87 = 18 * v85;
                LODWORD(v84[v87]) = 0;
                HIDWORD(v84[v87]) = v85 + 1;
                v84[v87 + 1] = 0LL;
              }
            }
            *((_DWORD *)&v84[18 * v83 - 17] - 1) = -1;
            first_free_connect = 0;
            num_connects = 0;
            httpd_conn_count = 0;
            v88 = hs;
            if ( hs )
            {
              v89 = *((_DWORD *)hs + 18);
              if ( v89 != -1 )
              {
                fdwatch_add_fd(v89, 0LL, 0);
                v88 = hs;
              }
              v90 = v88[19];
              if ( v90 != -1 )
                fdwatch_add_fd(v90, 0LL, 0);
            }
            gettimeofday(&pai, 0LL);
            while ( !terminate || num_connects > 0 )
            {
              if ( got_hup )
              {
                if ( !no_log && hs && logfile && strcmp(logfile, "-") )
                {
                  syslog(5, "re-opening logfile");
                  v91 = fopen(logfile, "a");
                  if ( v91 )
                  {
                    v92 = (__int64)v91;
                    v93 = fileno(v91);
                    fcntl(v93, 2, 1LL);
                    httpd_set_logfp((__int64)hs, v92);
                  }
                  else
                  {
                    syslog(2, "re-opening %.80s - %m", logfile);
                  }
                }
                got_hup = 0;
              }
              v94 = tmr_mstimeout(&pai);
              v95 = fdwatch(v94);
              if ( v95 < 0 )
              {
                v171 = *__errno_location();
                if ( v171 != 11 && v171 != 4 )
                {
                  syslog(3, "fdwatch - %m");
                  goto LABEL_250;
                }
              }
              else
              {
                v96 = v95;
                gettimeofday(&pai, 0LL);
                if ( !v96 )
                {
                  tmr_run((__int64)&pai);
                  continue;
                }
                if ( !hs
                  || ((v97 = *((_DWORD *)hs + 19), v97 == -1)
                   || !(unsigned int)fdwatch_check_fd(v97)
                   || !(unsigned int)handle_newconnect(&pai, *((_DWORD *)hs + 19)))
                  && (!hs
                   || (v98 = *((_DWORD *)hs + 18), v98 == -1)
                   || !(unsigned int)fdwatch_check_fd(v98)
                   || !(unsigned int)handle_newconnect(&pai, *((_DWORD *)hs + 18))) )
                {
                  while ( 1 )
                  {
                    do
LABEL_335:
                      next_client_data = fdwatch_get_next_client_data();
                    while ( !next_client_data );
                    v106 = next_client_data;
                    if ( next_client_data == -1 )
                      break;
                    if ( !(unsigned int)fdwatch_check_fd(*(_DWORD *)(*(_QWORD *)(next_client_data + 8) + 704LL)) )
                      goto LABEL_334;
                    v107 = *(_DWORD *)v106;
                    if ( *(_DWORD *)v106 == 4 )
                    {
                      v130 = read(*(_DWORD *)(*(_QWORD *)(v106 + 8) + 704LL), &service, 0x1000uLL);
                      if ( v130 < 0 )
                      {
                        v145 = *__errno_location();
                        if ( v145 == 4 || v145 == 11 )
                          goto LABEL_335;
                      }
                      else if ( v130 )
                      {
                        goto LABEL_335;
                      }
                      really_clear_connection(v106, &pai.tv_sec);
                      goto LABEL_335;
                    }
                    if ( v107 != 2 )
                    {
                      if ( v107 != 1 )
                        goto LABEL_335;
                      v108 = *(_QWORD *)(v106 + 8);
                      v109 = *(_QWORD *)(v108 + 152);
                      v110 = *(_QWORD *)(v108 + 160);
                      if ( v110 >= v109 )
                      {
                        if ( v109 >= 0x1389 )
                          goto LABEL_330;
                        httpd_realloc_str((void **)(v108 + 144), (__int64 *)(v108 + 152), v109 + 1000);
                        v109 = *(_QWORD *)(v108 + 152);
                        v110 = *(_QWORD *)(v108 + 160);
                      }
                      v111 = read(*(_DWORD *)(v108 + 704), (void *)(*(_QWORD *)(v108 + 144) + v110), v109 - v110);
                      if ( !v111 )
                        goto LABEL_330;
                      if ( v111 < 0 )
                      {
                        v146 = *__errno_location();
                        if ( v146 == 4 || v146 == 11 )
                          goto LABEL_335;
LABEL_330:
                        v99 = *(const char **)&httpd_err400title;
                        v100 = httpd_err400form[0];
                        v101 = v108;
                        v102 = 400;
                        v103 = (char *)"";
                        goto LABEL_331;
                      }
                      *(_QWORD *)(v108 + 160) += v111;
                      *(_QWORD *)(v106 + 88) = pai.tv_sec;
                      v112 = httpd_got_request(v108);
                      if ( !v112 )
                        goto LABEL_335;
                      if ( v112 == 2 )
                        goto LABEL_330;
                      if ( (int)httpd_parse_request(v108) < 0 )
                        goto LABEL_332;
                      *(_DWORD *)(v106 + 56) = 0;
                      *(_OWORD *)(v106 + 64) = -1LL;
                      if ( numthrottles > 0 )
                      {
                        v113 = 1LL;
                        v114 = 0LL;
                        while ( 1 )
                        {
                          if ( (unsigned int)match(
                                               *(char **)((char *)throttles + v114),
                                               *(_BYTE **)(*(_QWORD *)(v106 + 8) + 240LL)) )
                          {
                            v115 = (char *)throttles;
                            v116 = *(_QWORD *)((char *)throttles + v114 + 8);
                            v117 = *(_QWORD *)((char *)throttles + v114 + 24);
                            if ( v117 > 2 * v116 || (v118 = *(_QWORD *)((char *)throttles + v114 + 16), v117 < v118) )
                            {
                              v99 = *(const char **)&httpd_err503title;
                              v100 = httpd_err503form;
                              v103 = *(char **)(v108 + 208);
                              v101 = v108;
                              v102 = 503;
LABEL_331:
                              httpd_send_err(v101, v102, v99, (char *)"", v100, v103);
LABEL_332:
                              v104 = *(_QWORD *)(v106 + 8);
LABEL_333:
                              httpd_write_response(v104);
LABEL_334:
                              clear_connection(v106, &pai);
                              goto LABEL_335;
                            }
                            if ( *(int *)((char *)throttles + v114 + 40) < 0 )
                            {
                              syslog(3, "throttle sending count was negative - shouldn't happen!");
                              v115 = (char *)throttles;
                              *(_DWORD *)((char *)throttles + v114 + 40) = 0;
                              v116 = *(_QWORD *)&v115[v114 + 8];
                              v118 = *(_QWORD *)&v115[v114 + 16];
                            }
                            v119 = *(int *)(v106 + 56);
                            *(_DWORD *)(v106 + 56) = v119 + 1;
                            *(_DWORD *)(v106 + 4 * v119 + 16) = v113 - 1;
                            v120 = *(int *)&v115[v114 + 40] + 1LL;
                            *(_DWORD *)&v115[v114 + 40] = v120;
                            if ( (v120 | (unsigned __int64)v116) >> 32 )
                              v121 = v116 / v120;
                            else
                              v121 = (unsigned int)v116 / (unsigned int)v120;
                            v122 = *(_QWORD *)(v106 + 64);
                            v123 = v121;
                            if ( v122 < v121 )
                              v123 = *(_QWORD *)(v106 + 64);
                            v124 = *(_QWORD *)(v106 + 72);
                            if ( v122 == -1 )
                              v123 = v121;
                            *(_QWORD *)(v106 + 64) = v123;
                            v125 = v118;
                            if ( v124 > v118 )
                              v125 = v124;
                            if ( v124 == -1 )
                              v125 = v118;
                            *(_QWORD *)(v106 + 72) = v125;
                          }
                          if ( v113 < numthrottles )
                          {
                            v114 += 48LL;
                            ++v113;
                            if ( *(int *)(v106 + 56) < 10 )
                              continue;
                          }
                          break;
                        }
                      }
                      if ( (int)httpd_start_request(v108, &pai.tv_sec) < 0 )
                        goto LABEL_332;
                      if ( *(_DWORD *)(v108 + 528) )
                      {
                        *(_QWORD *)(v106 + 136) = *(_QWORD *)(v108 + 536);
                        v126 = *(_QWORD *)(v108 + 544) + 1LL;
LABEL_435:
                        *(_QWORD *)(v106 + 128) = v126;
                        if ( !*(_QWORD *)(v108 + 712) )
                          goto LABEL_439;
                      }
                      else
                      {
                        v126 = *(_QWORD *)(v108 + 192);
                        if ( v126 >= 0 )
                          goto LABEL_435;
                        *(_QWORD *)(v106 + 128) = 0LL;
                        v126 = 0LL;
                        if ( !*(_QWORD *)(v108 + 712) )
                        {
LABEL_439:
                          v164 = *(_DWORD *)(v106 + 56);
                          v165 = *(_QWORD *)(v108 + 200);
                          if ( v164 > 0 )
                          {
                            v166 = (char *)throttles;
                            if ( v164 == 1 )
                            {
                              v167 = 0LL;
                            }
                            else
                            {
                              v167 = 0LL;
                              do
                              {
                                v168 = 48LL * *(int *)(v106 + 4 * v167 + 16);
                                *(_QWORD *)&v166[v168 + 32] += v165;
                                v169 = 48LL * *(int *)(v106 + 4 * v167 + 20);
                                *(_QWORD *)&v166[v169 + 32] += v165;
                                v167 += 2LL;
                              }
                              while ( (v164 & 0xFFFFFFFE) != v167 );
                            }
                            if ( (v164 & 1) != 0 )
                            {
                              v170 = 48LL * *(int *)(v106 + 4 * v167 + 16);
                              *(_QWORD *)&v166[v170 + 32] += v165;
                            }
                          }
                          *(_QWORD *)(v106 + 136) = v165;
                          goto LABEL_332;
                        }
                      }
                      if ( *(_QWORD *)(v106 + 136) >= v126 )
                        goto LABEL_332;
                      *(_DWORD *)v106 = 2;
                      *(_QWORD *)(v106 + 80) = pai.tv_sec;
                      *(_QWORD *)(v106 + 112) = 0LL;
                      fdwatch_del_fd(*(_DWORD *)(v108 + 704));
                      fdwatch_add_fd(*(_DWORD *)(v108 + 704), v106, 1);
                      goto LABEL_335;
                    }
                    v127 = *(_QWORD *)(v106 + 64);
                    if ( v127 == -1 )
                    {
                      v129 = 1000000000LL;
                    }
                    else
                    {
                      v128 = v127 + 3;
                      if ( v127 >= 0 )
                        v128 = *(_QWORD *)(v106 + 64);
                      v129 = v128 >> 2;
                    }
                    v131 = *(_QWORD *)(v106 + 8);
                    v132 = *(_QWORD *)(v131 + 472);
                    if ( v132 )
                    {
                      service.iov_base = *(void **)(v131 + 368);
                      service.iov_len = v132;
                      v133 = *(_QWORD *)(v106 + 136);
                      v199 = v133 + *(_QWORD *)(v131 + 712);
                      v134 = *(_QWORD *)(v106 + 128) - v133;
                      if ( v134 >= v129 )
                        v134 = v129;
                      v200 = v134;
                      v135 = writev(*(_DWORD *)(v131 + 704), &service, 2);
                      v136 = v135 == 0;
                      if ( v135 < 0 )
                        goto LABEL_392;
                    }
                    else
                    {
                      v140 = *(_QWORD *)(v106 + 136);
                      v141 = *(_QWORD *)(v106 + 128) - v140;
                      if ( v141 >= v129 )
                        v141 = v129;
                      v135 = write(*(_DWORD *)(v131 + 704), (const void *)(v140 + *(_QWORD *)(v131 + 712)), v141);
                      v136 = v135 == 0;
                      if ( v135 < 0 )
                      {
LABEL_392:
                        v142 = *__errno_location();
                        switch ( v142 )
                        {
                          case 4:
                            goto LABEL_335;
                          case 5:
                          case 6:
                          case 7:
                          case 8:
                          case 9:
                          case 10:
                          case 12:
                          case 13:
                          case 14:
                          case 15:
                          case 16:
                          case 17:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 23:
                          case 24:
                          case 25:
                          case 26:
                          case 27:
                          case 28:
                          case 29:
                          case 30:
                          case 31:
                            goto LABEL_423;
                          case 11:
                            goto LABEL_393;
                          case 22:
                          case 32:
                            goto LABEL_334;
                          default:
                            if ( v142 != 104 )
LABEL_423:
                              syslog(3, "write - %m sending %.80s", *(const char **)(v131 + 208));
                            break;
                        }
                        goto LABEL_334;
                      }
                    }
                    if ( v136 )
                    {
LABEL_393:
                      *(_QWORD *)(v106 + 112) += 100LL;
                      *(_DWORD *)v106 = 3;
                      fdwatch_del_fd(*(_DWORD *)(v131 + 704));
                      if ( *(_QWORD *)(v106 + 96) )
                        syslog(3, "replacing non-null wakeup_timer!");
                      v143 = *(_QWORD *)(v106 + 112);
                      goto LABEL_396;
                    }
                    *(_QWORD *)(v106 + 88) = pai.tv_sec;
                    v137 = *(_QWORD *)(v131 + 472);
                    if ( v137 )
                    {
                      v138 = v135 - v137;
                      if ( v135 >= v137 )
                      {
                        v139 = 0LL;
                      }
                      else
                      {
                        v139 = (int)v137 - v135;
                        memmove(*(void **)(v131 + 368), (const void *)(*(_QWORD *)(v131 + 368) + v135), v139);
                        v138 = 0;
                      }
                      *(_QWORD *)(v131 + 472) = v139;
                      v135 = v138;
                    }
                    v147 = v135;
                    v148 = v135 + *(_QWORD *)(v106 + 136);
                    *(_QWORD *)(v106 + 136) = v148;
                    v104 = *(_QWORD *)(v106 + 8);
                    v149 = v135 + *(_QWORD *)(v104 + 200);
                    *(_QWORD *)(v104 + 200) = v149;
                    v150 = *(_DWORD *)(v106 + 56);
                    if ( v150 > 0 )
                    {
                      v151 = (char *)throttles;
                      if ( v150 == 1 )
                      {
                        v152 = 0LL;
                      }
                      else
                      {
                        v152 = 0LL;
                        do
                        {
                          v153 = 48LL * *(int *)(v106 + 4 * v152 + 16);
                          *(_QWORD *)&v151[v153 + 32] += v147;
                          v154 = 48LL * *(int *)(v106 + 4 * v152 + 20);
                          *(_QWORD *)&v151[v154 + 32] += v147;
                          v152 += 2LL;
                        }
                        while ( (v150 & 0xFFFFFFFE) != v152 );
                      }
                      if ( (v150 & 1) != 0 )
                      {
                        v155 = 48LL * *(int *)(v106 + 4 * v152 + 16);
                        *(_QWORD *)&v151[v155 + 32] += v147;
                      }
                    }
                    if ( v148 >= *(_QWORD *)(v106 + 128) )
                      goto LABEL_333;
                    v156 = *(_QWORD *)(v106 + 112);
                    if ( v156 >= 101 )
                      *(_QWORD *)(v106 + 112) = v156 - 100;
                    v157 = *(_QWORD *)(v106 + 64);
                    if ( v157 != -1 )
                    {
                      v158 = pai.tv_sec - *(_QWORD *)(v106 + 80);
                      if ( pai.tv_sec == *(_QWORD *)(v106 + 80) )
                        v158 = 1LL;
                      if ( (v158 | (unsigned __int64)v149) >> 32 )
                      {
                        if ( v149 / v158 <= v157 )
                          goto LABEL_335;
                      }
                      else if ( (unsigned int)v149 / (unsigned int)v158 <= v157 )
                      {
                        goto LABEL_335;
                      }
                      *(_DWORD *)v106 = 3;
                      fdwatch_del_fd(*(_DWORD *)(v131 + 704));
                      v159 = *(_QWORD *)(v106 + 64);
                      v160 = *(_QWORD *)(*(_QWORD *)(v106 + 8) + 200LL);
                      if ( (v159 | (unsigned __int64)v160) >> 32 )
                      {
                        v161 = v160 % v159;
                        v162 = v160 / v159;
                      }
                      else
                      {
                        v161 = (unsigned int)v160 % (unsigned int)v159;
                        LODWORD(v162) = (unsigned int)v160 / (unsigned int)v159;
                      }
                      v163 = v162 - v158;
                      if ( *(_QWORD *)(v106 + 96) )
                        syslog(3, "replacing non-null wakeup_timer!", v161);
                      v143 = 1000LL * v163;
                      if ( v163 <= 0 )
                        v143 = 500LL;
LABEL_396:
                      v144 = tmr_create(&pai, (__time_t)wakeup_connection, v106, v143, 0);
                      *(_QWORD *)(v106 + 96) = v144;
                      if ( v144 )
                        goto LABEL_335;
                      syslog(2, "tmr_create(wakeup_connection) failed");
LABEL_250:
                      exit(1);
                    }
                  }
                  tmr_run((__int64)&pai);
                  if ( got_usr1 )
                  {
                    if ( !terminate )
                    {
                      terminate = 1;
                      v172 = hs;
                      if ( hs )
                      {
                        v173 = *((_DWORD *)hs + 18);
                        if ( v173 != -1 )
                        {
                          fdwatch_del_fd(v173);
                          v172 = hs;
                        }
                        v174 = v172[19];
                        if ( v174 != -1 )
                        {
                          fdwatch_del_fd(v174);
                          v172 = hs;
                        }
                        httpd_unlisten((__int64)v172);
                      }
                    }
                  }
                }
              }
            }
            shut_down();
            syslog(5, "exiting");
            closelog();
            exit(0);
          }
LABEL_268:
          exit(1);
        }
        syslog(2, "data_dir chdir - %m");
        v55 = "data_dir chdir";
      }
LABEL_208:
      perror(v55);
      exit(1);
    }
    v187 = throttlefile;
    v45 = fopen(throttlefile, "r");
    if ( !v45 )
    {
      v12 = v187;
      syslog(2, "%.80s - %m", v187);
LABEL_472:
      v55 = v12;
      goto LABEL_208;
    }
    v46 = v45;
    gettimeofday(&pai, 0LL);
    if ( !fgets((char *)s, 5000, v46) )
    {
LABEL_192:
      fclose(v46);
      goto LABEL_193;
    }
    v57 = 0x100002600LL;
    streama = v46;
    while ( 1 )
    {
      v58 = strchr((const char *)s, 35);
      if ( v58 )
        *v58 = 0;
      v59 = strlen((const char *)s);
      if ( v59 <= 0 )
      {
        if ( !v59 )
          goto LABEL_222;
      }
      else
      {
        v60 = (unsigned int)v59 + 1LL;
        while ( 1 )
        {
          v61 = *((unsigned __int8 *)&s[0].ai_flags + (unsigned int)(v60 - 2));
          if ( v61 > 0x20 || !_bittest64(&v57, v61) )
            break;
          *((_BYTE *)&s[0].ai_flags + (unsigned int)(v60 - 2)) = 0;
          v62 = v60-- == 1;
          if ( v62 || v60 == 1 )
            goto LABEL_222;
        }
      }
      if ( (unsigned int)__isoc99_sscanf(s, " %4900[^ \t] %ld-%ld", &service, &v193, &v194) != 3 )
      {
        if ( (unsigned int)__isoc99_sscanf(s, " %4900[^ \t] %ld", &service, &v194) != 2 )
        {
          syslog(2, "unparsable line in %.80s - %.80s", v187, (const char *)s);
          fprintf(stderr, "%s: unparsable line in %.80s - %.80s\n", (const char *)argv0, v187, (const char *)s);
          goto LABEL_222;
        }
        v193 = 0LL;
      }
      if ( LOBYTE(service.iov_base) == 47 )
      {
        v63 = strlen((const char *)&service.iov_base + 1);
        memmove(&service, (char *)&service.iov_base + 1, v63 + 1);
      }
      v64 = strstr((const char *)&service, "|/");
      if ( v64 )
      {
        v65 = v64;
        do
        {
          v66 = v65 + 1;
          v67 = v65 + 2;
          v68 = strlen(v67);
          memmove(v66, v67, v68 + 1);
          v65 = strstr((const char *)&service, "|/");
        }
        while ( v65 );
      }
      v69 = numthrottles;
      v70 = maxthrottles;
      v46 = streama;
      if ( numthrottles >= maxthrottles )
      {
        if ( maxthrottles )
        {
          maxthrottles *= 2;
          v71 = realloc(throttles, 96 * v70);
        }
        else
        {
          maxthrottles = 100;
          v71 = malloc(0x12C0uLL);
        }
        throttles = v71;
        if ( !v71 )
        {
          syslog(2, "out of memory allocating a throttletab");
          fprintf(stderr, "%s: out of memory allocating a throttletab\n", argv0);
          goto LABEL_285;
        }
      }
      v72 = strdup((const char *)&service);
      if ( !v72 )
        goto LABEL_284;
      v73 = (char *)throttles;
      v74 = 48 * v69;
      *(_QWORD *)((char *)throttles + v74) = v72;
      *(_QWORD *)&v73[v74 + 8] = v194;
      *(_QWORD *)&v73[v74 + 16] = v193;
      *(_OWORD *)&v73[v74 + 24] = 0LL;
      *(_DWORD *)&v73[v74 + 40] = 0;
      numthrottles = v69 + 1;
LABEL_222:
      if ( !fgets((char *)s, 5000, v46) )
        goto LABEL_192;
    }
  }
LABEL_470:
  syslog(2, "%.80s - sockaddr too small (%lu < %lu)", hostname, 128LL, v44);
  exit(1);
}
// 0: using guessed type int dword_0;
// 5470: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);
// 8190: using guessed type __int64 __fastcall update_throttles();
// 193A8: using guessed type char *httpd_err400form[5];
// 193C8: using guessed type char *httpd_err503form;
// 1AEE8: using guessed type int terminate;
// 1AEF0: using guessed type __int64 argv0;
// 1AEF8: using guessed type int numthrottles;
// 1AEFC: using guessed type int maxthrottles;
// 1AF20: using guessed type char no_log;
// 1AF30: using guessed type char debug;
// 1AF40: using guessed type int max_connects;
// 1AF44: using guessed type char do_chroot;
// 1AF50: using guessed type int got_hup;
// 1AF54: using guessed type int got_usr1;
// 1AF58: using guessed type int watchdog_flag;
// 1AF68: using guessed type __int16 port;
// 1AF70: using guessed type __int64 cgi_pattern;
// 1AF78: using guessed type int cgi_limit;
// 1AF90: using guessed type int max_age;
// 1AF94: using guessed type char no_symlink_check;
// 1AF98: using guessed type char do_vhost;
// 1AF9C: using guessed type char do_global_passwd;
// 1AFB0: using guessed type char no_empty_referrers;
// 1AFC0: using guessed type __int64 stats_time;
// 1AFC8: using guessed type __int64 start_time;
// 1AFD0: using guessed type __int64 stats_connections;
// 1AFD8: using guessed type __int64 stats_bytes;
// 1AFE0: using guessed type int stats_simultaneous;
// 1AFF0: using guessed type int first_free_connect;
// 1AFF4: using guessed type int num_connects;
// 1AFF8: using guessed type int httpd_conn_count;

//----- (0000000000007E80) ----------------------------------------------------
void __fastcall __noreturn handle_term(unsigned int a1)
{
  shut_down();
  syslog(5, "exiting due to signal %d", a1);
  closelog();
  exit(1);
}

//----- (0000000000007EB0) ----------------------------------------------------
void __fastcall handle_chld()
{
  __int64 v0; // rax
  int *v1; // r14
  int v2; // r15d
  __pid_t v3; // eax
  int v4; // ecx
  int v5; // eax
  int stat_loc[9]; // [rsp+0h] [rbp-24h] BYREF

  stat_loc[0] = HIDWORD(v0);
  v1 = __errno_location();
  v2 = *v1;
  v3 = waitpid(-1, stat_loc, 1);
  if ( !v3 )
    goto LABEL_13;
  while ( 1 )
  {
    if ( v3 >= 0 )
    {
      if ( hs )
      {
        v4 = *((_DWORD *)hs + 9);
        if ( v4 <= 0 )
          v4 = 1;
        *((_DWORD *)hs + 9) = v4 - 1;
      }
      goto LABEL_3;
    }
    v5 = *v1;
    if ( *v1 != 4 && v5 != 11 )
      break;
LABEL_3:
    v3 = waitpid(-1, stat_loc, 1);
    if ( !v3 )
      goto LABEL_13;
  }
  if ( v5 != 10 )
    syslog(3, "child wait - %m");
LABEL_13:
  *v1 = v2;
}
// 7EB6: variable 'v0' is possibly undefined

//----- (0000000000007F70) ----------------------------------------------------
void handle_hup()
{
  got_hup = 1;
}
// 1AF50: using guessed type int got_hup;

//----- (0000000000007F80) ----------------------------------------------------
void handle_usr1()
{
  if ( !num_connects )
  {
    shut_down();
    syslog(5, "exiting");
    closelog();
    exit(0);
  }
  got_usr1 = 1;
}
// 1AF54: using guessed type int got_usr1;
// 1AFF4: using guessed type int num_connects;

//----- (0000000000007FC0) ----------------------------------------------------
void handle_usr2()
{
  int *v0; // rbx
  int v1; // ebp

  v0 = __errno_location();
  v1 = *v0;
  logstats(0LL);
  *v0 = v1;
}

//----- (0000000000007FE0) ----------------------------------------------------
void handle_alrm()
{
  int *v0; // rax
  int v1; // ebp
  int *v2; // rbx

  v0 = __errno_location();
  v1 = *v0;
  if ( !watchdog_flag )
  {
    chdir("/tmp");
    abort();
  }
  v2 = v0;
  watchdog_flag = 0;
  alarm(0x168u);
  *v2 = v1;
}
// 1AF58: using guessed type int watchdog_flag;

//----- (0000000000008030) ----------------------------------------------------
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm4,xmm5> occasional(__int64 a1, time_t *a2)
{
  mmc_cleanup(a2);
  tmr_cleanup();
  watchdog_flag = 1;
}
// 1AF58: using guessed type int watchdog_flag;

//----- (0000000000008050) ----------------------------------------------------
__int64 __fastcall idle(__int64 a1, struct timeval *a2)
{
  __int64 result; // rax
  __int64 v3; // r15
  __int64 v4; // rbp
  char *v5; // r14
  char *v6; // rbx
  int v7; // eax
  char *v8; // rax
  char *v9; // rax

  if ( max_connects > 0 )
  {
    v3 = 0LL;
    v4 = 0LL;
    do
    {
      v5 = (char *)connects;
      v6 = (char *)connects + v3;
      v7 = *(_DWORD *)((char *)connects + v3);
      if ( (unsigned int)(v7 - 2) >= 2 )
      {
        if ( v7 != 1 || a2->tv_sec - *(_QWORD *)((char *)connects + v3 + 88) < 60 )
          goto LABEL_4;
        v9 = httpd_ntoa(*(_QWORD *)((char *)connects + v3 + 8) + 16LL);
        syslog(6, "%.80s connection timed out reading", v9);
        httpd_send_err(
          *(_QWORD *)&v5[v3 + 8],
          0x198u,
          httpd_err408title[0],
          (char *)"",
          httpd_err408form[0],
          (char *)"");
        httpd_write_response(*(_QWORD *)&v5[v3 + 8]);
      }
      else
      {
        if ( a2->tv_sec - *(_QWORD *)((char *)connects + v3 + 88) < 300 )
          goto LABEL_4;
        v8 = httpd_ntoa(*(_QWORD *)((char *)connects + v3 + 8) + 16LL);
        syslog(6, "%.80s connection timed out sending", v8);
      }
      clear_connection((__int64)v6, a2);
LABEL_4:
      ++v4;
      result = max_connects;
      v3 += 144LL;
    }
    while ( v4 < max_connects );
  }
  return result;
}
// 193B0: using guessed type char *httpd_err408title[4];
// 193B8: using guessed type char *httpd_err408form[3];
// 1AF40: using guessed type int max_connects;

//----- (0000000000008190) ----------------------------------------------------
__int64 __fastcall update_throttles()
{
  __int64 result; // rax
  __int64 v1; // rbx
  char *v2; // rcx
  __int64 v3; // r13
  __int64 v4; // r9
  __int128 v5; // rax
  __int64 v6; // r8
  __int64 v7; // rcx
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r8
  _DWORD *v11; // r10
  char *v12; // rdi
  char *v13; // rbp
  __int64 v14; // r11
  __int64 v15; // r14
  __int64 *v16; // r9
  __int64 v17; // rsi
  __int64 i; // rbx
  __int64 v19; // rcx
  bool v20; // zf
  __int64 v21; // rcx
  signed __int64 v22; // rax
  __int64 v23; // rcx
  __int64 v24; // [rsp+0h] [rbp-38h]

  HIDWORD(v24) = HIDWORD(result);
  if ( numthrottles > 0 )
  {
    v1 = 40LL;
    v2 = (char *)throttles;
    v3 = 0LL;
    do
    {
      v4 = *(_QWORD *)&v2[v1 - 32];
      v5 = 0x5555555555555556LL * (__int128)(*(_QWORD *)&v2[v1 - 8] / 2LL + 2LL * *(_QWORD *)&v2[v1 - 16]);
      v6 = *((_QWORD *)&v5 + 1) + (*((_QWORD *)&v5 + 1) >> 63);
      *(_QWORD *)&v2[v1 - 16] = v6;
      *(_QWORD *)&v2[v1 - 8] = 0LL;
      if ( v6 > v4 && *(_DWORD *)&v2[v1] )
      {
        v7 = *(_QWORD *)&v2[v1 - 40];
        if ( v6 <= 2 * v4 )
          syslog(6, "throttle #%d '%.80s' rate %ld exceeding limit %ld; %d sending", (unsigned int)v3, v7);
        else
          syslog(5, "throttle #%d '%.80s' rate %ld greatly exceeding limit %ld; %d sending", (unsigned int)v3, v7);
      }
      v2 = (char *)throttles;
      v8 = *(_QWORD *)((char *)throttles + v1 - 24);
      v9 = *(_QWORD *)((char *)throttles + v1 - 16);
      if ( v9 < v8 && *(_DWORD *)((char *)throttles + v1) )
      {
        LODWORD(v24) = *(_DWORD *)((char *)throttles + v1);
        syslog(
          5,
          "throttle #%d '%.80s' rate %ld lower than minimum %ld; %d sending",
          (unsigned int)v3,
          *(const char **)((char *)throttles + v1 - 40),
          v9,
          v8,
          v24);
        v2 = (char *)throttles;
      }
      ++v3;
      result = numthrottles;
      v1 += 48LL;
    }
    while ( v3 < numthrottles );
  }
  v10 = (unsigned int)max_connects;
  if ( max_connects > 0 )
  {
    v11 = connects;
    v12 = (char *)throttles;
    v13 = (char *)connects + 16;
    v14 = 0LL;
    do
    {
      result = 144 * v14;
      if ( (v11[36 * v14] & 0xFFFFFFFE) == 2 )
      {
        *(_QWORD *)((char *)v11 + result + 64) = -1LL;
        v15 = *(unsigned int *)((char *)v11 + result + 56);
        if ( (int)v15 > 0 )
        {
          v16 = (__int64 *)((char *)v11 + result + 64);
          v17 = -1LL;
          for ( i = 0LL; i != v15; ++i )
          {
            v21 = 48LL * *(int *)&v13[4 * i];
            v22 = *(_QWORD *)&v12[v21 + 8];
            v23 = *(int *)&v12[v21 + 40];
            if ( (v23 | (unsigned __int64)v22) >> 32 )
              result = v22 / v23;
            else
              result = (unsigned int)v22 / (unsigned int)v23;
            v19 = result;
            if ( v17 < result )
              v19 = v17;
            v20 = v17 == -1;
            v17 = v19;
            if ( v20 )
              v17 = result;
          }
          *v16 = v17;
        }
      }
      ++v14;
      v13 += 144;
    }
    while ( v14 != v10 );
  }
  return result;
}
// 819A: variable 'result' is possibly undefined
// 82A9: variable 'v24' is possibly undefined
// 8190: using guessed type __int64 __fastcall update_throttles();
// 1AEF8: using guessed type int numthrottles;
// 1AF40: using guessed type int max_connects;

//----- (00000000000083B0) ----------------------------------------------------
void __fastcall show_stats(__int64 a1, struct timeval *a2)
{
  logstats(a2);
}

//----- (00000000000083C0) ----------------------------------------------------
__int64 __fastcall handle_newconnect(_QWORD *a1, int a2)
{
  char *v2; // rbp
  __int64 v3; // rbx
  char *v4; // r12
  _DWORD *v5; // rax
  int conn; // eax

  if ( num_connects < max_connects )
  {
    while ( first_free_connect != -1LL )
    {
      v2 = (char *)connects;
      v3 = 144LL * first_free_connect;
      if ( *(_DWORD *)((char *)connects + v3) )
        break;
      v4 = (char *)connects + v3 + 8;
      v5 = *(_DWORD **)v4;
      if ( !*(_QWORD *)v4 )
      {
        v5 = malloc(0x2D0uLL);
        *(_QWORD *)v4 = v5;
        if ( !v5 )
        {
          syslog(2, "out of memory allocating an httpd_conn");
LABEL_17:
          exit(1);
        }
        *v5 = 0;
        ++httpd_conn_count;
      }
      conn = httpd_get_conn((__int64)hs, a2, (__int64)v5);
      if ( !conn )
        goto LABEL_14;
      if ( conn == 2 )
        return 1LL;
      *(_DWORD *)&v2[v3] = 1;
      first_free_connect = *(_DWORD *)&v2[v3 + 4];
      *(_DWORD *)&v2[v3 + 4] = -1;
      ++num_connects;
      *(_QWORD *)&v2[v3 + 88] = *a1;
      *(_QWORD *)&v2[v3 + 136] = 0LL;
      *(_DWORD *)&v2[v3 + 56] = 0;
      *(_OWORD *)&v2[v3 + 96] = 0LL;
      httpd_set_ndelay(*(_DWORD *)(*(_QWORD *)v4 + 704LL));
      fdwatch_add_fd(*(_DWORD *)(*(_QWORD *)v4 + 704LL), (__int64)&v2[v3], 0);
      ++stats_connections;
      if ( num_connects > stats_simultaneous )
        stats_simultaneous = num_connects;
      if ( num_connects >= max_connects )
        goto LABEL_13;
    }
    syslog(2, "the connects free list is messed up");
    goto LABEL_17;
  }
LABEL_13:
  syslog(4, "too many connections!");
LABEL_14:
  tmr_run((__int64)a1);
  return 0LL;
}
// 1AF40: using guessed type int max_connects;
// 1AFD0: using guessed type __int64 stats_connections;
// 1AFE0: using guessed type int stats_simultaneous;
// 1AFF0: using guessed type int first_free_connect;
// 1AFF4: using guessed type int num_connects;
// 1AFF8: using guessed type int httpd_conn_count;

//----- (0000000000008570) ----------------------------------------------------
struct timeval *__fastcall clear_connection(__int64 a1, struct timeval *a2)
{
  __int64 v3; // rdi
  __int64 v4; // rax
  struct timeval *result; // rax

  v3 = *(_QWORD *)(a1 + 96);
  if ( v3 )
  {
    tmr_cancel(v3);
    *(_QWORD *)(a1 + 96) = 0LL;
  }
  if ( *(_DWORD *)a1 == 4 )
  {
    tmr_cancel(*(_QWORD *)(a1 + 104));
    *(_QWORD *)(a1 + 104) = 0LL;
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 556LL) = 0;
    return (struct timeval *)really_clear_connection(a1, &a2->tv_sec);
  }
  v4 = *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(v4 + 556) )
    return (struct timeval *)really_clear_connection(a1, &a2->tv_sec);
  if ( *(_DWORD *)a1 != 3 )
  {
    fdwatch_del_fd(*(_DWORD *)(v4 + 704));
    v4 = *(_QWORD *)(a1 + 8);
  }
  *(_DWORD *)a1 = 4;
  shutdown(*(_DWORD *)(v4 + 704), 1);
  fdwatch_add_fd(*(_DWORD *)(*(_QWORD *)(a1 + 8) + 704LL), a1, 0);
  if ( *(_QWORD *)(a1 + 104) )
    syslog(3, "replacing non-null linger_timer!");
  result = tmr_create(a2, (__time_t)linger_clear_connection, a1, 500LL, 0);
  *(_QWORD *)(a1 + 104) = result;
  if ( !result )
  {
    syslog(2, "tmr_create(linger_clear_connection) failed");
    exit(1);
  }
  return result;
}

//----- (0000000000008680) ----------------------------------------------------
void shut_down()
{
  __int64 v0; // rbx
  char *v1; // r12
  __int64 v2; // r15
  __int64 v3; // rdi
  _DWORD *v4; // rbx
  unsigned int v5; // edi
  unsigned int v6; // edi
  struct timeval tv; // [rsp+8h] [rbp-30h] BYREF

  gettimeofday(&tv, 0LL);
  logstats(&tv);
  if ( max_connects > 0 )
  {
    v0 = 8LL;
    v1 = (char *)connects;
    v2 = 0LL;
    do
    {
      if ( *(_DWORD *)&v1[v0 - 8] )
      {
        httpd_close_conn(*(_QWORD *)&v1[v0], &tv.tv_sec);
        v1 = (char *)connects;
      }
      v3 = *(_QWORD *)&v1[v0];
      if ( v3 )
      {
        httpd_destroy_conn(v3);
        v1 = (char *)connects;
        free(*(void **)((char *)connects + v0));
        --httpd_conn_count;
        *(_QWORD *)&v1[v0] = 0LL;
      }
      ++v2;
      v0 += 144LL;
    }
    while ( v2 < max_connects );
  }
  v4 = hs;
  if ( hs )
  {
    hs = 0LL;
    v5 = v4[18];
    if ( v5 != -1 )
      fdwatch_del_fd(v5);
    v6 = v4[19];
    if ( v6 != -1 )
      fdwatch_del_fd(v6);
    httpd_terminate(v4);
  }
  mmc_term();
  tmr_term();
  free(connects);
  if ( throttles )
    free(throttles);
}
// 1AF40: using guessed type int max_connects;
// 1AFF8: using guessed type int httpd_conn_count;

//----- (00000000000087A0) ----------------------------------------------------
void __fastcall logstats(struct timeval *a1)
{
  struct timeval *v1; // rbx
  __int64 tv_sec; // rax
  __int64 v3; // rdx
  bool v4; // zf
  __int64 v5; // rcx
  __int64 v6; // rbx
  struct timeval v7; // [rsp+0h] [rbp-18h] BYREF

  v1 = a1;
  if ( !a1 )
  {
    v1 = &v7;
    gettimeofday(&v7, 0LL);
  }
  tv_sec = v1->tv_sec;
  v3 = v1->tv_sec - start_time;
  v5 = v1->tv_sec - stats_time;
  v4 = v1->tv_sec == stats_time;
  v6 = 1LL;
  if ( !v4 )
    v6 = v5;
  stats_time = tv_sec;
  syslog(5, "up %ld seconds, stats for %ld seconds:", v3, v6);
  if ( v6 > 0 )
    syslog(
      5,
      "  thttpd - %ld connections (%g/sec), %d max simultaneous, %lld bytes (%g/sec), %d httpd_conns allocated",
      stats_connections,
      (float)((float)(int)stats_connections / (float)(int)v6),
      (unsigned int)stats_simultaneous,
      stats_bytes,
      (float)((float)(int)stats_bytes / (float)(int)v6),
      (unsigned int)httpd_conn_count);
  stats_connections = 0LL;
  stats_bytes = 0LL;
  stats_simultaneous = 0;
  httpd_logstats();
  mmc_logstats();
  fdwatch_logstats(v6);
  tmr_logstats();
}
// 1AFC0: using guessed type __int64 stats_time;
// 1AFC8: using guessed type __int64 start_time;
// 1AFD0: using guessed type __int64 stats_connections;
// 1AFD8: using guessed type __int64 stats_bytes;
// 1AFE0: using guessed type int stats_simultaneous;
// 1AFF8: using guessed type int httpd_conn_count;

//----- (00000000000088A0) ----------------------------------------------------
void __noreturn usage()
{
  fprintf(
    stderr,
    "usage:  %s [-C configfile] [-p port] [-d dir] [-r|-nor] [-dd data_dir] [-s|-nos] [-v|-nov] [-g|-nog] [-u user] [-c c"
    "gipat] [-t throttles] [-h host] [-l logfile] [-i pidfile] [-T charset] [-P P3P] [-M maxage] [-V] [-D]\n",
    (const char *)argv0);
  exit(1);
}
// 1AEF0: using guessed type __int64 argv0;

//----- (00000000000088D0) ----------------------------------------------------
void __fastcall wakeup_connection(__int64 a1)
{
  *(_QWORD *)(a1 + 96) = 0LL;
  if ( *(_DWORD *)a1 == 3 )
  {
    *(_DWORD *)a1 = 2;
    fdwatch_add_fd(*(_DWORD *)(*(_QWORD *)(a1 + 8) + 704LL), a1, 1);
  }
}

//----- (0000000000008900) ----------------------------------------------------
__int64 __fastcall really_clear_connection(__int64 a1, time_t *a2)
{
  __int64 v3; // rdi
  int v4; // eax
  char *v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rdi
  __int64 v8; // rdi
  __int64 v9; // rax
  __int64 v10; // rdi
  unsigned __int64 v11; // rbx
  __int64 result; // rax

  v3 = *(_QWORD *)(a1 + 8);
  stats_bytes += *(_QWORD *)(v3 + 200);
  if ( *(_DWORD *)a1 != 3 )
  {
    fdwatch_del_fd(*(_DWORD *)(v3 + 704));
    v3 = *(_QWORD *)(a1 + 8);
  }
  httpd_close_conn(v3, a2);
  v4 = *(_DWORD *)(a1 + 56);
  if ( v4 > 0 )
  {
    v5 = (char *)throttles;
    if ( v4 == 1 )
    {
      v6 = 0LL;
    }
    else
    {
      v6 = 0LL;
      do
      {
        v7 = 48LL * *(int *)(a1 + 4 * v6 + 16);
        --*(_DWORD *)&v5[v7 + 40];
        v8 = 48LL * *(int *)(a1 + 4 * v6 + 20);
        --*(_DWORD *)&v5[v8 + 40];
        v6 += 2LL;
      }
      while ( (v4 & 0xFFFFFFFE) != v6 );
    }
    if ( (v4 & 1) != 0 )
    {
      v9 = 48LL * *(int *)(a1 + 4 * v6 + 16);
      --*(_DWORD *)&v5[v9 + 40];
    }
  }
  v10 = *(_QWORD *)(a1 + 104);
  if ( v10 )
  {
    tmr_cancel(v10);
    *(_QWORD *)(a1 + 104) = 0LL;
  }
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = first_free_connect;
  v11 = (unsigned __int64)(a1 - (_QWORD)connects) >> 4;
  result = (unsigned int)(954437177 * v11);
  first_free_connect = 954437177 * v11;
  --num_connects;
  return result;
}
// 1AFD8: using guessed type __int64 stats_bytes;
// 1AFF0: using guessed type int first_free_connect;
// 1AFF4: using guessed type int num_connects;

//----- (00000000000089F0) ----------------------------------------------------
__int64 __fastcall linger_clear_connection(__int64 a1, time_t *a2)
{
  *(_QWORD *)(a1 + 104) = 0LL;
  return really_clear_connection(a1, a2);
}

//----- (0000000000008A00) ----------------------------------------------------
_OWORD *__fastcall httpd_initialize(
        char *s,
        struct sockaddr *a2,
        struct sockaddr *a3,
        __int16 a4,
        _BYTE *a5,
        int a6,
        char *sa,
        char *a8,
        int a9,
        char *a10,
        int a11,
        __int64 a12,
        int a13,
        int a14,
        int a15,
        char *a16,
        char *a17,
        int a18)
{
  _OWORD *v22; // rax
  _OWORD *v23; // r15
  char *v24; // rax
  const char *v25; // rsi
  char *v26; // rax
  char *v27; // rax
  char *v28; // rbx
  void *v29; // rbp
  const char *v30; // rbx
  size_t v31; // rax
  char *v32; // rax
  char *v33; // rax
  struct sockaddr *v34; // r13
  char *v35; // rax
  struct sockaddr *v36; // r14
  int v38; // eax
  int v39; // eax
  _DWORD *v40; // r12
  __int64 i; // rbx
  int v42; // edx
  socklen_t v43; // esi
  size_t v44; // rax

  v22 = malloc(0x88uLL);
  if ( !v22 )
  {
    v25 = "out of memory allocating an httpd_server";
    goto LABEL_29;
  }
  v23 = v22;
  if ( s )
  {
    v24 = strdup(s);
    *(_QWORD *)v23 = v24;
    if ( v24 )
    {
      *((_QWORD *)v23 + 1) = v24;
      goto LABEL_12;
    }
    v25 = "out of memory copying hostname";
LABEL_29:
    v23 = 0LL;
    syslog(2, v25);
    return v23;
  }
  *v22 = 0LL;
  if ( gethostname(&httpd_initialize_ghnbuf, 0x100uLL) < 0 )
  {
    httpd_initialize_ghnbuf = 0;
  }
  else if ( !*((_QWORD *)v23 + 1) && httpd_initialize_ghnbuf )
  {
    *((_QWORD *)v23 + 1) = &httpd_initialize_ghnbuf;
  }
LABEL_12:
  *((_WORD *)v23 + 8) = a4;
  if ( a5 )
  {
    v26 = strdup(&a5[*a5 == 47]);
    *((_QWORD *)v23 + 3) = v26;
    if ( !v26 )
    {
      v25 = "out of memory copying cgi_pattern";
      goto LABEL_29;
    }
    v27 = strstr(v26, "|/");
    if ( v27 )
    {
      v28 = v27;
      do
      {
        v29 = v28 + 1;
        v30 = v28 + 2;
        v31 = strlen(v30);
        memmove(v29, v30, v31 + 1);
        v28 = strstr(*((const char **)v23 + 3), "|/");
      }
      while ( v28 );
    }
  }
  else
  {
    *((_QWORD *)v23 + 3) = 0LL;
  }
  *((_DWORD *)v23 + 8) = a6;
  *((_DWORD *)v23 + 9) = 0;
  *((_QWORD *)v23 + 5) = strdup(sa);
  *((_QWORD *)v23 + 6) = strdup(a8);
  *((_DWORD *)v23 + 14) = a9;
  v32 = strdup(a10);
  *((_QWORD *)v23 + 8) = v32;
  if ( !v32 )
  {
    v25 = "out of memory copying cwd";
    goto LABEL_29;
  }
  if ( a16 )
  {
    v33 = strdup(a16);
    *((_QWORD *)v23 + 14) = v33;
    v34 = a3;
    if ( !v33 )
    {
      v25 = "out of memory copying url_pattern";
      goto LABEL_29;
    }
  }
  else
  {
    *((_QWORD *)v23 + 14) = 0LL;
    v34 = a3;
  }
  if ( a17 )
  {
    v35 = strdup(a17);
    *((_QWORD *)v23 + 15) = v35;
    v36 = a2;
    if ( !v35 )
    {
      v25 = "out of memory copying local_pattern";
      goto LABEL_29;
    }
  }
  else
  {
    *((_QWORD *)v23 + 15) = 0LL;
    v36 = a2;
  }
  *((_DWORD *)v23 + 20) = a11;
  *((_QWORD *)v23 + 11) = a12;
  *((_DWORD *)v23 + 24) = a13;
  *((_DWORD *)v23 + 25) = a14;
  *((_DWORD *)v23 + 26) = a15;
  *((_DWORD *)v23 + 32) = a18;
  if ( v34 )
    v38 = initialize_listen_socket(v34);
  else
    v38 = -1;
  *((_DWORD *)v23 + 19) = v38;
  if ( v36 )
  {
    v39 = initialize_listen_socket(v36);
    v40 = (_DWORD *)v23 + 18;
    *((_DWORD *)v23 + 18) = v39;
    if ( v39 == -1 && *((_DWORD *)v23 + 19) == -1 )
      goto LABEL_38;
  }
  else
  {
    v40 = (_DWORD *)v23 + 18;
    *((_DWORD *)v23 + 18) = -1;
    if ( v38 == -1 )
    {
LABEL_38:
      free_httpd_server((void **)v23);
      return 0LL;
    }
  }
  qsort(&enc_tab, 3uLL, 0x20uLL, (__compar_fn_t)ext_compare);
  qsort(&typ_tab, 0xC1uLL, 0x20uLL, (__compar_fn_t)ext_compare);
  qword_193D8 = strlen(enc_tab);
  qword_193E8 = strlen(off_193E0);
  qword_193F8 = strlen(off_193F0);
  qword_19408 = strlen(off_19400);
  qword_19418 = strlen(off_19410);
  qword_19428 = strlen(off_19420);
  for ( i = 24LL; i != 6200; i += 32LL )
  {
    *(void **)((char *)&typ_tab + i - 16) = (void *)strlen(*(const char **)((char *)&typ_tab + i - 24));
    *(void **)((char *)&typ_tab + i) = (void *)strlen(*(const char **)((char *)&typ_tab + i - 8));
  }
  if ( *(_QWORD *)v23 )
  {
    if ( *v40 == -1 )
      v36 = v34;
    v42 = 28;
    if ( v36->sa_family != 10 )
      v42 = 0;
    v43 = 16;
    if ( v36->sa_family != 2 )
      v43 = v42;
    if ( getnameinfo(v36, v43, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
    {
      strcpy(httpd_ntoa_str, "?");
    }
    else if ( !*(_DWORD *)&v36->sa_data[6]
           && !*(_DWORD *)&v36->sa_data[10]
           && *(_DWORD *)&v36[1].sa_family == -65536
           && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
    {
      v44 = strlen(src);
      memmove(httpd_ntoa_str, src, v44 + 1);
    }
    syslog(
      5,
      "%.80s starting on %.80s, port %d",
      "thttpd/2.29 23May2018",
      httpd_ntoa_str,
      *((unsigned __int16 *)v23 + 8));
  }
  else
  {
    syslog(5, "%.80s starting on port %d", "thttpd/2.29 23May2018", *((unsigned __int16 *)v23 + 8));
  }
  return v23;
}
// 193D8: using guessed type __int64 qword_193D8;
// 193E8: using guessed type __int64 qword_193E8;
// 193F8: using guessed type __int64 qword_193F8;
// 19408: using guessed type __int64 qword_19408;
// 19418: using guessed type __int64 qword_19418;
// 19428: using guessed type __int64 qword_19428;
// 19430: using guessed type void *typ_tab;

//----- (0000000000008EA0) ----------------------------------------------------
int __fastcall httpd_set_logfp(__int64 a1, __int64 a2)
{
  FILE *v3; // rdi
  int result; // eax

  v3 = *(FILE **)(a1 + 88);
  if ( v3 )
    result = fclose(v3);
  *(_QWORD *)(a1 + 88) = a2;
  return result;
}

//----- (0000000000008ED0) ----------------------------------------------------
__int64 __fastcall initialize_listen_socket(struct sockaddr *sa)
{
  int sa_family; // edi
  int v3; // eax
  unsigned int v4; // r14d
  socklen_t v5; // ebp
  socklen_t v6; // ebx
  int v7; // eax
  int v8; // ecx
  socklen_t v9; // esi
  size_t v10; // rax
  size_t v11; // rax
  int optval[11]; // [rsp+Ch] [rbp-2Ch] BYREF

  sa_family = sa->sa_family;
  if ( (sa_family & 0xFFF7) != 2 )
  {
    syslog(2, "unknown sockaddr family on listen socket");
    return (unsigned int)-1;
  }
  v3 = socket(sa_family, 1, 0);
  if ( v3 < 0 )
  {
    v8 = 28;
    if ( sa->sa_family != 10 )
      v8 = 0;
    v9 = 16;
    if ( sa->sa_family != 2 )
      v9 = v8;
    if ( getnameinfo(sa, v9, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
    {
      strcpy(httpd_ntoa_str, "?");
    }
    else if ( !*(_DWORD *)&sa->sa_data[6]
           && !*(_DWORD *)&sa->sa_data[10]
           && *(_DWORD *)&sa[1].sa_family == -65536
           && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
    {
      v10 = strlen(src);
      memmove(httpd_ntoa_str, src, v10 + 1);
    }
    syslog(2, "socket %.80s - %m", httpd_ntoa_str);
    return (unsigned int)-1;
  }
  v4 = v3;
  v5 = 0;
  fcntl(v3, 2, 1LL);
  optval[0] = 1;
  if ( setsockopt(v4, 1, 2, optval, 4u) < 0 )
    syslog(2, "setsockopt SO_REUSEADDR - %m");
  v6 = 28;
  if ( sa->sa_family == 10 )
    v5 = 28;
  if ( sa->sa_family == 2 )
    v5 = 16;
  if ( bind(v4, sa, v5) < 0 )
  {
    if ( sa->sa_family != 10 )
      v6 = 0;
    if ( sa->sa_family == 2 )
      v6 = 16;
    if ( getnameinfo(sa, v6, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
    {
      strcpy(httpd_ntoa_str, "?");
    }
    else if ( !*(_DWORD *)&sa->sa_data[6]
           && !*(_DWORD *)&sa->sa_data[10]
           && *(_DWORD *)&sa[1].sa_family == -65536
           && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
    {
      v11 = strlen(src);
      memmove(httpd_ntoa_str, src, v11 + 1);
    }
    syslog(2, "bind %.80s - %m", httpd_ntoa_str);
    goto LABEL_42;
  }
  v7 = fcntl(v4, 3, 0LL);
  if ( v7 == -1 )
  {
    syslog(2, "fcntl F_GETFL - %m");
    goto LABEL_42;
  }
  if ( fcntl(v4, 4, v7 | 0x800u) < 0 )
  {
    syslog(2, "fcntl O_NDELAY - %m");
    goto LABEL_42;
  }
  if ( listen(v4, 1024) < 0 )
  {
    syslog(2, "listen - %m");
LABEL_42:
    close(v4);
    return (unsigned int)-1;
  }
  return v4;
}
// 8ED0: using guessed type int optval[11];

//----- (00000000000091C0) ----------------------------------------------------
void __fastcall free_httpd_server(void **ptr)
{
  void *v2; // rdi
  void *v3; // rdi
  void *v4; // rdi
  void *v5; // rdi
  void *v6; // rdi
  void *v7; // rdi
  void *v8; // rdi

  v2 = *ptr;
  if ( v2 )
    free(v2);
  v3 = ptr[8];
  if ( v3 )
    free(v3);
  v4 = ptr[3];
  if ( v4 )
    free(v4);
  v5 = ptr[5];
  if ( v5 )
    free(v5);
  v6 = ptr[6];
  if ( v6 )
    free(v6);
  v7 = ptr[14];
  if ( v7 )
    free(v7);
  v8 = ptr[15];
  if ( v8 )
    free(v8);
  free(ptr);
}

//----- (0000000000009230) ----------------------------------------------------
char *__fastcall httpd_ntoa(__int64 a1)
{
  int v1; // edx
  socklen_t v2; // esi
  size_t v3; // rax

  v1 = 28;
  if ( *(_WORD *)a1 != 10 )
    v1 = 0;
  v2 = 16;
  if ( *(_WORD *)a1 != 2 )
    v2 = v1;
  if ( getnameinfo((const struct sockaddr *)a1, v2, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
  {
    strcpy(httpd_ntoa_str, "?");
  }
  else if ( !*(_DWORD *)(a1 + 8)
         && !*(_DWORD *)(a1 + 12)
         && *(_DWORD *)(a1 + 16) == -65536
         && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
  {
    v3 = strlen(src);
    memmove(httpd_ntoa_str, src, v3 + 1);
  }
  return httpd_ntoa_str;
}

//----- (00000000000092E0) ----------------------------------------------------
void __fastcall httpd_terminate(_DWORD *ptr)
{
  int v2; // edi
  int v3; // edi
  FILE *v4; // rdi

  v2 = ptr[18];
  if ( v2 != -1 )
  {
    close(v2);
    ptr[18] = -1;
  }
  v3 = ptr[19];
  if ( v3 != -1 )
  {
    close(v3);
    ptr[19] = -1;
  }
  v4 = (FILE *)*((_QWORD *)ptr + 11);
  if ( v4 )
    fclose(v4);
  free_httpd_server((void **)ptr);
}

//----- (0000000000009330) ----------------------------------------------------
int __fastcall httpd_unlisten(__int64 a1)
{
  int v2; // edi
  int result; // eax
  int v4; // edi

  v2 = *(_DWORD *)(a1 + 72);
  if ( v2 != -1 )
  {
    result = close(v2);
    *(_DWORD *)(a1 + 72) = -1;
  }
  v4 = *(_DWORD *)(a1 + 76);
  if ( v4 != -1 )
  {
    result = close(v4);
    *(_DWORD *)(a1 + 76) = -1;
  }
  return result;
}

//----- (0000000000009360) ----------------------------------------------------
void __fastcall httpd_write_response(__int64 a1)
{
  int v1; // ebp
  int v2; // eax
  unsigned __int64 v3; // rbx
  int v4; // r15d
  __int64 v5; // r12
  __int64 v6; // rax
  int v7; // ebp
  int v8; // eax
  int v9; // eax

  if ( sub_process == 1 )
  {
    v1 = *(_DWORD *)(a1 + 704);
    v2 = fcntl(v1, 3, 0LL);
    if ( v2 != -1 && (v2 & 0xFFFFF7FF) != v2 )
      fcntl(v1, 4);
  }
  v3 = *(_QWORD *)(a1 + 472);
  if ( v3 )
  {
    v4 = *(_DWORD *)(a1 + 704);
    v5 = *(_QWORD *)(a1 + 368);
    v6 = 0LL;
    v7 = 0;
    while ( 1 )
    {
      v8 = write(v4, (const void *)(v5 + v6), v3 - v6);
      if ( v8 < 0 )
      {
        v9 = *__errno_location();
        if ( v9 != 11 && v9 != 4 )
        {
LABEL_14:
          *(_QWORD *)(a1 + 472) = 0LL;
          return;
        }
        sleep(1u);
      }
      else
      {
        if ( !v8 )
          goto LABEL_14;
        v7 += v8;
      }
      v6 = v7;
      if ( v3 <= v7 )
        goto LABEL_14;
    }
  }
}
// 1B100: using guessed type char sub_process;

//----- (0000000000009430) ----------------------------------------------------
int __fastcall httpd_clear_ndelay(int fd)
{
  int result; // eax

  result = fcntl(fd, 3, 0LL);
  if ( result != -1 && (result & 0xFFFFF7FF) != result )
    return fcntl(fd, 4);
  return result;
}

//----- (0000000000009470) ----------------------------------------------------
__int64 __fastcall httpd_write_fully(int fd, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rax
  unsigned int v5; // ebp
  int v6; // eax
  unsigned int v7; // ebx
  int v8; // eax

  if ( !a3 )
    return 0;
  v4 = 0LL;
  v5 = 0;
  while ( 1 )
  {
    v6 = write(fd, (const void *)(a2 + v4), a3 - v4);
    v7 = v6;
    if ( v6 < 0 )
      break;
    v5 += v6;
    if ( !v6 )
      return v5;
LABEL_4:
    v4 = (int)v5;
    if ( (int)v5 >= a3 )
      return v5;
  }
  v8 = *__errno_location();
  if ( v8 == 11 || v8 == 4 )
  {
    sleep(1u);
    goto LABEL_4;
  }
  return v7;
}

//----- (0000000000009500) ----------------------------------------------------
int __fastcall httpd_set_ndelay(int fd)
{
  int result; // eax

  result = fcntl(fd, 3, 0LL);
  if ( result != -1 && (result | 0x800) != result )
    return fcntl(fd, 4);
  return result;
}

//----- (0000000000009540) ----------------------------------------------------
unsigned __int64 __fastcall httpd_realloc_str(void **a1, __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rsi
  __int64 v8; // r15
  unsigned __int64 v9; // rdx

  result = *a2;
  if ( *a2 )
  {
    if ( result >= a3 )
      return result;
    v5 = str_alloc_size - result;
    v6 = 2 * result;
    v7 = (5 * a3) >> 2;
    if ( v6 > v7 )
      v7 = v6;
    *a2 = v7;
    result = (unsigned __int64)realloc(*a1, v7 + 1);
    *a1 = (void *)result;
    v8 = *a2;
  }
  else
  {
    v9 = a3 + 100;
    v8 = 200LL;
    if ( v9 >= 0xC9 )
      v8 = v9;
    *a2 = v8;
    result = (unsigned __int64)malloc(v8 + 1);
    *a1 = (void *)result;
    ++str_alloc_count;
    v5 = str_alloc_size;
  }
  str_alloc_size = v8 + v5;
  if ( !result )
  {
    syslog(3, "out of memory reallocating a string to %ld bytes", v8);
    exit(1);
  }
  return result;
}
// 1B104: using guessed type int str_alloc_count;
// 1B108: using guessed type __int64 str_alloc_size;

//----- (0000000000009600) ----------------------------------------------------
void *__fastcall httpd_send_err(__int64 a1, unsigned int a2, const char *a3, char *a4, const char *a5, char *a6)
{
  const char *v9; // rcx
  void *result; // rax
  char filename[1048]; // [rsp+10h] [rbp-418h] BYREF

  if ( !*(_DWORD *)(*(_QWORD *)(a1 + 8) + 100LL)
    || (v9 = *(const char **)(a1 + 344), !*v9)
    || (my_snprintf(filename, 0x3E8uLL, "%s/%s/err%d.html", v9, "errors", a2),
        result = (void *)send_err_file(a1, a2, a3, a4, filename),
        !(_DWORD)result) )
  {
    my_snprintf(filename, 0x3E8uLL, "%s/err%d.html", "errors", a2);
    result = (void *)send_err_file(a1, a2, a3, a4, filename);
    if ( !(_DWORD)result )
      return send_response(a1, a2, a3, a4, a5, a6);
  }
  return result;
}

//----- (00000000000096F0) ----------------------------------------------------
int my_snprintf(char *a1, size_t a2, const char *a3, ...)
{
  gcc_va_list va; // [rsp+0h] [rbp-D8h] BYREF

  va_start(va, a3);
  return vsnprintf(a1, a2, a3, va);
}

//----- (0000000000009780) ----------------------------------------------------
__int64 __fastcall send_err_file(__int64 a1, unsigned int a2, const char *a3, char *a4, char *filename)
{
  FILE *v7; // rax
  FILE *v8; // r14
  size_t i; // rax
  size_t v10; // rbp
  size_t v11; // rbp
  char v13[1008]; // [rsp+0h] [rbp-808h] BYREF
  char s[1048]; // [rsp+3F0h] [rbp-418h] BYREF

  v7 = fopen(filename, "r");
  if ( !v7 )
    return 0LL;
  v8 = v7;
  send_mime(a1, a2, a3, "", a4, "text/html; charset=%s", -1LL, 0LL);
  for ( i = fread(v13, 1uLL, 0x3E7uLL, v8); i; i = fread(v13, 1uLL, 0x3E7uLL, v8) )
  {
    v13[i] = 0;
    v10 = strlen(v13);
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v10 + *(_QWORD *)(a1 + 472));
    memcpy((void *)(*(_QWORD *)(a1 + 472) + *(_QWORD *)(a1 + 368)), v13, v10);
    *(_QWORD *)(a1 + 472) += v10;
  }
  fclose(v8);
  my_snprintf(
    s,
    0x3E8uLL,
    "    <hr>\n\n    <address><a href=\"%s\">%s</a></address>\n\n  </body>\n\n</html>\n",
    "http://www.acme.com/software/thttpd/",
    "thttpd/2.29 23May2018");
  v11 = strlen(s);
  httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v11 + *(_QWORD *)(a1 + 472));
  memcpy((void *)(*(_QWORD *)(a1 + 472) + *(_QWORD *)(a1 + 368)), s, v11);
  *(_QWORD *)(a1 + 472) += v11;
  return 1LL;
}
// 9780: using guessed type char var_808[1008];

//----- (0000000000009910) ----------------------------------------------------
void *__fastcall send_response(__int64 a1, unsigned int a2, const char *a3, char *a4, const char *a5, char *a6)
{
  size_t v9; // rbp
  __int64 *v10; // r15
  char v11; // cl
  char *v12; // rbx
  char *v13; // rax
  const char *v14; // rdx
  __int64 *v15; // rbx
  size_t v16; // rbp
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // rdx
  __int64 v20; // rdx
  __int64 v21; // rdx
  __int64 v22; // rdx
  __int64 v23; // rdx
  __int64 v24; // rdx
  __int64 v25; // rdx
  size_t v26; // rbp
  void *result; // rax
  char v29[1008]; // [rsp+10h] [rbp-FD8h] BYREF
  char s[2000]; // [rsp+400h] [rbp-BE8h] BYREF
  char src[1048]; // [rsp+BD0h] [rbp-418h] BYREF

  send_mime(a1, a2, a3, "", a4, "text/html; charset=%s", -1LL, 0LL);
  my_snprintf(
    s,
    0x7D0uLL,
    "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n"
    "\n"
    "<html>\n"
    "\n"
    "  <head>\n"
    "    <meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\">\n"
    "    <title>%d %s</title>\n"
    "  </head>\n"
    "\n"
    "  <body bgcolor=\"#cc9999\" text=\"#000000\" link=\"#2020ff\" vlink=\"#4040cc\">\n"
    "\n"
    "    <h2>%d %s</h2>\n",
    a2,
    a3,
    a2,
    a3);
  v9 = strlen(s);
  v10 = (__int64 *)(a1 + 368);
  httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v9 + *(_QWORD *)(a1 + 472));
  memcpy((void *)(*(_QWORD *)(a1 + 472) + *(_QWORD *)(a1 + 368)), s, v9);
  *(_QWORD *)(a1 + 472) += v9;
  v11 = *a6;
  if ( *a6 )
  {
    v12 = a6 + 1;
    v13 = v29;
    v14 = a5;
    do
    {
      if ( v11 == 62 )
      {
        *(_DWORD *)v13 = 997484326;
        v13 += 3;
      }
      else if ( v11 == 60 )
      {
        *(_DWORD *)v13 = 997485606;
        v13 += 3;
      }
      else
      {
        *v13 = v11;
      }
      ++v13;
      v11 = *v12;
      if ( !*v12 )
        break;
      ++v12;
    }
    while ( v13 - v29 < 995 );
  }
  else
  {
    v13 = v29;
    v14 = a5;
  }
  v15 = (__int64 *)(a1 + 472);
  *v13 = 0;
  my_snprintf(s, 0x7D0uLL, v14, v29);
  v16 = strlen(s);
  httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v16 + *(_QWORD *)(a1 + 472));
  memcpy((void *)(*(_QWORD *)(a1 + 472) + *(_QWORD *)(a1 + 368)), s, v16);
  *(_QWORD *)(a1 + 472) += v16;
  if ( (unsigned int)match("**MSIE**", *(_BYTE **)(a1 + 280)) )
  {
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), *v15 + 5);
    v17 = *v10;
    v18 = *v15;
    *(_BYTE *)(v17 + v18 + 4) = 10;
    *(_DWORD *)(v17 + v18) = 757932348;
    v19 = *v15;
    *v15 += 5LL;
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v19 + 83);
    qmemcpy(
      (void *)(*v10 + *v15),
      "Padding so that MSIE deigns to show this error instead of its own canned one.\n",
      78);
    v20 = *v15;
    *v15 += 78LL;
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v20 + 156);
    qmemcpy(
      (void *)(*v10 + *v15),
      "Padding so that MSIE deigns to show this error instead of its own canned one.\n",
      78);
    v21 = *v15;
    *v15 += 78LL;
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v21 + 156);
    qmemcpy(
      (void *)(*v10 + *v15),
      "Padding so that MSIE deigns to show this error instead of its own canned one.\n",
      78);
    v22 = *v15;
    *v15 += 78LL;
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v22 + 156);
    qmemcpy(
      (void *)(*v10 + *v15),
      "Padding so that MSIE deigns to show this error instead of its own canned one.\n",
      78);
    v23 = *v15;
    *v15 += 78LL;
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v23 + 156);
    qmemcpy(
      (void *)(*v10 + *v15),
      "Padding so that MSIE deigns to show this error instead of its own canned one.\n",
      78);
    v24 = *v15;
    *v15 += 78LL;
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v24 + 156);
    qmemcpy(
      (void *)(*v10 + *v15),
      "Padding so that MSIE deigns to show this error instead of its own canned one.\n",
      78);
    v25 = *v15;
    *v15 += 78LL;
    httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v25 + 82);
    *(_DWORD *)(*v10 + *v15) = 171846957;
    *v15 += 4LL;
  }
  my_snprintf(
    src,
    0x3E8uLL,
    "    <hr>\n\n    <address><a href=\"%s\">%s</a></address>\n\n  </body>\n\n</html>\n",
    "http://www.acme.com/software/thttpd/",
    "thttpd/2.29 23May2018");
  v26 = strlen(src);
  httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v26 + *v15);
  result = memcpy((void *)(*v15 + *v10), src, v26);
  *v15 += v26;
  return result;
}
// 13973: using guessed type __int128 xmmword_13973;

//----- (0000000000009DB0) ----------------------------------------------------
const char *__fastcall httpd_method_str(int a1)
{
  unsigned int v1; // edi

  v1 = a1 - 1;
  if ( v1 > 5 )
    return "UNKNOWN";
  else
    return (&off_18DA0)[v1];
}
// 18DA0: using guessed type char *off_18DA0;

//----- (0000000000009DD0) ----------------------------------------------------
__int64 __fastcall httpd_get_conn(__int64 a1, int a2, __int64 a3)
{
  __int64 v4; // rbp
  int v5; // eax
  unsigned int v6; // r14d
  __int64 v7; // rcx
  size_t v8; // rbp
  int v9; // eax
  socklen_t addr_len; // [rsp+4h] [rbp-F4h] BYREF
  __int64 *v12; // [rsp+8h] [rbp-F0h]
  __int64 *v13; // [rsp+10h] [rbp-E8h]
  __int64 *v14; // [rsp+18h] [rbp-E0h]
  __int64 *v15; // [rsp+20h] [rbp-D8h]
  __int64 *v16; // [rsp+28h] [rbp-D0h]
  __int64 *v17; // [rsp+30h] [rbp-C8h]
  __int64 *v18; // [rsp+38h] [rbp-C0h]
  __int64 v19; // [rsp+40h] [rbp-B8h]
  struct sockaddr addr; // [rsp+48h] [rbp-B0h] BYREF

  v4 = a1;
  if ( !*(_DWORD *)a3 )
  {
    *(_QWORD *)(a3 + 152) = 0LL;
    httpd_realloc_str((void **)(a3 + 144), (__int64 *)(a3 + 152), 0x1F4uLL);
    v18 = (__int64 *)(a3 + 464);
    v17 = (__int64 *)(a3 + 456);
    v16 = (__int64 *)(a3 + 448);
    v15 = (__int64 *)(a3 + 440);
    v14 = (__int64 *)(a3 + 432);
    v13 = (__int64 *)(a3 + 424);
    v12 = (__int64 *)(a3 + 416);
    v19 = a1;
    *(_OWORD *)(a3 + 456) = 0LL;
    *(_OWORD *)(a3 + 440) = 0LL;
    *(_OWORD *)(a3 + 424) = 0LL;
    *(_OWORD *)(a3 + 408) = 0LL;
    *(_OWORD *)(a3 + 392) = 0LL;
    *(_OWORD *)(a3 + 376) = 0LL;
    httpd_realloc_str((void **)(a3 + 216), (__int64 *)(a3 + 376), 1uLL);
    httpd_realloc_str((void **)(a3 + 232), (__int64 *)(a3 + 384), 1uLL);
    httpd_realloc_str((void **)(a3 + 240), (__int64 *)(a3 + 392), 0LL);
    httpd_realloc_str((void **)(a3 + 248), (__int64 *)(a3 + 400), 0LL);
    v4 = v19;
    httpd_realloc_str((void **)(a3 + 256), (__int64 *)(a3 + 408), 0LL);
    httpd_realloc_str((void **)(a3 + 264), v12, 0LL);
    httpd_realloc_str((void **)(a3 + 288), v13, 0LL);
    httpd_realloc_str((void **)(a3 + 296), v14, 0LL);
    httpd_realloc_str((void **)(a3 + 328), v15, 0LL);
    httpd_realloc_str((void **)(a3 + 344), v16, 0LL);
    httpd_realloc_str((void **)(a3 + 360), v17, 0LL);
    httpd_realloc_str((void **)(a3 + 368), v18, 0LL);
    *(_DWORD *)a3 = 1;
  }
  addr_len = 128;
  v5 = accept(a2, &addr, &addr_len);
  *(_DWORD *)(a3 + 704) = v5;
  if ( v5 < 0 )
  {
    v9 = *__errno_location();
    if ( v9 == 11 )
    {
      return 2;
    }
    else
    {
      if ( v9 != 103 )
        syslog(3, "accept - %m");
      return 0;
    }
  }
  else if ( (addr.sa_family & 0xFFF7) == 2 )
  {
    v6 = 1;
    fcntl(v5, 2, 1LL);
    *(_QWORD *)(a3 + 8) = v4;
    v7 = 28LL;
    if ( addr.sa_family != 10 )
      v7 = 0LL;
    v8 = 16LL;
    if ( addr.sa_family != 2 )
      v8 = v7;
    memset((void *)(a3 + v8 + 16), 0, 128 - v8);
    memcpy((void *)(a3 + 16), &addr, v8);
    *(_OWORD *)(a3 + 160) = 0LL;
    *(_OWORD *)(a3 + 172) = 0LL;
    *(_OWORD *)(a3 + 192) = 0LL;
    *(_QWORD *)(a3 + 208) = "";
    **(_BYTE **)(a3 + 216) = 0;
    *(_QWORD *)(a3 + 224) = "UNKNOWN";
    **(_BYTE **)(a3 + 232) = 0;
    **(_BYTE **)(a3 + 240) = 0;
    **(_BYTE **)(a3 + 248) = 0;
    **(_BYTE **)(a3 + 256) = 0;
    **(_BYTE **)(a3 + 264) = 0;
    *(_QWORD *)(a3 + 272) = "";
    *(_QWORD *)(a3 + 280) = "";
    **(_BYTE **)(a3 + 288) = 0;
    **(_BYTE **)(a3 + 296) = 0;
    *(_QWORD *)(a3 + 304) = "";
    *(_QWORD *)(a3 + 312) = "";
    *(_QWORD *)(a3 + 320) = "";
    **(_BYTE **)(a3 + 328) = 0;
    *(_QWORD *)(a3 + 336) = "";
    **(_BYTE **)(a3 + 344) = 0;
    *(_QWORD *)(a3 + 352) = "";
    **(_BYTE **)(a3 + 360) = 0;
    **(_BYTE **)(a3 + 368) = 0;
    *(_QWORD *)(a3 + 472) = 0LL;
    *(_OWORD *)(a3 + 480) = -1LL;
    *(_QWORD *)(a3 + 496) = -1LL;
    *(_QWORD *)(a3 + 504) = "";
    *(_QWORD *)(a3 + 512) = 0LL;
    *(_DWORD *)(a3 + 520) = 1;
    *(_OWORD *)(a3 + 524) = 0LL;
    *(_DWORD *)(a3 + 540) = 0;
    *(_QWORD *)(a3 + 544) = -1LL;
    *(_QWORD *)(a3 + 552) = 0LL;
    *(_QWORD *)(a3 + 712) = 0LL;
  }
  else
  {
    v6 = 0;
    syslog(3, "unknown sockaddr family");
    close(*(_DWORD *)(a3 + 704));
    *(_DWORD *)(a3 + 704) = -1;
  }
  return v6;
}

//----- (000000000000A210) ----------------------------------------------------
__int64 __fastcall httpd_got_request(__int64 a1)
{
  unsigned __int64 v1; // rcx
  unsigned __int64 v2; // rdx
  __int64 v3; // r13
  int v4; // ebp
  unsigned __int64 v5; // rdx
  __int64 v6; // rcx
  int v7; // ebx
  __int64 v8; // rax
  int v9; // esi
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 160);
  v2 = *(_QWORD *)(a1 + 168);
  if ( v2 < v1 )
  {
    v3 = *(_QWORD *)(a1 + 144);
    v4 = *(_DWORD *)(a1 + 176);
    v5 = v2 + 1;
    v6 = -(__int64)v1;
    while ( 1 )
    {
      v9 = *(char *)(v3 + v5 - 1);
      result = 2LL;
      switch ( v4 )
      {
        case 0:
          v4 = 0;
          v7 = 1;
          switch ( *(_BYTE *)(v3 + v5 - 1) )
          {
            case 9:
            case 0x20:
              goto LABEL_4;
            case 0xA:
            case 0xD:
              goto LABEL_29;
            default:
              goto LABEL_5;
          }
        case 1:
          v7 = 2;
          v4 = 1;
          switch ( *(_BYTE *)(v3 + v5 - 1) )
          {
            case 9:
            case 0x20:
              goto LABEL_5;
            case 0xA:
            case 0xD:
              goto LABEL_29;
            default:
              goto LABEL_4;
          }
        case 2:
          v4 = 2;
          result = 1LL;
          v7 = 3;
          switch ( *(_BYTE *)(v3 + v5 - 1) )
          {
            case 9:
            case 0x20:
              goto LABEL_4;
            case 0xA:
            case 0xD:
              return result;
            default:
              goto LABEL_5;
          }
        case 3:
          v7 = 4;
          v4 = 3;
          switch ( *(_BYTE *)(v3 + v5 - 1) )
          {
            case 9:
            case 0x20:
              goto LABEL_5;
            case 0xA:
            case 0xD:
              goto LABEL_29;
            default:
              goto LABEL_4;
          }
        case 4:
          v4 = 4;
          v7 = 5;
          switch ( *(_BYTE *)(v3 + v5 - 1) )
          {
            case 9:
            case 0x20:
              goto LABEL_4;
            case 0xA:
              goto LABEL_3;
            case 0xD:
              goto LABEL_15;
            default:
              goto LABEL_5;
          }
          goto LABEL_5;
        case 5:
          v7 = 7;
          v4 = 5;
          switch ( *(_BYTE *)(v3 + v5 - 1) )
          {
            case 9:
            case 0x20:
              goto LABEL_5;
            case 0xA:
              goto LABEL_4;
            case 0xD:
              goto LABEL_15;
            default:
LABEL_29:
              *(_DWORD *)(a1 + 176) = 11;
              return result;
          }
        case 6:
          if ( v9 == 10 )
          {
LABEL_3:
            v7 = 7;
            goto LABEL_4;
          }
          v4 = 6;
          if ( v9 != 13 )
            goto LABEL_5;
LABEL_15:
          v7 = 8;
          goto LABEL_4;
        case 7:
          v7 = 8;
          if ( v9 == 13 )
            goto LABEL_4;
          goto LABEL_22;
        case 8:
          v7 = 9;
          if ( v9 == 10 )
            goto LABEL_4;
          if ( v9 == 13 )
            return 1LL;
          goto LABEL_23;
        case 9:
          v7 = 10;
          if ( v9 == 13 )
            goto LABEL_4;
LABEL_22:
          if ( v9 == 10 )
            return 1LL;
LABEL_23:
          v7 = 6;
LABEL_4:
          *(_DWORD *)(a1 + 176) = v7;
          v4 = v7;
LABEL_5:
          *(_QWORD *)(a1 + 168) = v5;
          v8 = v6 + v5++ + 1;
          if ( v8 == 1 )
            return 0LL;
          break;
        case 10:
          result = 1LL;
          if ( v9 == 10 )
            return result;
          v7 = 6;
          if ( v9 == 13 )
            return result;
          goto LABEL_4;
        case 11:
          return result;
        default:
          goto LABEL_5;
      }
    }
  }
  return 0LL;
}

//----- (000000000000A410) ----------------------------------------------------
__int64 __fastcall httpd_parse_request(__int64 a1)
{
  __int64 v1; // r13
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rdx
  const char *v6; // r15
  char v7; // bl
  __int64 v8; // rsi
  unsigned __int64 v9; // rax
  __int64 v10; // rcx
  char *v11; // rax
  const char *v12; // r12
  char *v13; // rax
  char *v14; // rbx
  size_t v15; // rax
  const char *v16; // rbp
  char *v17; // rax
  const char *v18; // rdx
  const char *v19; // r8
  unsigned int v20; // esi
  char *v21; // r9
  const char *v22; // r12
  char *v23; // rax
  char *v24; // r14
  unsigned __int64 v25; // rax
  int v26; // eax
  unsigned __int64 v27; // rax
  char *v28; // rbp
  char *v29; // rbx
  char v30; // dl
  const unsigned __int16 **v31; // rax
  const unsigned __int16 *v32; // rcx
  __int64 v33; // rsi
  __int64 v34; // rax
  char v35; // cl
  char v36; // cl
  char v37; // dl
  unsigned __int64 v38; // rax
  _WORD *v39; // rax
  char *v40; // rax
  const char *v41; // rbx
  unsigned __int64 v42; // rax
  char *v43; // rax
  char *v44; // rbp
  char *v45; // rax
  char *v46; // r14
  const char *v47; // rbx
  bool v48; // zf
  size_t v49; // rax
  size_t v50; // rax
  char *v51; // rax
  char *v52; // rbx
  size_t v53; // rax
  size_t v54; // rdx
  char *v55; // rdi
  const char *v56; // rsi
  char *v57; // rax
  char *v58; // r14
  char *v59; // rax
  char *v60; // r12
  const char *v61; // r14
  int v62; // eax
  __int64 v63; // rbx
  char *v64; // rbx
  char *v65; // rax
  const char *v66; // rax
  char v67; // cl
  char v68; // al
  unsigned __int64 v69; // rcx
  unsigned __int64 v70; // rax
  const char **v71; // r14
  __int64 v72; // rdx
  unsigned __int64 v73; // rsi
  __int64 v74; // rcx
  char v75; // bl
  __int64 v76; // rdi
  unsigned __int64 v77; // rcx
  __int64 v78; // r15
  const char *v79; // r15
  __int64 v80; // rbx
  size_t v81; // rax
  size_t v82; // rax
  const char *v83; // rbp
  char *v84; // rax
  const char *v85; // r15
  size_t v86; // rax
  const char *v87; // r15
  size_t v88; // rax
  unsigned __int64 v89; // rax
  size_t v90; // rbx
  size_t v91; // rax
  _BYTE *v92; // r15
  __int64 v93; // rax
  unsigned __int64 v94; // rax
  size_t v95; // rbx
  size_t v96; // rax
  char *v97; // rax
  const char *v98; // rbp
  char *v99; // rax
  char *v100; // r15
  __int64 v101; // rax
  __int64 v102; // rax
  char **v103; // r15
  unsigned __int64 v104; // rax
  __int64 v105; // rax
  char *v106; // rbp
  __int64 v107; // rbx
  const unsigned __int16 **v108; // r12
  _BYTE *v109; // rbp
  unsigned int v110; // ebx
  unsigned __int64 v112; // rax
  unsigned __int64 v113; // rbx
  size_t v114; // rax
  const char *v115; // rbx
  char *v116; // rax
  const char *v117; // rbx
  unsigned __int64 v118; // rax
  const char *v119; // rbx
  unsigned __int64 v120; // rax
  const char *v121; // rbx
  const char *v122; // r14
  int v123; // ebp
  int v124; // ebp
  char *v125; // rbp
  const char *v126; // r15
  size_t v127; // r14
  const char *v128; // r14
  size_t v129; // rax
  int v130; // edx
  socklen_t v131; // esi
  size_t v132; // rax
  __int64 v133; // [rsp+10h] [rbp-E8h]
  socklen_t len; // [rsp+1Ch] [rbp-DCh] BYREF
  __int64 *v135; // [rsp+20h] [rbp-D8h]
  __int64 v136; // [rsp+28h] [rbp-D0h]
  __int64 *v137; // [rsp+30h] [rbp-C8h]
  const char **v138; // [rsp+38h] [rbp-C0h]
  void **v139; // [rsp+40h] [rbp-B8h]
  struct sockaddr s; // [rsp+48h] [rbp-B0h] BYREF
  int v141; // [rsp+58h] [rbp-A0h]

  v1 = a1;
  *(_QWORD *)(a1 + 168) = 0LL;
  v2 = *(_QWORD *)(a1 + 160);
  if ( v2 )
  {
    v3 = *(_QWORD *)(a1 + 144);
    v4 = -v2;
    v5 = 1LL;
    v6 = 0LL;
    while ( 1 )
    {
      v7 = *(_BYTE *)(v3 + v5 - 1);
      if ( v7 == 13 || v7 == 10 )
        break;
      *(_QWORD *)(a1 + 168) = v5;
      v8 = v4 + v5++ + 1;
      if ( v8 == 1 )
        goto LABEL_13;
    }
    *(_BYTE *)(v3 + v5 - 1) = 0;
    v9 = *(_QWORD *)(a1 + 168) + 1LL;
    *(_QWORD *)(a1 + 168) = v9;
    if ( v7 == 13 && v9 < *(_QWORD *)(a1 + 160) )
    {
      v10 = *(_QWORD *)(a1 + 144);
      if ( *(_BYTE *)(v10 + v9) == 10 )
      {
        *(_BYTE *)(v10 + v9) = 0;
        ++*(_QWORD *)(a1 + 168);
      }
    }
    v6 = *(const char **)(a1 + 144);
  }
  else
  {
    v6 = 0LL;
  }
LABEL_13:
  v11 = strpbrk(v6, " \t\n\r");
  if ( !v11 )
    goto LABEL_181;
  *v11 = 0;
  v12 = &v11[strspn(v11 + 1, " \t\n\r") + 1];
  v13 = strpbrk(v12, " \t\n\r");
  if ( v13 )
  {
    v14 = v13;
    *v13 = 0;
    v15 = strspn(v13 + 1, " \t\n\r");
    v16 = &v14[v15 + 1];
    if ( *v16 )
    {
      v17 = strpbrk(&v14[v15 + 1], " \t\n\r");
      if ( v17 )
        *v17 = 0;
      if ( strcasecmp(v16, "HTTP/1.0") )
        *(_DWORD *)(a1 + 524) = 1;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 520) = 0;
    v16 = "HTTP/0.9";
  }
  *(_QWORD *)(a1 + 224) = v16;
  if ( !strncasecmp(v12, "http://", 7uLL) )
  {
    if ( !*(_DWORD *)(a1 + 524) )
      goto LABEL_181;
    v22 = v12 + 7;
    v23 = strchr(v22, 47);
    if ( !v23 )
      goto LABEL_181;
    v24 = v23;
    *v23 = 0;
    if ( strchr(v22, 47) || *v22 == 46 )
      goto LABEL_181;
    v25 = strlen(v22);
    httpd_realloc_str((void **)(a1 + 328), (__int64 *)(a1 + 440), v25);
    strcpy(*(char **)(a1 + 328), v22);
    *v24 = 47;
    v12 = v24;
  }
  else if ( *v12 != 47 )
  {
    goto LABEL_181;
  }
  if ( !strcasecmp(v6, "GET") )
  {
    v26 = 1;
  }
  else if ( !strcasecmp(v6, "HEAD") )
  {
    v26 = 2;
  }
  else if ( !strcasecmp(v6, "POST") )
  {
    v26 = 3;
  }
  else if ( !strcasecmp(v6, "PUT") )
  {
    v26 = 4;
  }
  else if ( !strcasecmp(v6, "DELETE") )
  {
    v26 = 5;
  }
  else
  {
    if ( strcasecmp(v6, "TRACE") )
    {
      v18 = "Not Implemented";
      v19 = "The requested method '%.80s' is not implemented by this server.\n";
      v20 = 501;
      v21 = (char *)v6;
      goto LABEL_183;
    }
    v26 = 6;
  }
  *(_DWORD *)(a1 + 180) = v26;
  *(_QWORD *)(a1 + 208) = v12;
  v27 = strlen(v12);
  httpd_realloc_str((void **)(a1 + 216), (__int64 *)(a1 + 376), v27);
  v28 = *(char **)(a1 + 208);
  v29 = *(char **)(a1 + 216);
  while ( 1 )
  {
    v30 = *v28;
    if ( *v28 != 37 )
      break;
    v31 = __ctype_b_loc();
    v32 = *v31;
    v33 = v28[1];
    v30 = 37;
    if ( ((*v31)[v33] & 0x1000) != 0 )
    {
      v34 = v28[2];
      if ( (v32[v34] & 0x1000) != 0 )
      {
        v35 = v33 - 48;
        if ( (unsigned __int8)(v33 - 48) >= 0xAu )
        {
          if ( (unsigned __int8)(v33 - 97) > 5u )
          {
            v35 = v33 - 55;
            if ( (unsigned __int8)(v33 - 65) >= 6u )
              v35 = 0;
          }
          else
          {
            v35 = v33 - 87;
          }
        }
        v36 = 16 * v35;
        v37 = v34 - 48;
        if ( (unsigned __int8)(v34 - 48) >= 0xAu )
        {
          if ( (unsigned __int8)(v34 - 97) > 5u )
          {
            v37 = v34 - 55;
            if ( (unsigned __int8)(v34 - 65) >= 6u )
              v37 = 0;
          }
          else
          {
            v37 = v34 - 87;
          }
        }
        v30 = v36 + v37;
        v28 += 2;
      }
    }
LABEL_43:
    *v29++ = v30;
    ++v28;
  }
  if ( v30 )
    goto LABEL_43;
  *v29 = 0;
  v38 = strlen(*(const char **)(a1 + 216));
  httpd_realloc_str((void **)(a1 + 232), (__int64 *)(a1 + 384), v38);
  strcpy(*(char **)(a1 + 232), (const char *)(*(_QWORD *)(a1 + 216) + 1LL));
  v39 = *(_WORD **)(a1 + 232);
  if ( !*(_BYTE *)v39 )
    *v39 = 46;
  v40 = strchr(*(const char **)(a1 + 208), 63);
  if ( v40 )
  {
    v41 = v40 + 1;
    v42 = strlen(v40 + 1);
    httpd_realloc_str((void **)(a1 + 264), (__int64 *)(a1 + 416), v42);
    strcpy(*(char **)(a1 + 264), v41);
    v43 = strchr(*(const char **)(a1 + 232), 63);
    if ( v43 )
      *v43 = 0;
  }
  v138 = (const char **)(a1 + 232);
  v44 = *(char **)(a1 + 232);
  v45 = strstr(v44, "//");
  if ( v45 )
  {
    v46 = v45;
    do
    {
      v47 = v46 + 1;
      do
        v48 = *++v47 == 47;
      while ( v48 );
      v49 = strlen(v47);
      memmove(v46 + 1, v47, v49 + 1);
      v46 = strstr(v44, "//");
    }
    while ( v46 );
  }
  while ( !strncmp(v44, "./", 2uLL) )
  {
    v50 = strlen(v44 + 2);
    memmove(v44, v44 + 2, v50 + 1);
  }
  v133 = a1;
  v51 = strstr(v44, "/./");
  if ( v51 )
  {
    v52 = v51;
    do
    {
      v53 = strlen(v52 + 2);
      memmove(v52, v52 + 2, v53 + 1);
      v52 = strstr(v44, "/./");
    }
    while ( v52 );
  }
  while ( 2 )
  {
    if ( !strncmp(v44, "../", 3uLL) )
    {
      v54 = strlen(v44 + 3) + 1;
      v55 = v44;
      v56 = v44 + 3;
LABEL_75:
      memmove(v55, v56, v54);
      continue;
    }
    break;
  }
  v57 = strstr(v44, "/../");
  if ( v57 )
  {
    v58 = v57;
    v59 = v57 - 1;
    do
    {
      v60 = v59;
      if ( v59 < v44 )
        break;
      --v59;
    }
    while ( *v60 != 47 );
    v61 = v58 + 4;
    v54 = strlen(v61) + 1;
    v55 = v60 + 1;
    v56 = v61;
    goto LABEL_75;
  }
  v62 = strlen(v44);
  if ( v62 >= 4 )
  {
LABEL_83:
    v63 = v62;
    if ( !strcmp(&v44[v62 - 3], "/..") )
    {
      v64 = &v44[v63 - 4];
      while ( v64 >= v44 )
      {
        v65 = v64 - 1;
        v48 = *v64-- == 47;
        if ( v48 )
        {
          v65[1] = 0;
          v62 = strlen(v44);
          if ( v62 > 3 )
            goto LABEL_83;
          break;
        }
      }
    }
  }
  v66 = *v138;
  v67 = **v138;
  if ( v67 == 47 || v67 == 46 && v66[1] == 46 && ((v68 = v66[2], v68 == 47) || !v68) )
  {
LABEL_181:
    v18 = *(const char **)&httpd_err400title;
    v19 = httpd_err400form[0];
    a1 = v1;
    goto LABEL_182;
  }
  if ( !*(_DWORD *)(v133 + 520) || (v69 = *(_QWORD *)(v133 + 160), v70 = *(_QWORD *)(v133 + 168), v70 >= v69) )
  {
LABEL_168:
    v1 = v133;
    if ( !*(_DWORD *)(v133 + 524) )
      goto LABEL_173;
    if ( **(_BYTE **)(v133 + 328) || **(_BYTE **)(v133 + 336) )
    {
      if ( *(_DWORD *)(v133 + 552) )
        *(_DWORD *)(v133 + 556) = 1;
LABEL_173:
      v103 = (char **)(v133 + 240);
      v104 = strlen(*(const char **)(v133 + 232));
      httpd_realloc_str((void **)(v133 + 240), (__int64 *)(v133 + 392), v104);
      strcpy(*(char **)(v133 + 240), *(const char **)(v133 + 232));
      v105 = *(_QWORD *)(v133 + 8);
      if ( *(_DWORD *)(v105 + 100) )
      {
        v106 = *(char **)(v133 + 328);
        if ( !*v106 )
        {
          v106 = *(char **)(v133 + 336);
          if ( !*v106 )
          {
            len = 128;
            if ( getsockname(*(_DWORD *)(v133 + 704), &s, &len) < 0 )
            {
              syslog(3, "getsockname - %m");
              goto LABEL_205;
            }
            v130 = 28;
            if ( s.sa_family != 10 )
              v130 = 0;
            v131 = 16;
            if ( s.sa_family != 2 )
              v131 = v130;
            v106 = httpd_ntoa_str;
            if ( getnameinfo(&s, v131, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
            {
              strcpy(httpd_ntoa_str, "?");
            }
            else if ( !*(_DWORD *)&s.sa_data[6]
                   && !*(_DWORD *)&s.sa_data[10]
                   && v141 == -65536
                   && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
            {
              v132 = strlen(src);
              v106 = httpd_ntoa_str;
              memmove(httpd_ntoa_str, src, v132 + 1);
            }
          }
        }
        *(_QWORD *)(v133 + 512) = v106;
        LOBYTE(v107) = *v106;
        if ( *v106 )
        {
          v108 = __ctype_b_loc();
          v109 = v106 + 1;
          do
          {
            v107 = (char)v107;
            if ( ((*v108)[(char)v107] & 0x100) != 0 )
              *(v109 - 1) = (*__ctype_tolower_loc())[v107];
            LOBYTE(v107) = *v109++;
          }
          while ( (_BYTE)v107 );
        }
        if ( !*(_DWORD *)(v133 + 532) )
        {
          v112 = strlen(*(const char **)(v133 + 512));
          httpd_realloc_str((void **)(v133 + 344), (__int64 *)(v133 + 448), v112);
          strcpy(*(char **)(v133 + 344), *(const char **)(v133 + 512));
          v113 = (int)strlen(*(const char **)(v133 + 240));
          httpd_realloc_str((void **)&vhost_map_tempfilename, &vhost_map_maxtempfilename, v113);
          strcpy(vhost_map_tempfilename, *(const char **)(v133 + 240));
          v114 = strlen(*(const char **)(v133 + 344));
          httpd_realloc_str((void **)(v133 + 240), (__int64 *)(v133 + 392), v113 + v114 + 1);
          strcpy(*(char **)(v133 + 240), *(const char **)(v133 + 344));
          v115 = *(const char **)(v133 + 240);
          *(_WORD *)&v115[strlen(v115)] = 47;
          strcat(*(char **)(v133 + 240), vhost_map_tempfilename);
        }
        v105 = *(_QWORD *)(v133 + 8);
      }
      v116 = expand_symlinks(*(char **)(v133 + 240), (char **)&s, *(_DWORD *)(v105 + 96), *(_DWORD *)(v133 + 532));
      if ( v116 )
      {
        v117 = v116;
        v118 = strlen(v116);
        httpd_realloc_str((void **)(v133 + 240), (__int64 *)(v133 + 392), v118);
        strcpy(*(char **)(v133 + 240), v117);
        v119 = *(const char **)&s.sa_family;
        v120 = strlen(*(const char **)&s.sa_family);
        httpd_realloc_str((void **)(v133 + 256), (__int64 *)(v133 + 408), v120);
        strcpy(*(char **)(v133 + 256), v119);
        v121 = *(const char **)(v133 + 256);
        if ( *v121 )
        {
          v122 = *v138;
          v123 = strlen(*v138);
          v124 = v123 - strlen(v121);
          if ( v124 > 0 && !strcmp(&v122[v124], v121) )
            v122[v124 - 1] = 0;
        }
        v125 = *v103;
        v110 = 0;
        if ( **v103 == 47 )
        {
          v126 = *(const char **)(*(_QWORD *)(v133 + 8) + 64LL);
          v127 = strlen(v126);
          if ( strncmp(v125, v126, v127) )
          {
            httpd_ntoa(v133 + 16);
            syslog(5, "%.80s URL \"%.80s\" goes outside the web tree", httpd_ntoa_str, *(const char **)(v133 + 208));
            v21 = *(char **)(v133 + 208);
            v18 = "Forbidden";
            v19 = "The requested URL '%.80s' resolves to a file outside the permitted web server directory tree.\n";
            a1 = v133;
            v20 = 403;
            goto LABEL_183;
          }
          v128 = &v125[v127];
          v129 = strlen(v128);
          memmove(v125, v128, v129 + 1);
        }
        return v110;
      }
LABEL_205:
      v21 = *(char **)(v133 + 208);
      v18 = "Internal Error";
      v19 = "There was an unusual problem serving the requested URL '%.80s'.\n";
      a1 = v133;
      v20 = 500;
      goto LABEL_183;
    }
    goto LABEL_181;
  }
  v139 = (void **)(v133 + 296);
  v135 = (__int64 *)(v133 + 432);
  v136 = v133 + 16;
  v71 = (const char **)(v133 + 288);
  v137 = (__int64 *)(v133 + 424);
  while ( 1 )
  {
    v72 = *(_QWORD *)(v133 + 144);
    v73 = v70 + 1;
    v74 = -(__int64)v69;
    while ( 1 )
    {
      v75 = *(_BYTE *)(v72 + v73 - 1);
      if ( v75 == 13 || v75 == 10 )
        break;
      *(_QWORD *)(v133 + 168) = v73;
      v76 = v74 + v73++ + 1;
      if ( v76 == 1 )
        goto LABEL_168;
    }
    *(_BYTE *)(v72 + v73 - 1) = 0;
    v77 = *(_QWORD *)(v133 + 168) + 1LL;
    *(_QWORD *)(v133 + 168) = v77;
    if ( v75 == 13 && v77 < *(_QWORD *)(v133 + 160) )
    {
      v78 = *(_QWORD *)(v133 + 144);
      if ( *(_BYTE *)(v78 + v77) != 10 )
        goto LABEL_106;
      *(_BYTE *)(v78 + v77) = 0;
      ++*(_QWORD *)(v133 + 168);
    }
    v78 = *(_QWORD *)(v133 + 144);
    if ( !v78 )
      goto LABEL_168;
LABEL_106:
    v79 = (const char *)((int)v70 + v78);
    if ( !*v79 )
      goto LABEL_168;
    if ( !strncasecmp(v79, "Referer:", 8uLL) )
    {
      v82 = (size_t)&v79[strspn(v79 + 8, " \t") + 8];
LABEL_127:
      v80 = v133;
      *(_QWORD *)(v133 + 272) = v82;
      goto LABEL_128;
    }
    if ( !strncasecmp(v79, "Referrer:", 9uLL) )
    {
      v82 = (size_t)&v79[strspn(v79 + 9, " \t") + 9];
      goto LABEL_127;
    }
    if ( !strncasecmp(v79, "User-Agent:", 0xBuLL) )
    {
      v80 = v133;
      *(_QWORD *)(v133 + 280) = &v79[strspn(v79 + 11, " \t") + 11];
      goto LABEL_128;
    }
    if ( !strncasecmp(v79, "Host:", 5uLL) )
      break;
    if ( !strncasecmp(v79, "Accept:", 7uLL) )
    {
      v85 = &v79[strspn(v79 + 7, " \t") + 7];
      if ( **v71 )
      {
        v86 = strlen(*v71);
        if ( v86 >= 0x1389 )
        {
          httpd_ntoa(v136);
          syslog(3, "%.80s way too much Accept: data", httpd_ntoa_str);
LABEL_150:
          v80 = v133;
          goto LABEL_128;
        }
        v90 = v86;
        v91 = strlen(v85);
        httpd_realloc_str((void **)v71, v137, v90 + v91 + 2);
        strcpy((char *)&(*v71)[strlen(*v71)], ", ");
      }
      else
      {
        v89 = strlen(v85);
        httpd_realloc_str((void **)v71, v137, v89);
      }
      strcat((char *)*v71, v85);
      goto LABEL_150;
    }
    if ( !strncasecmp(v79, "Accept-Encoding:", 0x10uLL) )
    {
      v87 = &v79[strspn(v79 + 16, " \t") + 16];
      if ( *(_BYTE *)*v139 )
      {
        v88 = strlen((const char *)*v139);
        if ( v88 >= 0x1389 )
        {
          httpd_ntoa(v136);
          syslog(3, "%.80s way too much Accept-Encoding: data", httpd_ntoa_str);
          goto LABEL_150;
        }
        v95 = v88;
        v96 = strlen(v87);
        httpd_realloc_str(v139, v135, v95 + v96 + 2);
        strcpy((char *)*v139 + strlen((const char *)*v139), ", ");
      }
      else
      {
        v94 = strlen(v87);
        httpd_realloc_str(v139, v135, v94);
      }
      strcpy((char *)*v139, v87);
      goto LABEL_150;
    }
    if ( !strncasecmp(v79, "Accept-Language:", 0x10uLL) )
    {
      v80 = v133;
      *(_QWORD *)(v133 + 304) = &v79[strspn(v79 + 16, " \t") + 16];
    }
    else
    {
      if ( !strncasecmp(v79, "If-Modified-Since:", 0x12uLL) )
      {
        v92 = v79 + 18;
        v93 = tdate_parse(v92);
        v80 = v133;
        *(_QWORD *)(v133 + 480) = v93;
        goto LABEL_153;
      }
      if ( !strncasecmp(v79, "Cookie:", 7uLL) )
      {
        v80 = v133;
        *(_QWORD *)(v133 + 312) = &v79[strspn(v79 + 7, " \t") + 7];
      }
      else
      {
        if ( !strncasecmp(v79, "Range:", 6uLL) )
        {
          v80 = v133;
          if ( !strchr(v79, 44) )
          {
            v97 = strchr(v79, 61);
            if ( v97 )
            {
              v98 = v97 + 1;
              v99 = strchr(v97 + 1, 45);
              if ( v99 )
              {
                v100 = v99;
                if ( v99 != v98 )
                {
                  *v99 = 0;
                  *(_DWORD *)(v133 + 528) = 1;
                  v101 = strtoll(v98, 0LL, 10);
                  if ( v101 < 0 )
                    v101 = 0LL;
                  *(_QWORD *)(v133 + 536) = v101;
                  if ( ((*__ctype_b_loc())[v100[1]] & 0x800) != 0 )
                  {
                    v102 = strtoll(v100 + 1, 0LL, 10);
                    if ( v102 < 0 )
                      v102 = -1LL;
                    *(_QWORD *)(v133 + 544) = v102;
                  }
                }
              }
            }
          }
          goto LABEL_128;
        }
        if ( !strncasecmp(v79, "Range-If:", 9uLL) || !strncasecmp(v79, "If-Range:", 9uLL) )
        {
          v92 = v79 + 9;
          v93 = tdate_parse(v92);
          v80 = v133;
          *(_QWORD *)(v133 + 488) = v93;
LABEL_153:
          if ( v93 == -1 )
            syslog(7, "unparsable time: %.80s", v92);
          goto LABEL_128;
        }
        if ( !strncasecmp(v79, "Content-Type:", 0xDuLL) )
        {
          v80 = v133;
          *(_QWORD *)(v133 + 320) = &v79[strspn(v79 + 13, " \t") + 13];
        }
        else if ( !strncasecmp(v79, "Content-Length:", 0xFuLL) )
        {
          v80 = v133;
          *(_QWORD *)(v133 + 496) = strtol(v79 + 15, 0LL, 10);
        }
        else if ( !strncasecmp(v79, "Authorization:", 0xEuLL) )
        {
          v80 = v133;
          *(_QWORD *)(v133 + 352) = &v79[strspn(v79 + 14, " \t") + 14];
        }
        else
        {
          v80 = v133;
          if ( !strncasecmp(v79, "Connection:", 0xBuLL) )
          {
            v81 = strspn(v79 + 11, " \t");
            if ( !strcasecmp(&v79[v81 + 11], "keep-alive") )
              *(_DWORD *)(v133 + 552) = 1;
          }
        }
      }
    }
LABEL_128:
    v69 = *(_QWORD *)(v80 + 160);
    v70 = *(_QWORD *)(v80 + 168);
    if ( v70 >= v69 )
      goto LABEL_168;
  }
  v83 = &v79[strspn(v79 + 5, " \t") + 5];
  v80 = v133;
  *(_QWORD *)(v133 + 336) = v83;
  v84 = strchr(v83, 58);
  if ( v84 )
  {
    *v84 = 0;
    v83 = *(const char **)(v133 + 336);
  }
  if ( !strchr(v83, 47) && *v83 != 46 )
    goto LABEL_128;
  v18 = *(const char **)&httpd_err400title;
  v19 = httpd_err400form[0];
  a1 = v133;
LABEL_182:
  v20 = 400;
  v21 = (char *)"";
LABEL_183:
  httpd_send_err(a1, v20, v18, (char *)"", v19, v21);
  return (unsigned int)-1;
}
// 193A8: using guessed type char *httpd_err400form[5];
// 1B1E0: using guessed type __int64 vhost_map_maxtempfilename;

//----- (000000000000B710) ----------------------------------------------------
char *__fastcall expand_symlinks(char *src, char **a2, int a3, int a4)
{
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rax
  char *v7; // rcx
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r15
  char *v10; // r14
  size_t v11; // rax
  __int64 v12; // r12
  char *v13; // rax
  int v14; // ebp
  size_t v15; // rdx
  __int64 v16; // r13
  __int64 v17; // rbx
  __int64 v18; // r13
  __int64 v19; // r13
  unsigned __int64 v20; // rbx
  unsigned __int64 v21; // rax
  ssize_t v22; // rax
  unsigned int v23; // eax
  char *v24; // r12
  char *v25; // rax
  char *v26; // rbp
  char *v27; // rax
  unsigned __int64 v28; // rbp
  char v29; // cl
  bool v30; // zf
  char *v31; // r15
  size_t v32; // rax
  __int64 v33; // rdi
  __int64 v34; // rax
  __int64 v35; // rbx
  char *v36; // rbx
  int v37; // ecx
  int v39; // [rsp+Ch] [rbp-13CCh]
  char *v40; // [rsp+18h] [rbp-13C0h]
  struct stat buf; // [rsp+20h] [rbp-13B8h] BYREF

  if ( a3 && stat(src, &buf) != -1 )
  {
    v5 = strlen(src);
    httpd_realloc_str((void **)&expand_symlinks_checked, &expand_symlinks_maxchecked, v5);
    strcpy(expand_symlinks_checked, src);
    if ( expand_symlinks_checked[v5 - 1] == 47 )
    {
      v6 = v5 - 1;
      v7 = &expand_symlinks_checked[v5 - 1];
      v8 = v5 - 2;
      do
      {
        *v7 = 0;
        v7 = &expand_symlinks_checked[--v6];
        v30 = expand_symlinks_checked[v8--] == 47;
      }
      while ( v30 );
    }
    httpd_realloc_str((void **)&expand_symlinks_rest, &expand_symlinks_maxrest, 0LL);
    *expand_symlinks_rest = 0;
    *a2 = expand_symlinks_rest;
    return expand_symlinks_checked;
  }
  httpd_realloc_str((void **)&expand_symlinks_checked, &expand_symlinks_maxchecked, 1uLL);
  *expand_symlinks_checked = 0;
  v9 = strlen(src);
  httpd_realloc_str((void **)&expand_symlinks_rest, &expand_symlinks_maxrest, v9);
  v40 = src;
  strcpy(expand_symlinks_rest, src);
  if ( expand_symlinks_rest[v9 - 1] == 47 )
    expand_symlinks_rest[--v9] = 0;
  v10 = expand_symlinks_rest;
  if ( !a4 )
  {
    while ( *v10 == 47 )
    {
      v11 = strlen(v10 + 1);
      memmove(v10, v10 + 1, v11 + 1);
      --v9;
      v10 = expand_symlinks_rest;
    }
  }
  if ( !v9 )
  {
LABEL_71:
    *a2 = v10;
    v36 = expand_symlinks_checked;
    if ( !*expand_symlinks_checked )
    {
      *(_WORD *)expand_symlinks_checked = 46;
      return expand_symlinks_checked;
    }
    return v36;
  }
  v39 = 0;
  v12 = 0LL;
  while ( 1 )
  {
    while ( 1 )
    {
      v13 = strchr(v10, 47);
      if ( v13 )
      {
        v14 = (_DWORD)v13 - (_DWORD)v10;
        if ( (_DWORD)v13 == (_DWORD)v10 )
        {
          v19 = v12 + 1;
          httpd_realloc_str((void **)&expand_symlinks_checked, &expand_symlinks_maxchecked, v12 + 1);
          strncpy(&expand_symlinks_checked[v12], v10, 1uLL);
        }
        else
        {
          v15 = (unsigned int)v14;
          if ( v14 < 3 )
            v15 = 2LL;
          if ( strncmp(v10, "..", v15) )
          {
            v16 = v12;
            httpd_realloc_str((void **)&expand_symlinks_checked, &expand_symlinks_maxchecked, v14 + v12 + 1);
            if ( v12 )
            {
              v17 = v12;
              if ( expand_symlinks_checked[v12 - 1] != 47 )
              {
                v16 = v12 + 1;
                expand_symlinks_checked[v12] = 47;
              }
            }
            else
            {
              v17 = 0LL;
              v16 = 0LL;
            }
            strncpy(&expand_symlinks_checked[v16], v10, v14);
            v19 = v14 + v16;
LABEL_35:
            v12 = v17;
            goto LABEL_36;
          }
          if ( v12 )
          {
            v17 = v12;
            v24 = expand_symlinks_checked;
            v25 = strrchr(expand_symlinks_checked, 47);
            if ( v25 )
            {
              v19 = v25 - v24;
              if ( v25 == v24 )
                v19 = 1LL;
            }
            else
            {
              v19 = 0LL;
            }
            goto LABEL_35;
          }
          v19 = 0LL;
        }
LABEL_36:
        expand_symlinks_checked[v19] = 0;
        v21 = v14 + 1;
        v20 = v9 - v21;
        goto LABEL_41;
      }
      if ( strcmp(v10, "..") )
      {
        httpd_realloc_str((void **)&expand_symlinks_checked, &expand_symlinks_maxchecked, v12 + v9 + 1);
        if ( v12 )
        {
          v18 = v12;
          if ( expand_symlinks_checked[v12 - 1] != 47 )
          {
            v18 = v12 + 1;
            expand_symlinks_checked[v12] = 47;
          }
        }
        else
        {
          v18 = 0LL;
        }
        strcpy(&expand_symlinks_checked[v18], v10);
        v19 = v9 + v18;
LABEL_39:
        v20 = 0LL;
        goto LABEL_40;
      }
      if ( v12 )
      {
        v26 = expand_symlinks_checked;
        v27 = strrchr(expand_symlinks_checked, 47);
        if ( v27 )
        {
          v19 = v27 - v26;
          if ( v27 == v26 )
            v19 = 1LL;
          v26[v19] = 0;
        }
        else
        {
          v19 = 0LL;
          *v26 = 0;
        }
        goto LABEL_39;
      }
      v20 = 0LL;
      v19 = 0LL;
LABEL_40:
      v21 = v9;
LABEL_41:
      v10 += v21;
      if ( *expand_symlinks_checked )
        break;
LABEL_15:
      v12 = v19;
      v9 = v20;
      if ( !v20 )
        goto LABEL_71;
    }
    v22 = readlink(expand_symlinks_checked, (char *)&buf, 0x1387uLL);
    if ( v22 == -1 )
      break;
    if ( v39 == 32 )
    {
      v36 = 0LL;
      syslog(3, "too many symlinks in %.80s", v40);
      return v36;
    }
    *((_BYTE *)&buf.st_dev + v22) = 0;
    v28 = v22 - 1;
    v29 = *((_BYTE *)&v40 + v22 + 7);
    v30 = v29 == 47;
    if ( v29 == 47 )
      v29 = 0;
    *((_BYTE *)&v40 + v22 + 7) = v29;
    if ( !v30 )
      v28 = v22;
    if ( v20 )
    {
      v31 = expand_symlinks_rest;
      v32 = strlen(v10);
      memmove(v31, v10, v32 + 1);
      v9 = v20 + v28 + 1;
      httpd_realloc_str((void **)&expand_symlinks_rest, &expand_symlinks_maxrest, v9);
      if ( (v20 & 0x80000000) == 0LL )
      {
        v33 = (unsigned int)v20;
        v34 = (unsigned int)v20;
        v35 = ((_BYTE)v20 + 1) & 3;
        if ( v35 )
        {
          v34 = v33;
          do
          {
            expand_symlinks_rest[v28 + 1 + v34] = expand_symlinks_rest[v34];
            --v34;
            --v35;
          }
          while ( v35 );
        }
        if ( (unsigned int)v33 >= 3 )
        {
          do
          {
            expand_symlinks_rest[v28 + 1 + v34] = expand_symlinks_rest[v34];
            expand_symlinks_rest[v28 + v34] = expand_symlinks_rest[v34 - 1];
            expand_symlinks_rest[v28 - 1 + v34] = expand_symlinks_rest[v34 - 2];
            expand_symlinks_rest[v28 - 2 + v34] = expand_symlinks_rest[v34 - 3];
            v34 -= 4LL;
          }
          while ( v34 != -1 );
        }
      }
      strcpy(expand_symlinks_rest, (const char *)&buf);
      expand_symlinks_rest[v28] = 47;
    }
    else
    {
      httpd_realloc_str((void **)&expand_symlinks_rest, &expand_symlinks_maxrest, v28);
      strcpy(expand_symlinks_rest, (const char *)&buf);
      v9 = v28;
    }
    ++v39;
    v10 = expand_symlinks_rest;
    if ( *expand_symlinks_rest == 47 )
      v12 = 0LL;
    expand_symlinks_checked[v12] = 0;
    if ( !v9 )
      goto LABEL_71;
  }
  v23 = *__errno_location();
  if ( v23 == 22 )
    goto LABEL_15;
  if ( v23 > 0x14 || (v37 = 1056772, !_bittest(&v37, v23)) )
  {
    v36 = 0LL;
    syslog(3, "readlink %.80s - %m", expand_symlinks_checked);
    return v36;
  }
  *a2 = &v10[v20 - v9];
  if ( v12 )
    expand_symlinks_checked[v12] = 0;
  else
    *(_WORD *)expand_symlinks_checked = 46;
  return expand_symlinks_checked;
}
// 1B1F8: using guessed type __int64 expand_symlinks_maxchecked;
// 1B200: using guessed type __int64 expand_symlinks_maxrest;

//----- (000000000000BD70) ----------------------------------------------------
void __fastcall httpd_close_conn(__int64 a1, time_t *a2)
{
  __int64 v4; // rax
  const char *v5; // r15
  const char *v6; // rcx
  __int64 v7; // rcx
  time_t v8; // rax
  const struct sockaddr *v9; // rdi
  __int16 v10; // ax
  int v11; // edx
  socklen_t v12; // esi
  struct tm *v13; // r13
  __int64 tm_gmtoff; // rcx
  unsigned int v15; // r9d
  FILE *v16; // r12
  const struct sockaddr *v17; // rdi
  __int16 v18; // ax
  int v19; // ecx
  socklen_t v20; // esi
  size_t v21; // rax
  unsigned int v22; // eax
  const char *v23; // r9
  size_t v24; // rax
  unsigned int v25; // eax
  const char *v26; // r8
  __int64 v27; // rdi
  int v28; // edi
  time_t timer; // [rsp+38h] [rbp-280h] BYREF
  __int16 v30[24]; // [rsp+40h] [rbp-278h] BYREF
  char v31[112]; // [rsp+70h] [rbp-248h] BYREF
  char v32[320]; // [rsp+E0h] [rbp-1D8h] BYREF
  char s[152]; // [rsp+220h] [rbp-98h] BYREF

  v4 = *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(v4 + 80) )
  {
    v5 = "-";
    if ( **(_BYTE **)(a1 + 360) )
      v5 = *(const char **)(a1 + 360);
    if ( *(_DWORD *)(v4 + 100) && !*(_DWORD *)(a1 + 532) )
    {
      v6 = *(const char **)(a1 + 512);
      if ( !v6 )
        v6 = *(const char **)(v4 + 8);
      my_snprintf(v32, 0x131uLL, "/%.100s%.200s", v6, *(const char **)(a1 + 208));
    }
    else
    {
      my_snprintf(v32, 0x131uLL, "%.200s", *(const char **)(a1 + 208));
    }
    v7 = *(_QWORD *)(a1 + 200);
    if ( v7 < 0 )
      v30[0] = 45;
    else
      my_snprintf((char *)v30, 0x28uLL, "%lld", v7);
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 8) + 88LL) )
    {
      if ( a2 )
        v8 = *a2;
      else
        v8 = time(0LL);
      timer = v8;
      v13 = localtime(&timer);
      strftime(s, 0x64uLL, "%d/%b/%Y:%H:%M:%S", v13);
      tm_gmtoff = v13->tm_gmtoff;
      v15 = (int)tm_gmtoff / -60;
      if ( (int)tm_gmtoff / -60 < 0 )
        v15 = (int)tm_gmtoff / 60;
      my_snprintf(
        v31,
        0x64uLL,
        "%s %c%04d",
        s,
        2 * ((unsigned int)((int)tm_gmtoff / 60) >> 31) + 43,
        100 * (v15 / 0x3C) + v15 % 0x3C);
      v16 = *(FILE **)(*(_QWORD *)(a1 + 8) + 88LL);
      v17 = (const struct sockaddr *)(a1 + 16);
      v18 = *(_WORD *)(a1 + 16);
      v19 = 28;
      if ( v18 != 10 )
        v19 = 0;
      v20 = 16;
      if ( v18 != 2 )
        v20 = v19;
      if ( getnameinfo(v17, v20, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
      {
        strcpy(httpd_ntoa_str, "?");
      }
      else if ( !*(_DWORD *)(a1 + 24)
             && !*(_DWORD *)(a1 + 28)
             && *(_DWORD *)(a1 + 32) == -65536
             && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
      {
        v21 = strlen(src);
        memmove(httpd_ntoa_str, src, v21 + 1);
      }
      v22 = *(_DWORD *)(a1 + 180) - 1;
      if ( v22 > 5 )
        v23 = "UNKNOWN";
      else
        v23 = (&off_18DA0)[v22];
      fprintf(
        v16,
        "%.80s - %.80s [%s] \"%.80s %.300s %.80s\" %d %s \"%.200s\" \"%.200s\"\n",
        httpd_ntoa_str,
        v5,
        v31,
        v23,
        v32,
        *(const char **)(a1 + 224),
        *(_DWORD *)(a1 + 184),
        (const char *)v30,
        *(const char **)(a1 + 272),
        *(const char **)(a1 + 280));
      fflush(*(FILE **)(*(_QWORD *)(a1 + 8) + 88LL));
    }
    else
    {
      v9 = (const struct sockaddr *)(a1 + 16);
      v10 = *(_WORD *)(a1 + 16);
      v11 = 28;
      if ( v10 != 10 )
        v11 = 0;
      v12 = 16;
      if ( v10 != 2 )
        v12 = v11;
      if ( getnameinfo(v9, v12, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
      {
        strcpy(httpd_ntoa_str, "?");
      }
      else if ( !*(_DWORD *)(a1 + 24)
             && !*(_DWORD *)(a1 + 28)
             && *(_DWORD *)(a1 + 32) == -65536
             && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
      {
        v24 = strlen(src);
        memmove(httpd_ntoa_str, src, v24 + 1);
      }
      v25 = *(_DWORD *)(a1 + 180) - 1;
      if ( v25 > 5 )
        v26 = "UNKNOWN";
      else
        v26 = (&off_18DA0)[v25];
      syslog(
        6,
        "%.80s - %.80s \"%.80s %.200s %.80s\" %d %s \"%.200s\" \"%.200s\"",
        httpd_ntoa_str,
        v5,
        v26,
        v32,
        *(const char **)(a1 + 224),
        *(_DWORD *)(a1 + 184),
        (const char *)v30,
        *(const char **)(a1 + 272),
        *(const char **)(a1 + 280));
    }
  }
  v27 = *(_QWORD *)(a1 + 712);
  if ( v27 )
  {
    mmc_unmap(v27, (__int64 *)(a1 + 560), a2);
    *(_QWORD *)(a1 + 712) = 0LL;
  }
  v28 = *(_DWORD *)(a1 + 704);
  if ( v28 >= 0 )
  {
    close(v28);
    *(_DWORD *)(a1 + 704) = -1;
  }
}
// 18DA0: using guessed type char *off_18DA0;

//----- (000000000000C1A0) ----------------------------------------------------
void __fastcall httpd_destroy_conn(__int64 a1)
{
  if ( *(_DWORD *)a1 )
  {
    free(*(void **)(a1 + 144));
    free(*(void **)(a1 + 216));
    free(*(void **)(a1 + 232));
    free(*(void **)(a1 + 240));
    free(*(void **)(a1 + 248));
    free(*(void **)(a1 + 256));
    free(*(void **)(a1 + 264));
    free(*(void **)(a1 + 288));
    free(*(void **)(a1 + 296));
    free(*(void **)(a1 + 328));
    free(*(void **)(a1 + 344));
    free(*(void **)(a1 + 360));
    free(*(void **)(a1 + 368));
    *(_DWORD *)a1 = 0;
  }
}

//----- (000000000000C260) ----------------------------------------------------
__int64 __fastcall httpd_start_request(__int64 a1, time_t *a2)
{
  time_t *v2; // r15
  __int64 v3; // r13
  const char *v4; // rbx
  unsigned __int64 v5; // r12
  const char **v6; // r14
  char *v7; // r9
  const char *v8; // rdx
  const char *v9; // r8
  unsigned int v10; // esi
  const struct sockaddr *v11; // rdi
  __int16 v12; // ax
  int v13; // edx
  socklen_t v14; // esi
  size_t v15; // rax
  const char *v16; // rbx
  unsigned __int64 v17; // r12
  __int64 v18; // r13
  const char *v19; // r15
  size_t v20; // rax
  void **v21; // rbp
  char *v22; // r14
  size_t v23; // rax
  __int64 v24; // rbx
  __int16 v25; // ax
  int v26; // edx
  socklen_t v27; // esi
  char *v28; // rax
  const char *v29; // rbx
  unsigned int v30; // ebp
  __int64 v32; // rax
  char *v33; // r15
  char *v34; // rsi
  DIR *v35; // rax
  DIR *v36; // r15
  int v37; // eax
  const char *v38; // rbp
  const char *v39; // rbx
  char *v40; // rax
  size_t v41; // rbp
  size_t v42; // rax
  char *v43; // rbx
  char *v44; // rax
  char *v45; // rbx
  __int64 v46; // rax
  char *v47; // rsi
  __int16 v48; // ax
  int v49; // edx
  socklen_t v50; // esi
  const char *v51; // rbx
  char *v52; // rdi
  __int64 v53; // rax
  int v54; // edx
  int v55; // ecx
  __int16 v56; // ax
  int v57; // edx
  socklen_t v58; // esi
  __int16 v59; // ax
  int v60; // edx
  socklen_t v61; // esi
  size_t v62; // rax
  int v63; // eax
  __int64 v64; // rcx
  __int64 v65; // rax
  const char *v66; // rbx
  const char *v67; // rax
  __int64 v68; // rbp
  unsigned __int64 v69; // r14
  const char *v70; // r12
  __int64 v71; // r15
  const char *v72; // rax
  const char *v73; // rdi
  int v74; // eax
  int v75; // ecx
  size_t v76; // rax
  char *v77; // r9
  const char *v78; // r8
  size_t v79; // rax
  size_t v80; // rax
  size_t v81; // rax
  int v82; // ebx
  int v83; // eax
  __pid_t v84; // eax
  unsigned int v85; // ebx
  size_t v86; // rax
  unsigned int v87; // eax
  char *v88; // r9
  __int16 v89; // ax
  int v90; // edx
  socklen_t v91; // esi
  __int64 v92; // rax
  int v93; // edx
  int v94; // ecx
  unsigned int v95; // eax
  size_t v96; // rax
  __pid_t v97; // eax
  unsigned int v98; // r12d
  int v99; // r12d
  int v100; // r15d
  int v101; // ebx
  __int64 v102; // rbp
  int v103; // eax
  void **v104; // r13
  char *v105; // r12
  char *v106; // rdi
  __int64 v107; // r15
  char *v108; // rbp
  __int64 v109; // rcx
  __ino_t v110; // rax
  __int64 v111; // rbx
  int v112; // edi
  int v113; // edi
  unsigned int v114; // edi
  int v115; // eax
  __int64 v116; // rax
  const char *v117; // rsi
  unsigned int v118; // r12d
  unsigned int v119; // eax
  const char *v120; // rsi
  const char *v121; // rsi
  unsigned int v122; // ebp
  const char *v123; // rsi
  const char *v124; // r14
  size_t v125; // rbx
  const char *v126; // r15
  size_t v127; // r13
  char *v128; // rax
  const char *v129; // rbx
  const char *v130; // rbx
  const char *v131; // rsi
  unsigned int v132; // ebx
  const char *v133; // rsi
  __int16 v134; // ax
  int v135; // edx
  socklen_t v136; // esi
  size_t v137; // rax
  unsigned int v138; // ebp
  const char *v139; // rsi
  const char *v140; // rsi
  char *v141; // rax
  __int64 v142; // rcx
  const char *v143; // rsi
  char *v144; // rax
  __int64 v145; // rcx
  const char *v146; // rsi
  char *v147; // rax
  __int64 v148; // rcx
  const char *v149; // rsi
  char *v150; // rax
  __int64 v151; // rcx
  const char *v152; // rsi
  char *v153; // rax
  __int64 v154; // rcx
  const char *v155; // rsi
  char *v156; // rax
  __int64 v157; // rcx
  const char *v158; // rsi
  char *v159; // rax
  __int64 v160; // rcx
  __int64 v161; // rcx
  char *v162; // rax
  __int64 v163; // rcx
  const char *v164; // rsi
  char *v165; // rax
  __int64 v166; // rcx
  char *v167; // rax
  __int64 v168; // rcx
  char *v169; // rax
  char *v170; // rax
  __int64 v171; // rcx
  const char *v172; // r15
  size_t v173; // rax
  const char *v174; // r14
  char *v175; // rax
  char *v176; // rcx
  int v177; // r14d
  const char *i; // rbp
  __int64 v179; // rax
  char *v180; // rbx
  char *k; // r13
  char v182; // dl
  const unsigned __int16 **v183; // rax
  const unsigned __int16 *v184; // rcx
  __int64 v185; // rsi
  __int64 v186; // rax
  char v187; // cl
  char v188; // cl
  char v189; // dl
  char *v190; // rbx
  char *j; // rbp
  char v192; // dl
  const unsigned __int16 **v193; // rax
  const unsigned __int16 *v194; // rcx
  __int64 v195; // rsi
  __int64 v196; // rax
  char v197; // cl
  char v198; // cl
  char v199; // dl
  __int64 v200; // rax
  __pid_t v201; // eax
  int v202; // edi
  int v203; // eax
  int v204; // edi
  const char *v205; // r14
  char *v206; // rax
  const char *v207; // rbp
  char *v208; // rax
  __int64 v209; // rbp
  int v210; // edi
  int v211; // edi
  __pid_t v212; // eax
  __int64 v213; // rbx
  struct dirent *v214; // rax
  struct dirent *v215; // r14
  _QWORD *v216; // r12
  const char *d_name; // r14
  size_t v218; // rbp
  __int64 v219; // r13
  char *v220; // rbp
  void *v221; // rax
  void *v222; // rax
  __int64 v223; // rdx
  __int64 v224; // rsi
  char *v225; // rcx
  __int64 v226; // rsi
  __int64 v227; // rdx
  int v228; // edi
  struct stat *v229; // rbx
  const char *v230; // rbp
  const char *v231; // rbx
  size_t v232; // r14
  size_t v233; // rax
  size_t v234; // r14
  size_t v235; // rax
  const char *v236; // rbp
  const char *v237; // rbp
  const char **v238; // rbp
  size_t v239; // rax
  char *v240; // rbp
  int v241; // ebx
  char *v242; // r12
  char v243; // r15
  const unsigned __int16 **v244; // r13
  char *v245; // r12
  int v246; // r14d
  int v247; // eax
  __int64 v248; // rcx
  int v249; // ecx
  int v250; // eax
  const char *v251; // r14
  char v252; // cl
  char v253; // dl
  char v254; // al
  time_t v255; // rbp
  char *v256; // rax
  __int16 v257; // dx
  int v258; // edx
  char *s1; // [rsp+0h] [rbp-11E8h]
  char *s1a; // [rsp+0h] [rbp-11E8h]
  char *s1b; // [rsp+0h] [rbp-11E8h]
  char *s1c; // [rsp+0h] [rbp-11E8h]
  struct stat *buf; // [rsp+8h] [rbp-11E0h]
  const char **bufa; // [rsp+8h] [rbp-11E0h]
  unsigned int bufb; // [rsp+8h] [rbp-11E0h]
  struct stat *bufc; // [rsp+8h] [rbp-11E0h]
  unsigned int stream; // [rsp+10h] [rbp-11D8h]
  FILE *streama; // [rsp+10h] [rbp-11D8h]
  time_t *v269; // [rsp+18h] [rbp-11D0h]
  const char **v270; // [rsp+18h] [rbp-11D0h]
  unsigned __int64 v271; // [rsp+18h] [rbp-11D0h]
  char v272[32]; // [rsp+20h] [rbp-11C8h] BYREF
  size_t v273; // [rsp+40h] [rbp-11A8h]
  const char *v274; // [rsp+48h] [rbp-11A0h]
  char *v275; // [rsp+50h] [rbp-1198h]
  size_t v276; // [rsp+58h] [rbp-1190h]
  char *s2; // [rsp+60h] [rbp-1188h]
  size_t n; // [rsp+68h] [rbp-1180h]
  char *v279; // [rsp+70h] [rbp-1178h]
  __int64 v280; // [rsp+78h] [rbp-1170h]
  __int64 v281; // [rsp+80h] [rbp-1168h]
  __int64 v282; // [rsp+88h] [rbp-1160h]
  struct stat v283; // [rsp+90h] [rbp-1158h] BYREF
  struct stat v284; // [rsp+120h] [rbp-10C8h] BYREF
  int pipedes[2]; // [rsp+1B0h] [rbp-1038h] BYREF

  v2 = a2;
  v3 = a1;
  v4 = *(const char **)(a1 + 240);
  v5 = strlen(v4);
  buf = (struct stat *)(a1 + 560);
  if ( stat(v4, (struct stat *)(a1 + 560)) < 0 )
    goto LABEL_39;
  if ( (*(_DWORD *)(a1 + 584) & 5) == 0 )
  {
    v11 = (const struct sockaddr *)(a1 + 16);
    v12 = *(_WORD *)(v3 + 16);
    v13 = 28;
    if ( v12 != 10 )
      v13 = 0;
    v14 = 16;
    if ( v12 != 2 )
      v14 = v13;
    if ( getnameinfo(v11, v14, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
    {
      strcpy(httpd_ntoa_str, "?");
    }
    else if ( !*(_DWORD *)(v3 + 24)
           && !*(_DWORD *)(v3 + 28)
           && *(_DWORD *)(v3 + 32) == -65536
           && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
    {
      v15 = strlen(src);
      memmove(httpd_ntoa_str, src, v15 + 1);
    }
    syslog(6, "%.80s URL \"%.80s\" resolves to a non world-readable file", httpd_ntoa_str, *(const char **)(v3 + 208));
    v7 = *(char **)(v3 + 208);
    v8 = "Forbidden";
    v9 = "The requested URL '%.80s' resolves to a file that is not world-readable.\n";
    goto LABEL_18;
  }
  v6 = (const char **)(a1 + 240);
  if ( (*(_DWORD *)(a1 + 584) & 0xF000) == 0x4000 )
  {
    if ( **(_BYTE **)(a1 + 256) )
    {
      v7 = *(char **)(a1 + 208);
      v8 = "Not Found";
      v9 = "The requested URL '%.80s' was not found on this server.\n";
      v10 = 404;
      goto LABEL_41;
    }
    v16 = *(const char **)(a1 + 232);
    if ( *v16 && strcmp(*(const char **)(a1 + 232), ".") && v16[strlen(v16) - 1] != 47 )
    {
      v38 = *(const char **)(a1 + 208);
      v39 = *(const char **)(a1 + 264);
      if ( *v39 )
      {
        v40 = strchr(*(const char **)(a1 + 208), 63);
        if ( v40 )
        {
          *v40 = 0;
          v38 = *(const char **)(a1 + 208);
          v39 = *(const char **)(a1 + 264);
        }
        v41 = strlen(v38);
        v42 = strlen(v39);
        httpd_realloc_str((void **)&send_dirredirect_location, &send_dirredirect_maxlocation, v42 + v41 + 2);
        my_snprintf(
          send_dirredirect_location,
          send_dirredirect_maxlocation,
          "%s/?%s",
          *(const char **)(a1 + 208),
          *(const char **)(a1 + 264));
      }
      else
      {
        v80 = strlen(*(const char **)(a1 + 208));
        httpd_realloc_str((void **)&send_dirredirect_location, &send_dirredirect_maxlocation, v80 + 1);
        my_snprintf(send_dirredirect_location, send_dirredirect_maxlocation, "%s/", *(const char **)(a1 + 208));
      }
      v81 = strlen(send_dirredirect_location);
      httpd_realloc_str((void **)&send_dirredirect_header, &send_dirredirect_maxheader, v81 + 11);
      my_snprintf(
        (char *)send_dirredirect_header,
        send_dirredirect_maxheader,
        "%s%s\r\n",
        send_dirredirect_headstr,
        send_dirredirect_location);
      send_response(
        a1,
        0x12Eu,
        "Found",
        (char *)send_dirredirect_header,
        "The actual URL is '%.80s'.\n",
        send_dirredirect_location);
      return (unsigned int)-1;
    }
    s1 = (char *)a1;
    v17 = v5 + 1;
    v18 = 0LL;
    while ( 1 )
    {
      v19 = (&really_start_request_index_names)[v18];
      v20 = strlen(v19);
      httpd_realloc_str((void **)&really_start_request_indexname, &really_start_request_maxindexname, v20 + v17);
      v21 = (void **)v6;
      strcpy(really_start_request_indexname, *v6);
      v22 = really_start_request_indexname;
      v23 = strlen(really_start_request_indexname);
      if ( !v23 || v22[v23 - 1] != 47 )
      {
        *(_WORD *)&v22[strlen(v22)] = 47;
        v22 = really_start_request_indexname;
      }
      if ( !strcmp(v22, "./") )
      {
        *v22 = 0;
        v22 = really_start_request_indexname;
      }
      strcat(v22, v19);
      if ( stat(really_start_request_indexname, buf) >= 0 )
        break;
      ++v18;
      v6 = (const char **)v21;
      if ( v18 == 6 )
      {
        v24 = a1;
        if ( (*(_BYTE *)(a1 + 584) & 4) == 0 )
        {
          v25 = *(_WORD *)(a1 + 16);
          v26 = 28;
          if ( v25 != 10 )
            v26 = 0;
          v27 = 16;
          if ( v25 != 2 )
            v27 = v26;
          if ( getnameinfo((const struct sockaddr *)(a1 + 16), v27, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
          {
            strcpy(httpd_ntoa_str, "?");
          }
          else if ( !*(_DWORD *)(a1 + 24)
                 && !*(_DWORD *)(a1 + 28)
                 && *(_DWORD *)(a1 + 32) == -65536
                 && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
          {
            v79 = strlen(src);
            memmove(httpd_ntoa_str, src, v79 + 1);
          }
          syslog(
            6,
            "%.80s URL \"%.80s\" tried to index a directory with indexing disabled",
            httpd_ntoa_str,
            *(const char **)(a1 + 208));
          v7 = *(char **)(a1 + 208);
          v8 = "Forbidden";
          v9 = "The requested URL '%.80s' resolves to a directory that has indexing disabled.\n";
          v10 = 403;
          goto LABEL_41;
        }
        v32 = *(_QWORD *)(a1 + 8);
        v33 = *(char **)(a1 + 240);
        if ( !*(_DWORD *)(v32 + 104) )
          goto LABEL_50;
        if ( !*(_DWORD *)(v32 + 100) || (v34 = *(char **)(a1 + 344), !*v34) )
          v34 = (char *)".";
        v30 = auth_check2(a1, v34);
        if ( v30 == -1 )
          return v30;
        if ( v30 != 1 )
        {
LABEL_50:
          if ( (unsigned int)auth_check2(a1, v33) == -1 )
            return (unsigned int)-1;
        }
        v30 = -1;
        if ( !(unsigned int)check_referrer(a1) )
          return v30;
        v35 = opendir(*v6);
        if ( !v35 )
        {
          syslog(3, "opendir %.80s - %m", *(const char **)(a1 + 240));
          v7 = *(char **)(a1 + 208);
          v8 = "Not Found";
          v9 = "The requested URL '%.80s' was not found on this server.\n";
          v10 = 404;
          goto LABEL_41;
        }
        v36 = v35;
        v37 = *(_DWORD *)(a1 + 180);
        if ( v37 != 1 )
        {
          if ( v37 == 2 )
          {
            closedir(v36);
            send_mime(a1, 0xC8u, "OK", "", (char *)"", "text/html; charset=%s", -1LL, *(_QWORD *)(a1 + 648));
            return 0;
          }
          closedir(v36);
          v95 = *(_DWORD *)(a1 + 180) - 1;
          if ( v95 > 5 )
            v88 = "UNKNOWN";
          else
            v88 = (&off_18DA0)[v95];
          v30 = -1;
LABEL_186:
          httpd_send_err(
            a1,
            0x1F5u,
            "Not Implemented",
            (char *)"",
            "The requested method '%.80s' is not implemented by this server.\n",
            v88);
          return v30;
        }
        v92 = *(_QWORD *)(a1 + 8);
        v93 = *(_DWORD *)(v92 + 32);
        v94 = *(_DWORD *)(v92 + 36);
        if ( v93 && v94 >= v93 )
        {
          closedir(v36);
          v8 = *(const char **)&httpd_err503title;
          v9 = httpd_err503form;
          v7 = *(char **)(a1 + 208);
          v10 = 503;
          goto LABEL_41;
        }
        *(_DWORD *)(v92 + 36) = v94 + 1;
        v97 = fork();
        if ( v97 < 0 )
        {
          syslog(3, "fork - %m");
          closedir(v36);
          goto LABEL_211;
        }
        if ( v97 )
        {
          v98 = v97;
          closedir(v36);
          v30 = 0;
          syslog(7, "spawned indexing process %d for directory '%.200s'", v98, *v6);
          if ( tmr_create(0LL, (__time_t)cgi_kill, v98, 30000LL, 0) )
          {
            *(_DWORD *)(a1 + 184) = 200;
            *(_QWORD *)(a1 + 200) = 25000LL;
            *(_DWORD *)(a1 + 556) = 0;
            return v30;
          }
          v121 = "tmr_create(cgi_kill ls) failed";
          goto LABEL_232;
        }
        sub_process = 1;
        v209 = *(_QWORD *)(a1 + 8);
        v210 = *(_DWORD *)(v209 + 72);
        if ( v210 != -1 )
        {
          close(v210);
          *(_DWORD *)(v209 + 72) = -1;
        }
        v211 = *(_DWORD *)(v209 + 76);
        if ( v211 != -1 )
        {
          close(v211);
          *(_DWORD *)(v209 + 76) = -1;
        }
        send_mime((__int64)s1, 0xC8u, "OK", "", (char *)"", "text/html; charset=%s", -1LL, *((_QWORD *)s1 + 81));
        httpd_write_response((__int64)s1);
        nice(10);
        streama = fdopen(*((_DWORD *)s1 + 176), "w");
        if ( !streama )
        {
          syslog(3, "fdopen - %m");
          httpd_send_err(
            (__int64)s1,
            0x1F4u,
            "Internal Error",
            (char *)"",
            "There was an unusual problem serving the requested URL '%.80s'.\n",
            *((char **)s1 + 26));
          httpd_write_response((__int64)s1);
          closedir(v36);
          exit(1);
        }
        LODWORD(v213) = 0;
        fprintf(
          streama,
          "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n"
          "\n"
          "<html>\n"
          "\n"
          "  <head>\n"
          "    <meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\">\n"
          "    <title>Index of %.80s</title>\n"
          "  </head>\n"
          "\n"
          "  <body bgcolor=\"#99cc99\" text=\"#000000\" link=\"#2020ff\" vlink=\"#4040cc\">\n"
          "\n"
          "    <h2>Index of %.80s</h2>\n"
          "\n"
          "    <pre>\n"
          "mode  links    bytes  last-changed  name\n"
          "    <hr>",
          *((const char **)s1 + 26),
          *((const char **)s1 + 26));
        v214 = readdir(v36);
        if ( !v214 )
        {
LABEL_356:
          closedir(v36);
          v271 = (unsigned int)v213;
          qsort(ls_nameptrs, (unsigned int)v213, 8uLL, (__compar_fn_t)name_compare);
          if ( (_DWORD)v213 )
          {
            v229 = 0LL;
            do
            {
              v232 = strlen(*((const char **)s1 + 30));
              v233 = strlen(*((const char **)ls_nameptrs + (_QWORD)v229));
              httpd_realloc_str((void **)&ls_name, &ls_maxname, v232 + v233 + 1);
              v234 = strlen(*((const char **)s1 + 29));
              v235 = strlen(*((const char **)ls_nameptrs + (_QWORD)v229));
              httpd_realloc_str((void **)&ls_rname, &ls_maxrname, v234 + v235 + 1);
              v236 = (const char *)*((_QWORD *)s1 + 30);
              bufc = v229;
              if ( !*v236 || !strcmp(v236, ".") )
              {
                v238 = (const char **)ls_nameptrs;
                strcpy(ls_name, *((const char **)ls_nameptrs + (_QWORD)v229));
                strcpy(ls_rname, v238[(_QWORD)v229]);
              }
              else
              {
                my_snprintf(ls_name, ls_maxname, "%s/%s", v236, *((const char **)ls_nameptrs + (_QWORD)v229));
                v237 = (const char *)*((_QWORD *)s1 + 29);
                if ( !strcmp(v237, ".") )
                  my_snprintf(ls_rname, ls_maxrname, "%s", *((const char **)ls_nameptrs + (_QWORD)v229));
                else
                  my_snprintf(ls_rname, ls_maxrname, "%s%s", v237, *((const char **)ls_nameptrs + (_QWORD)v229));
              }
              v239 = strlen(ls_rname);
              httpd_realloc_str((void **)&ls_encrname, (__int64 *)&ls_maxencrname, 3 * v239 + 1);
              v240 = ls_encrname;
              v241 = ls_maxencrname;
              if ( ls_maxencrname >= 5 )
              {
                v242 = ls_rname;
                v243 = *ls_rname;
                if ( *ls_rname )
                {
                  v244 = __ctype_b_loc();
                  v245 = v242 + 1;
                  v246 = 0;
                  do
                  {
                    if ( ((*v244)[v243] & 8) != 0 || memchr("/_.-~", v243, 6uLL) )
                    {
                      *v240 = v243;
                      v247 = 1;
                      v248 = 1LL;
                    }
                    else
                    {
                      sprintf(v240, "%%%02x", (unsigned __int8)v243);
                      v247 = 3;
                      v248 = 3LL;
                    }
                    v240 += v248;
                    v243 = *v245;
                    if ( !*v245 )
                      break;
                    v249 = v247 + v246 + 4;
                    ++v245;
                    v246 += v247;
                  }
                  while ( v249 < v241 );
                }
              }
              *v240 = 0;
              if ( stat(ls_name, &v284) >= 0 && lstat(ls_name, &v283) >= 0 )
              {
                LOBYTE(pipedes[0]) = 0;
                switch ( ((v283.st_mode & 0xF000) - 4096) >> 12 )
                {
                  case 0u:
                    v272[0] = 112;
                    goto LABEL_421;
                  case 1u:
                    v272[0] = 99;
                    goto LABEL_421;
                  case 3u:
                    v272[0] = 100;
                    goto LABEL_421;
                  case 5u:
                    v272[0] = 98;
                    goto LABEL_421;
                  case 7u:
                    v272[0] = 45;
                    goto LABEL_421;
                  case 9u:
                    v272[0] = 108;
                    v250 = readlink(ls_name, (char *)pipedes, 0x1000uLL);
                    v251 = "";
                    if ( v250 != -1 )
                    {
                      *((_BYTE *)pipedes + v250) = 0;
                      v251 = " -&gt; ";
                    }
                    goto LABEL_422;
                  case 0xBu:
                    v272[0] = 115;
                    goto LABEL_421;
                  default:
                    v272[0] = 63;
LABEL_421:
                    v251 = "";
LABEL_422:
                    v252 = 114;
                    if ( (v283.st_mode & 4) == 0 )
                      v252 = 45;
                    v253 = 119;
                    if ( (v283.st_mode & 2) == 0 )
                      v253 = 45;
                    v272[1] = v252;
                    v272[2] = v253;
                    v254 = 120;
                    if ( (v283.st_mode & 1) == 0 )
                      v254 = 45;
                    v272[3] = v254;
                    v272[4] = 0;
                    v255 = time(0LL);
                    v256 = ctime(&v283.st_mtim.tv_sec);
                    *v256 = v256[4];
                    *(_WORD *)(v256 + 1) = *(_WORD *)(v256 + 5);
                    v256[3] = 32;
                    *((_WORD *)v256 + 2) = *((_WORD *)v256 + 4);
                    v256[6] = 32;
                    if ( v255 - v283.st_mtim.tv_sec < 15724801 )
                    {
                      v257 = *((_WORD *)v256 + 7);
                      *(_WORD *)(v256 + 7) = *(_WORD *)(v256 + 11);
                      v256[9] = 58;
                      *((_WORD *)v256 + 5) = v257;
                    }
                    else
                    {
                      v256[7] = 32;
                      *((_DWORD *)v256 + 2) = *((_DWORD *)v256 + 5);
                    }
                    v256[12] = 0;
                    v258 = v284.st_mode & 0xF000;
                    if ( v258 == 40960 )
                    {
                      v230 = "@";
                    }
                    else
                    {
                      v230 = "/";
                      if ( (unsigned __int16)v258 != 0x4000 )
                      {
                        if ( (unsigned __int16)v258 == 49152 )
                        {
                          v230 = "=";
                        }
                        else
                        {
                          v230 = "*";
                          if ( (v284.st_mode & 1) == 0 )
                            v230 = "";
                        }
                      }
                    }
                    v231 = "";
                    if ( v258 == 0x4000 )
                      v231 = "/";
                    fprintf(
                      streama,
                      "%s %3ld  %10lld  %s  <a href=\"/%.500s%s\">%.80s</a>%s%s%s\n",
                      v272,
                      v283.st_nlink,
                      v283.st_size,
                      v256,
                      ls_encrname,
                      v231,
                      *((const char **)ls_nameptrs + (_QWORD)bufc),
                      v251,
                      (const char *)pipedes,
                      v230);
                    break;
                }
              }
              v229 = (struct stat *)((char *)&bufc->st_dev + 1);
            }
            while ( (__dev_t *)((char *)&bufc->st_dev + 1) != (__dev_t *)v271 );
          }
          fwrite("    </pre>\n  </body>\n</html>\n", 0x1DuLL, 1uLL, streama);
          fclose(streama);
          exit(0);
        }
        v215 = v214;
        v213 = 0LL;
        while ( 2 )
        {
          v219 = ls_maxnames;
          if ( v213 < ls_maxnames )
          {
            v216 = ls_nameptrs;
          }
          else
          {
            if ( ls_maxnames )
            {
              bufb = 2 * ls_maxnames;
              ls_maxnames *= 2;
              v220 = (char *)realloc(ls_names, 8194 * v219);
              ls_names = v220;
              v221 = realloc(ls_nameptrs, 16 * v219);
              ls_nameptrs = v221;
              if ( !v220 )
                goto LABEL_436;
              v216 = v221;
              if ( !v221 )
                goto LABEL_436;
              if ( (int)v219 <= 0 )
                goto LABEL_364;
            }
            else
            {
              ls_maxnames = 100;
              v220 = (char *)malloc(0x64064uLL);
              ls_names = v220;
              v222 = malloc(0x320uLL);
              ls_nameptrs = v222;
              if ( !v220 || (v216 = v222) == 0LL )
              {
LABEL_436:
                syslog(3, "out of memory reallocating directory names");
LABEL_233:
                exit(1);
              }
              bufb = 100;
            }
            if ( (unsigned __int64)bufb - 1 >= 3 )
            {
              v224 = 8194LL;
              v223 = 0LL;
              do
              {
                v216[v223] = &v220[((_DWORD)v224 - 8194) & 0xFFFFFFFC];
                v216[v223 + 1] = &v220[((_DWORD)v224 - 4097) & 0xFFFFFFFD];
                v216[v223 + 2] = &v220[v224 & 0xFFFFFFFE];
                v216[v223 + 3] = &v220[(unsigned int)(v224 + 4097)];
                v223 += 4LL;
                v224 += 16388LL;
              }
              while ( (bufb & 0xFFFFFFFC) != v223 );
            }
            else
            {
              v223 = 0LL;
            }
            if ( (bufb & 2) != 0 )
            {
              v225 = (char *)&v216[v223];
              v226 = 4097 * v223;
              v227 = 0LL;
              do
              {
                *(_QWORD *)&v225[8 * v227++] = &v220[(unsigned int)v226];
                v226 += 4097LL;
              }
              while ( (bufb & 2) != v227 );
            }
          }
LABEL_364:
          d_name = v215->d_name;
          v218 = (int)strlen(d_name);
          strncpy((char *)v216[v213], d_name, v218);
          *(_BYTE *)(v216[v213++] + v218) = 0;
          v215 = readdir(v36);
          if ( !v215 )
            goto LABEL_356;
          continue;
        }
      }
    }
    v3 = a1;
    v28 = expand_symlinks(
            really_start_request_indexname,
            (char **)&v284,
            *(_DWORD *)(*(_QWORD *)(a1 + 8) + 96LL),
            *(_DWORD *)(a1 + 532));
    v2 = a2;
    if ( !v28 || (v29 = v28, *(_BYTE *)v284.st_dev) )
    {
LABEL_39:
      v7 = *(char **)(v3 + 208);
      v8 = "Internal Error";
      v9 = "There was an unusual problem serving the requested URL '%.80s'.\n";
      a1 = v3;
      goto LABEL_40;
    }
    v6 = (const char **)v21;
    v5 = strlen(v28);
    httpd_realloc_str(v21, (__int64 *)(a1 + 392), v5);
    strcpy(*(char **)(a1 + 240), v29);
    if ( (*(_BYTE *)(a1 + 584) & 5) == 0 )
    {
      v89 = *(_WORD *)(a1 + 16);
      v90 = 28;
      if ( v89 != 10 )
        v90 = 0;
      v91 = 16;
      if ( v89 != 2 )
        v91 = v90;
      if ( getnameinfo((const struct sockaddr *)(a1 + 16), v91, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
      {
        strcpy(httpd_ntoa_str, "?");
      }
      else if ( !*(_DWORD *)(a1 + 24)
             && !*(_DWORD *)(a1 + 28)
             && *(_DWORD *)(a1 + 32) == -65536
             && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
      {
        v96 = strlen(src);
        memmove(httpd_ntoa_str, src, v96 + 1);
      }
      syslog(
        6,
        "%.80s URL \"%.80s\" resolves to a non-world-readable index file",
        httpd_ntoa_str,
        *(const char **)(a1 + 208));
      v7 = *(char **)(a1 + 208);
      v8 = "Forbidden";
      v9 = "The requested URL '%.80s' resolves to an index file that is not world-readable.\n";
      goto LABEL_18;
    }
  }
  httpd_realloc_str((void **)&really_start_request_dirname, &really_start_request_maxdirname, v5);
  strcpy(really_start_request_dirname, *v6);
  v43 = really_start_request_dirname;
  v44 = strrchr(really_start_request_dirname, 47);
  if ( v44 )
    *v44 = 0;
  else
    *(_WORD *)v43 = 46;
  v45 = really_start_request_dirname;
  v46 = *(_QWORD *)(v3 + 8);
  if ( !*(_DWORD *)(v46 + 104) )
    goto LABEL_70;
  if ( !*(_DWORD *)(v46 + 100) || (v47 = *(char **)(v3 + 344), !*v47) )
    v47 = (char *)".";
  v30 = auth_check2(v3, v47);
  if ( v30 == -1 )
    return v30;
  if ( v30 != 1 )
  {
LABEL_70:
    if ( (unsigned int)auth_check2(v3, v45) == -1 )
      return (unsigned int)-1;
  }
  if ( v5 == 9 )
  {
    if ( !strcmp(*v6, ".htpasswd") )
    {
LABEL_73:
      v48 = *(_WORD *)(v3 + 16);
      v49 = 28;
      if ( v48 != 10 )
        v49 = 0;
      v50 = 16;
      if ( v48 != 2 )
        v50 = v49;
      if ( getnameinfo((const struct sockaddr *)(v3 + 16), v50, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
      {
        strcpy(httpd_ntoa_str, "?");
      }
      else if ( !*(_DWORD *)(v3 + 24)
             && !*(_DWORD *)(v3 + 28)
             && *(_DWORD *)(v3 + 32) == -65536
             && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
      {
        v62 = strlen(src);
        memmove(httpd_ntoa_str, src, v62 + 1);
      }
      syslog(5, "%.80s URL \"%.80s\" tried to retrieve an auth file", httpd_ntoa_str, *(const char **)(v3 + 208));
      v7 = *(char **)(v3 + 208);
      v8 = "Forbidden";
      v9 = "The requested URL '%.80s' is an authorization file, retrieving it is not permitted.\n";
LABEL_18:
      a1 = v3;
      v10 = 403;
      goto LABEL_41;
    }
  }
  else if ( v5 > 9 )
  {
    v51 = *v6;
    if ( !strcmp(&(*v6)[v5 - 9], ".htpasswd") && v51[v5 - 10] == 47 )
      goto LABEL_73;
  }
  v30 = -1;
  if ( !(unsigned int)check_referrer(v3) )
    return v30;
  v52 = *(char **)(*(_QWORD *)(v3 + 8) + 24LL);
  if ( v52 && (*(_BYTE *)(v3 + 584) & 1) != 0 && (unsigned int)match(v52, *v6) )
  {
    v53 = *(_QWORD *)(v3 + 8);
    v54 = *(_DWORD *)(v53 + 32);
    v55 = *(_DWORD *)(v53 + 36);
    if ( v54 && v55 >= v54 )
    {
      httpd_send_err(v3, 0x1F7u, *(const char **)&httpd_err503title, (char *)"", httpd_err503form, *(char **)(v3 + 208));
      return v30;
    }
    *(_DWORD *)(v53 + 36) = v55 + 1;
    v82 = *(_DWORD *)(v3 + 704);
    v83 = fcntl(v82, 3, 0LL);
    if ( v83 != -1 && (v83 & 0xFFFFF7FF) != v83 )
      fcntl(v82, 4);
    v84 = fork();
    if ( v84 < 0 )
    {
      syslog(3, "fork - %m");
      httpd_send_err(
        v3,
        0x1F4u,
        "Internal Error",
        (char *)"",
        "There was an unusual problem serving the requested URL '%.80s'.\n",
        *(char **)(v3 + 208));
      return v30;
    }
    if ( v84 )
    {
      v85 = v84;
      v30 = 0;
      syslog(7, "spawned CGI process %d for file '%.200s'", (unsigned int)v84, *v6);
      if ( tmr_create(0LL, (__time_t)cgi_kill, v85, 30000LL, 0) )
      {
        *(_DWORD *)(v3 + 184) = 200;
        *(_QWORD *)(v3 + 200) = 25000LL;
        *(_DWORD *)(v3 + 556) = 0;
        return v30;
      }
      v121 = "tmr_create(cgi_kill child) failed";
LABEL_232:
      syslog(2, v121);
      goto LABEL_233;
    }
    v270 = v6;
    sub_process = 1;
    s1c = (char *)v3;
    v111 = *(_QWORD *)(v3 + 8);
    v112 = *(_DWORD *)(v111 + 72);
    if ( v112 != -1 )
    {
      close(v112);
      *(_DWORD *)(v111 + 72) = -1;
    }
    v113 = *(_DWORD *)(v111 + 76);
    if ( v113 != -1 )
    {
      close(v113);
      *(_DWORD *)(v111 + 76) = -1;
    }
    fcntl(*(_DWORD *)(v3 + 704), 2, 0LL);
    closelog();
    v114 = *(_DWORD *)(v3 + 704);
    if ( v114 <= 2 )
    {
      v115 = dup2(v114, 3);
      if ( v115 >= 0 )
        *(_DWORD *)(v3 + 704) = v115;
    }
    make_envp_envp = build_env("PATH=%s", "/usr/local/bin:/usr/ucb:/bin:/usr/bin");
    qword_1B308 = (__int64)build_env("SERVER_SOFTWARE=%s", "thttpd/2.29 23May2018");
    v116 = *(_QWORD *)(v3 + 8);
    if ( *(_DWORD *)(v116 + 100) && (v117 = *(const char **)(v3 + 512)) != 0LL && *v117
      || (v117 = *(const char **)(v3 + 336)) != 0LL && *v117
      || (v117 = *(const char **)(v3 + 328)) != 0LL && *v117
      || (v117 = *(const char **)(v116 + 8), v118 = 2, v117) )
    {
      qword_1B310 = (__int64)build_env("SERVER_NAME=%s", v117);
      v118 = 3;
    }
    (&make_envp_envp)[v118] = "GATEWAY_INTERFACE=CGI/1.1";
    (&make_envp_envp)[v118 + 1] = build_env("SERVER_PROTOCOL=%s", *(const char **)(v3 + 224));
    my_snprintf((char *)pipedes, 0x100uLL, "%d", *(unsigned __int16 *)(*(_QWORD *)(v3 + 8) + 16LL));
    (&make_envp_envp)[v118 + 2] = build_env("SERVER_PORT=%s", (const char *)pipedes);
    v119 = *(_DWORD *)(v3 + 180) - 1;
    if ( v119 > 5 )
      v120 = "UNKNOWN";
    else
      v120 = (&off_18DA0)[v119];
    v122 = v118 + 4;
    (&make_envp_envp)[v118 + 3] = build_env("REQUEST_METHOD=%s", v120);
    v123 = *(const char **)(v3 + 256);
    if ( *v123 )
    {
      (&make_envp_envp)[v122] = build_env("PATH_INFO=/%s", v123);
      v124 = *(const char **)(*(_QWORD *)(v3 + 8) + 64LL);
      v125 = strlen(v124);
      v126 = *(const char **)(v3 + 256);
      v127 = v125 + strlen(v126) + 1;
      v128 = (char *)malloc(v127);
      if ( v128 )
      {
        v129 = v128;
        my_snprintf(v128, v127, "%s%s", v124, v126);
        (&make_envp_envp)[v118 + 5] = build_env("PATH_TRANSLATED=%s", v129);
        v122 = v118 + 6;
      }
      else
      {
        v122 = v118 + 5;
      }
    }
    v130 = (const char *)*((_QWORD *)s1c + 29);
    v131 = "";
    if ( strcmp(v130, ".") )
      v131 = v130;
    v132 = v122 + 1;
    (&make_envp_envp)[v122] = build_env("SCRIPT_NAME=/%s", v131);
    v133 = (const char *)*((_QWORD *)s1c + 33);
    if ( *v133 )
    {
      (&make_envp_envp)[v132] = build_env("QUERY_STRING=%s", v133);
      v132 = v122 + 2;
    }
    v134 = *((_WORD *)s1c + 8);
    v135 = 28;
    if ( v134 != 10 )
      v135 = 0;
    v136 = 16;
    if ( v134 != 2 )
      v136 = v135;
    if ( getnameinfo((const struct sockaddr *)s1c + 1, v136, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
    {
      strcpy(httpd_ntoa_str, "?");
    }
    else if ( !*((_DWORD *)s1c + 6)
           && !*((_DWORD *)s1c + 7)
           && *((_DWORD *)s1c + 8) == -65536
           && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
    {
      v137 = strlen(src);
      memmove(httpd_ntoa_str, src, v137 + 1);
    }
    v138 = v132 + 1;
    (&make_envp_envp)[v132] = build_env("REMOTE_ADDR=%s", httpd_ntoa_str);
    v139 = (const char *)*((_QWORD *)s1c + 34);
    if ( *v139 )
    {
      (&make_envp_envp)[v138] = build_env("HTTP_REFERER=%s", v139);
      (&make_envp_envp)[v132 + 2] = build_env("HTTP_REFERRER=%s", *((const char **)s1c + 34));
      v138 = v132 + 3;
    }
    v140 = (const char *)*((_QWORD *)s1c + 35);
    if ( *v140 )
    {
      v141 = build_env("HTTP_USER_AGENT=%s", v140);
      v142 = v138++;
      (&make_envp_envp)[v142] = v141;
    }
    v143 = (const char *)*((_QWORD *)s1c + 36);
    if ( *v143 )
    {
      v144 = build_env("HTTP_ACCEPT=%s", v143);
      v145 = v138++;
      (&make_envp_envp)[v145] = v144;
    }
    v146 = (const char *)*((_QWORD *)s1c + 37);
    if ( *v146 )
    {
      v147 = build_env("HTTP_ACCEPT_ENCODING=%s", v146);
      v148 = v138++;
      (&make_envp_envp)[v148] = v147;
    }
    v149 = (const char *)*((_QWORD *)s1c + 38);
    if ( *v149 )
    {
      v150 = build_env("HTTP_ACCEPT_LANGUAGE=%s", v149);
      v151 = v138++;
      (&make_envp_envp)[v151] = v150;
    }
    v152 = (const char *)*((_QWORD *)s1c + 39);
    if ( *v152 )
    {
      v153 = build_env("HTTP_COOKIE=%s", v152);
      v154 = v138++;
      (&make_envp_envp)[v154] = v153;
    }
    v155 = (const char *)*((_QWORD *)s1c + 40);
    if ( *v155 )
    {
      v156 = build_env("CONTENT_TYPE=%s", v155);
      v157 = v138++;
      (&make_envp_envp)[v157] = v156;
    }
    v158 = (const char *)*((_QWORD *)s1c + 42);
    if ( *v158 )
    {
      v159 = build_env("HTTP_HOST=%s", v158);
      v160 = v138++;
      (&make_envp_envp)[v160] = v159;
    }
    v161 = *((_QWORD *)s1c + 62);
    if ( v161 != -1 )
    {
      my_snprintf((char *)pipedes, 0x100uLL, "%lu", v161);
      v162 = build_env("CONTENT_LENGTH=%s", (const char *)pipedes);
      v163 = v138++;
      (&make_envp_envp)[v163] = v162;
    }
    v164 = (const char *)*((_QWORD *)s1c + 45);
    if ( *v164 )
    {
      v165 = build_env("REMOTE_USER=%s", v164);
      v166 = v138++;
      (&make_envp_envp)[v166] = v165;
    }
    if ( **((_BYTE **)s1c + 44) )
    {
      v167 = build_env("AUTH_TYPE=%s", "Basic");
      v168 = v138++;
      (&make_envp_envp)[v168] = v167;
    }
    v169 = getenv("TZ");
    if ( v169 )
    {
      v170 = build_env("TZ=%s", v169);
      v171 = v138++;
      (&make_envp_envp)[v171] = v170;
    }
    (&make_envp_envp)[v138] = build_env("CGI_PATTERN=%s", *(const char **)(*((_QWORD *)s1c + 1) + 24LL));
    (&make_envp_envp)[v138 + 1] = 0LL;
    v172 = (const char *)*((_QWORD *)s1c + 33);
    v173 = strlen(v172);
    bufa = (const char **)malloc(8 * v173 + 16);
    if ( bufa )
    {
      v174 = *v270;
      v175 = strrchr(*v270, 47);
      v176 = v175 + 1;
      if ( !v175 )
        v176 = (char *)v174;
      *bufa = v176;
      v177 = 1;
      if ( !strchr(v172, 61) )
      {
        v177 = 1;
        for ( i = v172; *i != 43; ++i )
        {
          if ( !*i )
          {
            if ( i == v172 )
              goto LABEL_325;
            v190 = (char *)v172;
            for ( j = (char *)v172; ; ++j )
            {
              v192 = *j;
              if ( *j == 37 )
              {
                v193 = __ctype_b_loc();
                v194 = *v193;
                v195 = j[1];
                v192 = 37;
                if ( ((*v193)[v195] & 0x1000) != 0 )
                {
                  v196 = j[2];
                  if ( (v194[v196] & 0x1000) != 0 )
                  {
                    v197 = v195 - 48;
                    if ( (unsigned __int8)(v195 - 48) >= 0xAu )
                    {
                      if ( (unsigned __int8)(v195 - 97) > 5u )
                      {
                        v197 = v195 - 55;
                        if ( (unsigned __int8)(v195 - 65) >= 6u )
                          v197 = 0;
                      }
                      else
                      {
                        v197 = v195 - 87;
                      }
                    }
                    v198 = 16 * v197;
                    v199 = v196 - 48;
                    if ( (unsigned __int8)(v196 - 48) >= 0xAu )
                    {
                      if ( (unsigned __int8)(v196 - 97) > 5u )
                      {
                        v199 = v196 - 55;
                        if ( (unsigned __int8)(v196 - 65) >= 6u )
                          v199 = 0;
                      }
                      else
                      {
                        v199 = v196 - 87;
                      }
                    }
                    v192 = v198 + v199;
                    j += 2;
                  }
                }
              }
              else if ( !v192 )
              {
                *v190 = 0;
                v200 = v177++;
                bufa[v200] = v172;
                goto LABEL_325;
              }
              *v190++ = v192;
            }
          }
LABEL_285:
          ;
        }
        *i = 0;
        v180 = (char *)v172;
        for ( k = (char *)v172; ; ++k )
        {
          v182 = *k;
          if ( *k == 37 )
          {
            v183 = __ctype_b_loc();
            v184 = *v183;
            v185 = k[1];
            v182 = 37;
            if ( ((*v183)[v185] & 0x1000) != 0 )
            {
              v186 = k[2];
              if ( (v184[v186] & 0x1000) != 0 )
              {
                v187 = v185 - 48;
                if ( (unsigned __int8)(v185 - 48) >= 0xAu )
                {
                  if ( (unsigned __int8)(v185 - 97) > 5u )
                  {
                    v187 = v185 - 55;
                    if ( (unsigned __int8)(v185 - 65) >= 6u )
                      v187 = 0;
                  }
                  else
                  {
                    v187 = v185 - 87;
                  }
                }
                v188 = 16 * v187;
                v189 = v186 - 48;
                if ( (unsigned __int8)(v186 - 48) >= 0xAu )
                {
                  if ( (unsigned __int8)(v186 - 97) > 5u )
                  {
                    v189 = v186 - 55;
                    if ( (unsigned __int8)(v186 - 65) >= 6u )
                      v189 = 0;
                  }
                  else
                  {
                    v189 = v186 - 87;
                  }
                }
                v182 = v188 + v189;
                k += 2;
              }
            }
          }
          else if ( !v182 )
          {
            *v180 = 0;
            v179 = v177++;
            bufa[v179] = v172;
            v172 = i + 1;
            goto LABEL_285;
          }
          *v180++ = v182;
        }
      }
LABEL_325:
      bufa[v177] = 0LL;
    }
    else
    {
      bufa = 0LL;
    }
    if ( *((_DWORD *)s1c + 45) == 3 && *((_QWORD *)s1c + 20) > *((_QWORD *)s1c + 21) )
    {
      if ( pipe(pipedes) < 0 )
      {
LABEL_344:
        syslog(3, "pipe - %m");
        goto LABEL_354;
      }
      v201 = fork();
      if ( v201 < 0 )
      {
LABEL_353:
        syslog(3, "fork - %m");
LABEL_354:
        httpd_send_err(
          (__int64)s1c,
          0x1F4u,
          "Internal Error",
          (char *)"",
          "There was an unusual problem serving the requested URL '%.80s'.\n",
          *((char **)s1c + 26));
        httpd_write_response((__int64)s1c);
        exit(1);
      }
      if ( !v201 )
      {
        sub_process = 1;
        close(pipedes[0]);
        cgi_interpose_input((__int64)s1c, pipedes[1]);
        exit(0);
      }
      close(pipedes[1]);
      if ( pipedes[0] )
      {
        dup2(pipedes[0], 0);
        close(pipedes[0]);
      }
    }
    else
    {
      v202 = *((_DWORD *)s1c + 176);
      if ( v202 )
        dup2(v202, 0);
    }
    if ( !strncmp(*bufa, "nph-", 4uLL) || !*((_DWORD *)s1c + 130) )
    {
      v203 = *((_DWORD *)s1c + 176);
      v204 = 1;
      if ( v203 == 1 || (dup2(v203, 1), v204 = *((_DWORD *)s1c + 176), v204 != 2) )
        dup2(v204, 2);
      goto LABEL_339;
    }
    if ( pipe(pipedes) < 0 )
      goto LABEL_344;
    v212 = fork();
    if ( v212 >= 0 )
    {
      if ( !v212 )
      {
        sub_process = 1;
        close(pipedes[1]);
        cgi_interpose_output((__int64)s1c, pipedes[0]);
        exit(0);
      }
      close(pipedes[0]);
      v228 = 1;
      if ( pipedes[1] == 1 || (dup2(pipedes[1], 1), v228 = pipedes[1], pipedes[1] != 2) )
      {
        dup2(v228, 2);
        if ( (unsigned int)(pipedes[1] - 3) <= 0xFFFFFFFD )
          close(pipedes[1]);
      }
LABEL_339:
      nice(10);
      v205 = *v270;
      v206 = strdup(*v270);
      if ( v206 )
      {
        v207 = v206;
        v208 = strrchr(v206, 47);
        if ( v208 )
        {
          v205 = v208 + 1;
          *v208 = 0;
          chdir(v207);
        }
      }
      sigset(13, 0LL);
      execve(v205, (char *const *)bufa, &make_envp_envp);
      syslog(3, "execve %.80s - %m", *((const char **)s1c + 30));
      httpd_send_err(
        (__int64)s1c,
        0x1F4u,
        "Internal Error",
        (char *)"",
        "There was an unusual problem serving the requested URL '%.80s'.\n",
        *((char **)s1c + 26));
      httpd_write_response((__int64)s1c);
      _exit(1);
    }
    goto LABEL_353;
  }
  if ( (*(_BYTE *)(v3 + 584) & 1) != 0 )
  {
    v59 = *(_WORD *)(v3 + 16);
    v60 = 28;
    if ( v59 != 10 )
      v60 = 0;
    v61 = 16;
    if ( v59 != 2 )
      v61 = v60;
    if ( getnameinfo((const struct sockaddr *)(v3 + 16), v61, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
    {
      strcpy(httpd_ntoa_str, "?");
    }
    else if ( !*(_DWORD *)(v3 + 24)
           && !*(_DWORD *)(v3 + 28)
           && *(_DWORD *)(v3 + 32) == -65536
           && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
    {
      v76 = strlen(src);
      memmove(httpd_ntoa_str, src, v76 + 1);
    }
    syslog(5, "%.80s URL \"%.80s\" is executable but isn't CGI", httpd_ntoa_str, *(const char **)(v3 + 208));
    v77 = *(char **)(v3 + 208);
    v78 = "The requested URL '%.80s' resolves to a file which is marked executable but is not a CGI file; retrieving it is forbidden.\n";
    goto LABEL_156;
  }
  if ( **(_BYTE **)(v3 + 256) )
  {
    v56 = *(_WORD *)(v3 + 16);
    v57 = 28;
    if ( v56 != 10 )
      v57 = 0;
    v58 = 16;
    if ( v56 != 2 )
      v58 = v57;
    if ( getnameinfo((const struct sockaddr *)(v3 + 16), v58, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
    {
      strcpy(httpd_ntoa_str, "?");
    }
    else if ( !*(_DWORD *)(v3 + 24)
           && !*(_DWORD *)(v3 + 28)
           && *(_DWORD *)(v3 + 32) == -65536
           && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
    {
      v86 = strlen(src);
      memmove(httpd_ntoa_str, src, v86 + 1);
    }
    syslog(6, "%.80s URL \"%.80s\" has pathinfo but isn't CGI", httpd_ntoa_str, *(const char **)(v3 + 208));
    v77 = *(char **)(v3 + 208);
    v78 = "The requested URL '%.80s' resolves to a file plus CGI-style pathinfo, but the file is not a valid CGI file.\n";
LABEL_156:
    httpd_send_err(v3, 0x193u, "Forbidden", (char *)"", v78, v77);
    return v30;
  }
  v63 = *(_DWORD *)(v3 + 180);
  if ( (unsigned int)(v63 - 1) >= 2 )
  {
    v87 = v63 - 3;
    if ( v87 > 3 )
      v88 = "UNKNOWN";
    else
      v88 = (char *)dword_13280 + dword_13280[v87];
    a1 = v3;
    goto LABEL_186;
  }
  if ( *(_DWORD *)(v3 + 528) )
  {
    v64 = *(_QWORD *)(v3 + 544);
    v65 = *(_QWORD *)(v3 + 608);
    if ( v64 == -1 || v64 >= v65 )
      *(_QWORD *)(v3 + 544) = v65 - 1;
  }
  v66 = *v6;
  v67 = &v66[strlen(*v6)];
  s2 = enc_tab;
  v275 = off_193F0;
  v279 = off_19410;
  v273 = qword_19418;
  v280 = ~qword_19418;
  v276 = qword_193F8;
  v281 = ~qword_193F8;
  n = qword_193D8;
  v68 = ~qword_193D8;
  stream = 0;
  v69 = 1LL;
  v274 = "text/plain; charset=%s";
  v269 = v2;
  while ( 1 )
  {
    v70 = v67;
    v71 = 0LL;
    do
    {
      v72 = &v70[v71 - 1];
      if ( v72 < v66 )
        goto LABEL_199;
      --v71;
    }
    while ( *v72 != 46 );
    v73 = &v70[v71 + 1];
    s1a = (char *)v73;
    v282 = v68;
    if ( v68 == v71 )
    {
      v73 = &v70[v71 + 1];
      if ( !strncasecmp(s1a, s2, n) )
      {
        v75 = 0;
        goto LABEL_127;
      }
    }
    if ( v281 == v71 )
    {
      v73 = &v70[v71 + 1];
      if ( !strncasecmp(s1a, v275, v276) )
      {
        v75 = 1;
        goto LABEL_127;
      }
    }
    if ( v280 != v71 )
      break;
    v74 = strncasecmp(v73, v279, v273);
    v75 = 2;
    if ( v74 )
      goto LABEL_189;
LABEL_127:
    v67 = &v70[v71];
    v68 = v282;
    if ( stream <= 0x63 )
    {
      pipedes[stream++] = v75;
      ++v69;
      v67 = &v70[v71];
    }
  }
  v273 = ~v71;
LABEL_189:
  v99 = 192;
  v100 = 0;
  while ( 2 )
  {
    v101 = (v99 + v100) / 2;
    v102 = 32LL * v101;
    v103 = strncasecmp(v73, *(const char **)((char *)&typ_tab + v102), v273);
    if ( v103 < 0 )
    {
      v99 = v101 - 1;
      v73 = s1a;
      goto LABEL_191;
    }
    v73 = s1a;
    if ( v103 )
      goto LABEL_197;
    if ( v273 < *(unsigned __int64 *)((char *)&typ_tab + v102 + 8) )
    {
      v99 = v101 - 1;
      goto LABEL_191;
    }
    if ( v273 > *(unsigned __int64 *)((char *)&typ_tab + v102 + 8) )
    {
LABEL_197:
      v100 = v101 + 1;
LABEL_191:
      if ( v99 < v100 )
        goto LABEL_199;
      continue;
    }
    break;
  }
  v274 = *(const char **)((char *)&typ_tab + v102 + 16);
LABEL_199:
  *(_QWORD *)(v3 + 504) = v274;
  s1b = (char *)v3;
  **(_BYTE **)(v3 + 248) = 0;
  if ( stream )
  {
    v104 = (void **)(v3 + 248);
    v105 = 0LL;
    do
    {
      v107 = 4LL * pipedes[(unsigned int)(v69 - 2)];
      v108 = v105 + 1;
      httpd_realloc_str(v104, (__int64 *)s1b + 50, (unsigned __int64)&(&enc_tab)[v107 + 3][(_QWORD)(v105 + 1)]);
      v106 = (char *)*v104;
      if ( *(_BYTE *)*v104 )
      {
        *(_WORD *)&v105[(_QWORD)v106] = 44;
        v106 = (char *)*v104;
      }
      else
      {
        v108 = v105;
      }
      strcpy(&v106[(_QWORD)v108], (&enc_tab)[v107 + 2]);
      --v69;
      v105 = &v108[(_QWORD)(&enc_tab)[v107 + 3]];
    }
    while ( v69 > 1 );
  }
  v24 = (__int64)s1b;
  if ( *((_DWORD *)s1b + 45) == 2 )
  {
LABEL_209:
    send_mime(
      (__int64)s1b,
      0xC8u,
      "OK",
      *((const char **)s1b + 31),
      (char *)"",
      *((const char **)s1b + 63),
      *((_QWORD *)s1b + 76),
      *((_QWORD *)s1b + 81));
    return 0;
  }
  v109 = *((_QWORD *)s1b + 60);
  if ( v109 != -1 && v109 >= *((_QWORD *)s1b + 81) )
  {
    send_mime(
      (__int64)s1b,
      0x130u,
      "Not Modified",
      *((const char **)s1b + 31),
      (char *)"",
      *((const char **)s1b + 63),
      -1LL,
      *((_QWORD *)s1b + 81));
    return 0;
  }
  v110 = mmc_map(*((char **)s1b + 30), buf, v269);
  *((_QWORD *)s1b + 89) = v110;
  if ( v110 )
    goto LABEL_209;
LABEL_211:
  v7 = *(char **)(v24 + 208);
  v8 = "Internal Error";
  v9 = "There was an unusual problem serving the requested URL '%.80s'.\n";
  a1 = v24;
LABEL_40:
  v10 = 500;
LABEL_41:
  httpd_send_err(a1, v10, v8, (char *)"", v9, v7);
  return (unsigned int)-1;
}
// 13280: using guessed type int dword_13280[4];
// 18D70: using guessed type char *really_start_request_index_names;
// 18DA0: using guessed type char *off_18DA0;
// 193C8: using guessed type char *httpd_err503form;
// 193D8: using guessed type __int64 qword_193D8;
// 193F8: using guessed type __int64 qword_193F8;
// 19418: using guessed type __int64 qword_19418;
// 19430: using guessed type void *typ_tab;
// 1B100: using guessed type char sub_process;
// 1B210: using guessed type __int64 really_start_request_maxindexname;
// 1B220: using guessed type __int64 really_start_request_maxdirname;
// 1B230: using guessed type __int64 send_dirredirect_header;
// 1B238: using guessed type __int64 send_dirredirect_maxlocation;
// 1B240: using guessed type __int64 send_dirredirect_maxheader;
// 1B2B0: using guessed type int ls_maxnames;
// 1B2D0: using guessed type __int64 ls_maxname;
// 1B2E0: using guessed type __int64 ls_maxrname;
// 1B2F0: using guessed type int ls_maxencrname;
// 1B308: using guessed type __int64 qword_1B308;
// 1B310: using guessed type __int64 qword_1B310;

//----- (000000000000E850) ----------------------------------------------------
__int64 __fastcall httpd_read_fully(int fd, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rax
  unsigned int v5; // ebp
  int v6; // eax
  unsigned int v7; // ebx
  int v8; // eax

  if ( !a3 )
    return 0;
  v4 = 0LL;
  v5 = 0;
  while ( 1 )
  {
    v6 = read(fd, (void *)(a2 + v4), a3 - v4);
    v7 = v6;
    if ( v6 < 0 )
      break;
    v5 += v6;
    if ( !v6 )
      return v5;
LABEL_4:
    v4 = (int)v5;
    if ( (int)v5 >= a3 )
      return v5;
  }
  v8 = *__errno_location();
  if ( v8 == 11 || v8 == 4 )
  {
    sleep(1u);
    goto LABEL_4;
  }
  return v7;
}

//----- (000000000000E8E0) ----------------------------------------------------
void httpd_logstats()
{
  float v0; // xmm0_4

  if ( str_alloc_count > 0 )
  {
    if ( str_alloc_size < 0 )
      v0 = (float)(int)(((unsigned __int64)str_alloc_size >> 1) | str_alloc_size & 1)
         + (float)(int)(((unsigned __int64)str_alloc_size >> 1) | str_alloc_size & 1);
    else
      v0 = (float)(int)str_alloc_size;
    syslog(
      5,
      "  libhttpd - %d strings allocated, %lu bytes (%g bytes/str)",
      (unsigned int)str_alloc_count,
      str_alloc_size,
      (float)(v0 / (float)str_alloc_count));
  }
}
// 1B104: using guessed type int str_alloc_count;
// 1B108: using guessed type __int64 str_alloc_size;

//----- (000000000000E940) ----------------------------------------------------
void __fastcall send_mime(
        __int64 a1,
        unsigned int a2,
        const char *a3,
        const char *a4,
        char *a5,
        const char *a6,
        __int64 a7,
        time_t a8)
{
  unsigned int v8; // r14d
  time_t v9; // rbp
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rax
  time_t v14; // rax
  struct tm *v15; // rax
  struct tm *v16; // rax
  size_t v17; // r13
  __int64 *v18; // r12
  _QWORD *v19; // r15
  size_t v20; // r13
  bool v21; // cc
  void **v22; // r14
  size_t v23; // r13
  size_t v24; // r13
  size_t v25; // r13
  __int64 v26; // rax
  const char *v27; // rcx
  size_t v28; // r13
  __int64 v29; // rax
  struct tm *v30; // rax
  size_t v31; // r13
  char *v32; // rbp
  size_t v33; // rbx
  size_t v34; // rbx
  char v35; // [rsp+4h] [rbp-794h]
  const char *v36; // [rsp+8h] [rbp-790h]
  time_t timer; // [rsp+10h] [rbp-788h] BYREF
  const char *v38; // [rsp+18h] [rbp-780h]
  char *v39; // [rsp+20h] [rbp-778h]
  time_t v40; // [rsp+28h] [rbp-770h] BYREF
  char s[112]; // [rsp+30h] [rbp-768h] BYREF
  char v42[112]; // [rsp+A0h] [rbp-6F8h] BYREF
  char v43[112]; // [rsp+110h] [rbp-688h] BYREF
  char src[1008]; // [rsp+180h] [rbp-618h] BYREF
  char v45[552]; // [rsp+570h] [rbp-228h] BYREF

  v39 = a5;
  v8 = a2;
  v9 = a8;
  *(_DWORD *)(a1 + 184) = a2;
  *(_QWORD *)(a1 + 192) = a7;
  if ( !*(_DWORD *)(a1 + 520) )
    return;
  v38 = a4;
  if ( a2 == 200
    && *(_DWORD *)(a1 + 528)
    && (v11 = *(_QWORD *)(a1 + 536), v12 = *(_QWORD *)(a1 + 544), v12 >= v11)
    && (v12 != a7 - 1 || v11)
    && ((v13 = *(_QWORD *)(a1 + 488), v13 == -1) || v13 == *(_QWORD *)(a1 + 648)) )
  {
    *(_DWORD *)(a1 + 184) = 206;
    v8 = 206;
    v36 = "Partial Content";
    v35 = 0;
  }
  else
  {
    v36 = a3;
    *(_DWORD *)(a1 + 528) = 0;
    v35 = 1;
  }
  v14 = time(0LL);
  timer = v14;
  if ( !v9 )
    a8 = v14;
  v15 = gmtime(&timer);
  strftime(s, 0x64uLL, "%a, %d %b %Y %H:%M:%S GMT", v15);
  v16 = gmtime(&a8);
  strftime(v43, 0x64uLL, "%a, %d %b %Y %H:%M:%S GMT", v16);
  my_snprintf(v45, 0x1F4uLL, a6, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40LL));
  my_snprintf(
    src,
    0x3E8uLL,
    "%.20s %d %s\r\n"
    "Server: %s\r\n"
    "Content-Type: %s\r\n"
    "Date: %s\r\n"
    "Last-Modified: %s\r\n"
    "Accept-Ranges: bytes\r\n"
    "Connection: close\r\n",
    *(const char **)(a1 + 224),
    v8,
    v36,
    "thttpd/2.29 23May2018",
    v45,
    s,
    v43);
  v17 = strlen(src);
  v18 = (__int64 *)(a1 + 464);
  v19 = (_QWORD *)(a1 + 472);
  httpd_realloc_str((void **)(a1 + 368), (__int64 *)(a1 + 464), v17 + *(_QWORD *)(a1 + 472));
  memmove((void *)(*(_QWORD *)(a1 + 472) + *(_QWORD *)(a1 + 368)), src, v17);
  v20 = *(_QWORD *)(a1 + 472) + v17;
  *(_QWORD *)(a1 + 472) = v20;
  v21 = v8 - 400 <= 0xFFFFFF37;
  v22 = (void **)(a1 + 368);
  if ( v21 )
  {
    my_snprintf(src, 0x3E8uLL, "Cache-Control: no-cache,no-store\r\n");
    v23 = strlen(src);
    httpd_realloc_str(v22, (__int64 *)(a1 + 464), v23 + *v19);
    memmove((char *)*v22 + *v19, src, v23);
    v20 = *v19 + v23;
    *v19 = v20;
  }
  if ( *v38 )
  {
    my_snprintf(src, 0x3E8uLL, "Content-Encoding: %s\r\n", v38);
    v24 = strlen(src);
    httpd_realloc_str(v22, (__int64 *)(a1 + 464), v24 + *v19);
    memmove((char *)*v22 + *v19, src, v24);
    v20 = *v19 + v24;
    *v19 = v20;
  }
  if ( !v35 )
  {
    my_snprintf(
      src,
      0x3E8uLL,
      "Content-Range: bytes %lld-%lld/%lld\r\nContent-Length: %lld\r\n",
      *(_QWORD *)(a1 + 536),
      *(_QWORD *)(a1 + 544),
      a7,
      *(_QWORD *)(a1 + 544) - *(_QWORD *)(a1 + 536) + 1LL);
    goto LABEL_21;
  }
  if ( a7 >= 0 )
  {
    my_snprintf(src, 0x3E8uLL, "Content-Length: %lld\r\n", a7);
LABEL_21:
    v25 = strlen(src);
    httpd_realloc_str(v22, (__int64 *)(a1 + 464), v25 + *v19);
    memmove((char *)*v22 + *v19, src, v25);
    v20 = *v19 + v25;
    *v19 = v20;
  }
  v26 = *(_QWORD *)(a1 + 8);
  v27 = *(const char **)(v26 + 48);
  if ( *v27 )
  {
    my_snprintf(src, 0x3E8uLL, "P3P: %s\r\n", v27);
    v28 = strlen(src);
    httpd_realloc_str(v22, (__int64 *)(a1 + 464), v28 + *(_QWORD *)(a1 + 472));
    memmove((void *)(*(_QWORD *)(a1 + 472) + *(_QWORD *)(a1 + 368)), src, v28);
    v20 = *(_QWORD *)(a1 + 472) + v28;
    *(_QWORD *)(a1 + 472) = v20;
    v26 = *(_QWORD *)(a1 + 8);
  }
  v29 = *(unsigned int *)(v26 + 56);
  if ( (int)v29 >= 0 )
  {
    v40 = timer + v29;
    v30 = gmtime(&v40);
    strftime(v42, 0x64uLL, "%a, %d %b %Y %H:%M:%S GMT", v30);
    my_snprintf(
      src,
      0x3E8uLL,
      "Cache-Control: max-age=%d\r\nExpires: %s\r\n",
      *(unsigned int *)(*(_QWORD *)(a1 + 8) + 56LL),
      v42);
    v31 = strlen(src);
    httpd_realloc_str(v22, (__int64 *)(a1 + 464), v31 + *(_QWORD *)(a1 + 472));
    memmove((void *)(*(_QWORD *)(a1 + 472) + *(_QWORD *)(a1 + 368)), src, v31);
    v20 = *(_QWORD *)(a1 + 472) + v31;
    *(_QWORD *)(a1 + 472) = v20;
  }
  v32 = v39;
  if ( *v39 )
  {
    v33 = strlen(v39);
    httpd_realloc_str(v22, v18, v33 + v20);
    memmove((char *)*v22 + *v19, v32, v33);
    v34 = *v19 + v33;
    *v19 = v34;
    v20 = v34;
  }
  httpd_realloc_str(v22, v18, v20 + 2);
  *(_WORD *)((char *)*v22 + *v19) = 2573;
  *v19 += 2LL;
}

//----- (000000000000EE60) ----------------------------------------------------
int __fastcall ext_compare(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (000000000000EE70) ----------------------------------------------------
__int64 __fastcall check_referrer(__int64 a1)
{
  __int64 v1; // r14
  char *v2; // rbx
  unsigned int v3; // ebp
  __int64 v4; // r13
  const char *v5; // rdi
  char *v6; // rax
  char *v7; // r12
  char *v8; // rbx
  unsigned __int64 v9; // rbp
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  _BYTE *v12; // r15
  unsigned __int64 v13; // r12
  const unsigned __int16 **v14; // r13
  char v15; // al
  __int64 v16; // rbp
  _BYTE *v17; // rsi
  char *v18; // rdi
  __int64 v19; // rcx
  const char *v20; // rax
  const char *v21; // r14
  __int16 v22; // ax
  int v23; // edx
  socklen_t v24; // esi
  char *v25; // rdi
  size_t v26; // rax
  __int64 v28; // [rsp+10h] [rbp-38h]

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(char **)(v1 + 112);
  v3 = 1;
  if ( v2 )
  {
    v4 = a1;
    v5 = *(const char **)(a1 + 272);
    if ( v5 && *v5 && (v6 = strstr(v5, "//")) != 0LL )
    {
      v7 = v6;
      v8 = v6 + 2;
      v9 = 2LL;
      v10 = 0x400800000000001LL;
      while ( 1 )
      {
        v11 = (unsigned __int8)v7[v9];
        if ( v11 <= 0x3A )
        {
          if ( _bittest64(&v10, v11) )
            break;
        }
        ++v9;
      }
      httpd_realloc_str((void **)&really_check_referrer_refhost, &really_check_referrer_refhost_size, v9 - 2);
      v12 = (_BYTE *)really_check_referrer_refhost;
      v28 = v4;
      if ( v9 >= 3 )
      {
        v13 = (unsigned __int64)&v7[v9];
        v14 = __ctype_b_loc();
        do
        {
          v15 = *v8;
          if ( ((*v14)[*v8] & 0x100) != 0 )
          {
            v16 = *v8;
            v15 = (*__ctype_tolower_loc())[v16];
          }
          *v12 = v15;
          ++v8;
          ++v12;
        }
        while ( (unsigned __int64)v8 < v13 );
      }
      *v12 = 0;
      v25 = *(char **)(v1 + 120);
      v4 = v28;
      v3 = 1;
      if ( !v25 )
      {
        if ( *(_DWORD *)(v1 + 100) )
        {
          v25 = *(char **)(v28 + 512);
          if ( !v25 )
            return v3;
        }
        else
        {
          v25 = *(char **)(v1 + 8);
          if ( !v25 )
            return v3;
        }
      }
      if ( (unsigned int)match(v25, (_BYTE *)really_check_referrer_refhost) )
        return v3;
      v18 = *(char **)(v1 + 112);
      v17 = *(_BYTE **)(v28 + 232);
    }
    else
    {
      if ( !*(_DWORD *)(v1 + 128) )
        return v3;
      v17 = *(_BYTE **)(v4 + 232);
      v18 = v2;
    }
    if ( (unsigned int)match(v18, v17) )
    {
      v19 = *(_QWORD *)(v4 + 8);
      if ( !*(_DWORD *)(v19 + 100) || (v20 = *(const char **)(v4 + 512)) == 0LL )
        v20 = *(const char **)(v19 + 8);
      v21 = "";
      if ( v20 )
        v21 = v20;
      v22 = *(_WORD *)(v4 + 16);
      v23 = 28;
      if ( v22 != 10 )
        v23 = 0;
      v24 = 16;
      if ( v22 != 2 )
        v24 = v23;
      if ( getnameinfo((const struct sockaddr *)(v4 + 16), v24, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
      {
        strcpy(httpd_ntoa_str, "?");
      }
      else if ( !*(_DWORD *)(v4 + 24)
             && !*(_DWORD *)(v4 + 28)
             && *(_DWORD *)(v4 + 32) == -65536
             && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
      {
        v26 = strlen(src);
        memmove(httpd_ntoa_str, src, v26 + 1);
      }
      v3 = 0;
      syslog(
        6,
        "%.80s non-local referrer \"%.80s%.80s\" \"%.80s\"",
        httpd_ntoa_str,
        v21,
        *(const char **)(v4 + 208),
        *(const char **)(v4 + 272));
      httpd_send_err(
        v4,
        0x193u,
        "Forbidden",
        (char *)"",
        "You must supply a local referrer to get URL '%.80s' from this server.\n",
        *(char **)(v4 + 208));
    }
  }
  return v3;
}
// 1B2A0: using guessed type __int64 really_check_referrer_refhost;
// 1B2A8: using guessed type __int64 really_check_referrer_refhost_size;

//----- (000000000000F130) ----------------------------------------------------
__int64 __fastcall auth_check2(__int64 a1, char *s)
{
  size_t v4; // rax
  unsigned int v5; // ebx
  _BYTE *v6; // rbx
  size_t v7; // rax
  unsigned __int8 v9; // al
  unsigned __int8 *v10; // rbx
  unsigned int v11; // ebp
  int v12; // esi
  int v13; // ecx
  unsigned int v14; // edi
  int v15; // eax
  __int64 v16; // rbp
  __int64 v17; // rax
  char *v18; // rax
  const char *v19; // r12
  char *v20; // rax
  const char *v21; // rbx
  FILE *v22; // rax
  FILE *v23; // r13
  __int64 v24; // rax
  char *v25; // rax
  char *v26; // rbx
  const char *v27; // rbx
  char *v28; // rax
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rax
  char *v33; // rdi
  char *v34; // rsi
  __int16 v35; // ax
  int v36; // edx
  socklen_t v37; // esi
  size_t v38; // rax
  char *v39; // rax
  unsigned __int64 v40; // rax
  struct stat buf; // [rsp+10h] [rbp-4B8h] BYREF
  char sa[512]; // [rsp+A0h] [rbp-428h] BYREF
  char s1[552]; // [rsp+2A0h] [rbp-228h] BYREF

  v4 = strlen(s);
  httpd_realloc_str((void **)&auth_check2_authpath, &auth_check2_maxauthpath, v4 + 11);
  v5 = 0;
  my_snprintf(auth_check2_authpath, auth_check2_maxauthpath, "%s/%s", s, ".htpasswd");
  if ( stat(auth_check2_authpath, &buf) >= 0 )
  {
    v6 = *(_BYTE **)(a1 + 352);
    if ( *v6 && !strncmp(*(const char **)(a1 + 352), "Basic ", 6uLL) )
    {
      v9 = v6[6];
      if ( v9 )
      {
        v10 = v6 + 7;
        v11 = 0;
        v12 = 0;
        v13 = 0;
        do
        {
          v14 = b64_decode_table[v9];
          if ( v14 == -1 )
          {
            v14 = v11;
          }
          else
          {
            switch ( v12 )
            {
              case 0:
                v12 = 1;
                break;
              case 1:
                v12 = 2;
                if ( v13 <= 498 )
                {
                  v15 = ((v14 >> 4) & 3) + 4 * v11;
                  goto LABEL_18;
                }
                break;
              case 2:
                v12 = 3;
                if ( v13 <= 498 )
                {
                  v15 = (16 * v11) | (v14 >> 2) & 0xF;
LABEL_18:
                  v16 = v13++;
                  sa[v16] = v15;
                }
                break;
              case 3:
                v12 = 0;
                if ( v13 <= 498 )
                {
                  v17 = v13++;
                  sa[v17] = v14 | ((_BYTE)v11 << 6);
                }
                break;
              default:
                break;
            }
          }
          v9 = *v10++;
          v11 = v14;
        }
        while ( v9 );
      }
      else
      {
        v13 = 0;
      }
      sa[v13] = 0;
      v18 = strchr(sa, 58);
      if ( v18 )
      {
        v19 = v18 + 1;
        *v18 = 0;
        v20 = strchr(v18 + 1, 58);
        if ( v20 )
          *v20 = 0;
        v21 = auth_check2_authpath;
        if ( auth_check2_maxprevauthpath
          && !strcmp(auth_check2_authpath, auth_check2_prevauthpath)
          && buf.st_mtim.tv_sec == auth_check2_prevmtime
          && !strcmp(sa, auth_check2_prevuser) )
        {
          v39 = crypt(v19, auth_check2_prevcryp);
          if ( !strcmp(v39, auth_check2_prevcryp) )
          {
            v40 = strlen(sa);
            httpd_realloc_str((void **)(a1 + 360), (__int64 *)(a1 + 456), v40);
            v33 = *(char **)(a1 + 360);
            v34 = sa;
            goto LABEL_56;
          }
          goto LABEL_53;
        }
        v22 = fopen(v21, "r");
        if ( !v22 )
        {
          v35 = *(_WORD *)(a1 + 16);
          v36 = 28;
          if ( v35 != 10 )
            v36 = 0;
          v37 = 16;
          if ( v35 != 2 )
            v37 = v36;
          if ( getnameinfo((const struct sockaddr *)(a1 + 16), v37, httpd_ntoa_str, 0xC8u, 0LL, 0, 1) )
          {
            strcpy(httpd_ntoa_str, "?");
          }
          else if ( !*(_DWORD *)(a1 + 24)
                 && !*(_DWORD *)(a1 + 28)
                 && *(_DWORD *)(a1 + 32) == -65536
                 && !(*(_DWORD *)httpd_ntoa_str ^ 0x66663A3A | *(_DWORD *)&httpd_ntoa_str[3] ^ 0x3A666666) )
          {
            v38 = strlen(src);
            memmove(httpd_ntoa_str, src, v38 + 1);
          }
          syslog(3, "%.80s auth file %.80s could not be opened - %m", httpd_ntoa_str, auth_check2_authpath);
          httpd_send_err(
            a1,
            0x193u,
            "Forbidden",
            (char *)"",
            "The requested URL '%.80s' is protected by an authentication file, but the authentication file cannot be opened.\n",
            *(char **)(a1 + 208));
          return (unsigned int)-1;
        }
        v23 = v22;
        if ( fgets(s1, 500, v22) )
        {
          while ( 1 )
          {
            v24 = (int)(strlen(s1) - 1);
            if ( s1[v24] == 10 )
              s1[v24] = 0;
            v25 = strchr(s1, 58);
            if ( v25 )
            {
              v26 = v25;
              *v25 = 0;
              if ( !strcmp(s1, sa) )
                break;
            }
            if ( !fgets(s1, 500, v23) )
              goto LABEL_39;
          }
          v27 = v26 + 1;
          fclose(v23);
          v28 = crypt(v19, v27);
          if ( !strcmp(v28, v27) )
          {
            v29 = strlen(s1);
            httpd_realloc_str((void **)(a1 + 360), (__int64 *)(a1 + 456), v29);
            strcpy(*(char **)(a1 + 360), s1);
            v30 = strlen(auth_check2_authpath);
            httpd_realloc_str((void **)&auth_check2_prevauthpath, &auth_check2_maxprevauthpath, v30);
            strcpy(auth_check2_prevauthpath, auth_check2_authpath);
            auth_check2_prevmtime = buf.st_mtim.tv_sec;
            v31 = strlen(sa);
            httpd_realloc_str((void **)&auth_check2_prevuser, &auth_check2_maxprevuser, v31);
            strcpy(auth_check2_prevuser, sa);
            v32 = strlen(v27);
            httpd_realloc_str((void **)&auth_check2_prevcryp, &auth_check2_maxprevcryp, v32);
            v33 = auth_check2_prevcryp;
            v34 = (char *)v27;
LABEL_56:
            strcpy(v33, v34);
            return 1;
          }
LABEL_53:
          send_authenticate(a1, s);
          return (unsigned int)-1;
        }
LABEL_39:
        fclose(v23);
      }
    }
    v7 = strlen(s);
    httpd_realloc_str((void **)&send_authenticate_header, &send_authenticate_maxheader, v7 + 35);
    my_snprintf(
      *(char **)&send_authenticate_header,
      send_authenticate_maxheader,
      "%s%s\"\r\n",
      send_authenticate_headstr,
      s);
    httpd_send_err(
      a1,
      0x191u,
      "Unauthorized",
      *(char **)&send_authenticate_header,
      "Authorization required for the URL '%.80s'.\n",
      *(char **)(a1 + 208));
    v5 = -1;
    if ( *(_DWORD *)(a1 + 180) == 3 )
      *(_DWORD *)(a1 + 556) = 1;
  }
  return v5;
}
// 12E80: using guessed type _DWORD b64_decode_table[256];
// 1B250: using guessed type __int64 auth_check2_maxauthpath;
// 1B260: using guessed type __int64 auth_check2_maxprevauthpath;
// 1B268: using guessed type __int64 auth_check2_prevmtime;
// 1B278: using guessed type __int64 auth_check2_maxprevuser;
// 1B288: using guessed type __int64 auth_check2_maxprevcryp;
// 1B298: using guessed type __int64 send_authenticate_maxheader;
// F130: using guessed type char s[512];
// F130: using guessed type char s1[552];

//----- (000000000000F700) ----------------------------------------------------
void *__fastcall send_authenticate(__int64 a1, char *s)
{
  size_t v2; // rax
  void *result; // rax

  v2 = strlen(s);
  httpd_realloc_str((void **)&send_authenticate_header, &send_authenticate_maxheader, v2 + 35);
  my_snprintf(
    *(char **)&send_authenticate_header,
    send_authenticate_maxheader,
    "%s%s\"\r\n",
    send_authenticate_headstr,
    s);
  result = httpd_send_err(
             a1,
             0x191u,
             "Unauthorized",
             *(char **)&send_authenticate_header,
             "Authorization required for the URL '%.80s'.\n",
             *(char **)(a1 + 208));
  if ( *(_DWORD *)(a1 + 180) == 3 )
    *(_DWORD *)(a1 + 556) = 1;
  return result;
}
// 1B298: using guessed type __int64 send_authenticate_maxheader;

//----- (000000000000F7A0) ----------------------------------------------------
int __fastcall name_compare(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (000000000000F7B0) ----------------------------------------------------
int __fastcall cgi_kill(__suseconds_t a1, struct timeval *a2)
{
  struct timeval *v2; // rax

  LODWORD(v2) = kill(a1, 2);
  if ( !(_DWORD)v2 )
  {
    syslog(4, "killed CGI process %d", (unsigned int)a1);
    v2 = tmr_create(a2, (__time_t)cgi_kill2, a1, 5000LL, 0);
    if ( !v2 )
    {
      syslog(2, "tmr_create(cgi_kill2) failed");
      exit(1);
    }
  }
  return (int)v2;
}

//----- (000000000000F830) ----------------------------------------------------
void __fastcall cgi_kill2(unsigned int a1)
{
  if ( !kill(a1, 9) )
    syslog(4, "hard-killed CGI process %d", a1);
}

//----- (000000000000F860) ----------------------------------------------------
__int64 __fastcall cgi_interpose_input(__int64 a1, int a2)
{
  __int64 v2; // r14
  unsigned __int64 v3; // r13
  __int64 v4; // r14
  __int64 v5; // rax
  int v6; // ebx
  int v7; // eax
  int v8; // ebp
  int v9; // eax
  __int64 result; // rax
  unsigned __int64 v11; // rdx
  size_t v12; // rdx
  unsigned __int64 v13; // rbp
  __int64 v14; // rax
  int v15; // r14d
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  int v19; // ebp
  int v20; // eax
  char v21[2]; // [rsp+Eh] [rbp-43Ah] BYREF
  char buf[1080]; // [rsp+10h] [rbp-438h] BYREF

  v2 = *(_QWORD *)(a1 + 168);
  v3 = *(_QWORD *)(a1 + 160) - v2;
  if ( !v3 )
    goto LABEL_12;
  v4 = *(_QWORD *)(a1 + 144) + v2;
  v5 = 0LL;
  v6 = 0;
  while ( 1 )
  {
    v7 = write(a2, (const void *)(v4 + v5), v3 - v5);
    v8 = v7;
    if ( v7 < 0 )
      break;
    v6 += v7;
    if ( !v7 )
      goto LABEL_11;
LABEL_4:
    v5 = v6;
    if ( v3 <= v6 )
      goto LABEL_11;
  }
  v9 = *__errno_location();
  if ( v9 == 11 || v9 == 4 )
  {
    sleep(1u);
    goto LABEL_4;
  }
  v6 = v8;
LABEL_11:
  result = v6;
  if ( v3 != v6 )
    return result;
LABEL_12:
  v11 = *(_QWORD *)(a1 + 496);
  if ( v11 <= v3 )
    goto LABEL_33;
LABEL_13:
  v12 = v11 - v3;
  if ( v12 >= 0x400 )
    v12 = 1024LL;
  result = read(*(_DWORD *)(a1 + 704), buf, v12);
  if ( result >= 0 )
  {
    if ( !result )
      return result;
    v13 = result;
    v14 = 0LL;
    v15 = 0;
    while ( 1 )
    {
      v16 = write(a2, &buf[v14], v13 - v14);
      v17 = v16;
      if ( v16 < 0 )
      {
        v18 = *__errno_location();
        if ( v18 != 11 && v18 != 4 )
        {
          v15 = v17;
LABEL_31:
          result = v15;
          if ( v13 != v15 )
            return result;
          v3 += v13;
LABEL_19:
          v11 = *(_QWORD *)(a1 + 496);
          if ( v11 <= v3 )
          {
LABEL_33:
            if ( sub_process == 1 )
            {
              v19 = *(_DWORD *)(a1 + 704);
              v20 = fcntl(v19, 3, 0LL);
              if ( v20 != -1 && (v20 | 0x800) != v20 )
                fcntl(v19, 4);
            }
            return read(*(_DWORD *)(a1 + 704), v21, 2uLL);
          }
          goto LABEL_13;
        }
        sleep(1u);
      }
      else
      {
        v15 += v16;
        if ( !v16 )
          goto LABEL_31;
      }
      v14 = v15;
      if ( v13 <= v15 )
        goto LABEL_31;
    }
  }
  result = (unsigned int)*__errno_location();
  if ( (_DWORD)result == 11 || (_DWORD)result == 4 )
  {
    sleep(1u);
    goto LABEL_19;
  }
  return result;
}
// 1B100: using guessed type char sub_process;
// F860: using guessed type char var_43A[2];

//----- (000000000000FA70) ----------------------------------------------------
int __fastcall cgi_interpose_output(__int64 a1, int a2)
{
  int v2; // ebx
  int v3; // eax
  char *v4; // rax
  char *v5; // r15
  unsigned __int64 v6; // r12
  char *v7; // rax
  size_t v8; // rbx
  unsigned __int64 v9; // r13
  int *v10; // rbx
  char *v11; // rbx
  __int64 v12; // r13
  size_t v13; // rax
  char *v14; // rax
  char *v15; // rax
  char *v16; // rbp
  size_t v17; // rax
  __int64 v18; // rcx
  const char *v19; // r8
  int v20; // r13d
  int v21; // ebx
  size_t v22; // rax
  unsigned __int64 v23; // rbp
  __int64 v24; // rax
  int v25; // eax
  int v26; // eax
  __int64 v27; // rax
  int v28; // ebp
  int v29; // eax
  int v30; // eax
  ssize_t v31; // rax
  int v32; // r12d
  int v33; // r13d
  __int64 v34; // rax
  int v35; // ebx
  int v36; // eax
  int v37; // ebp
  int v38; // eax
  int v39; // eax
  char *haystack; // [rsp+10h] [rbp-448h] BYREF
  __int64 v42; // [rsp+18h] [rbp-440h] BYREF
  char buf[1080]; // [rsp+20h] [rbp-438h] BYREF

  v2 = *(_DWORD *)(a1 + 704);
  v3 = fcntl(v2, 3, 0LL);
  if ( v3 != -1 && (v3 & 0xFFFFF7FF) != v3 )
    fcntl(v2, 4);
  v42 = 600LL;
  v4 = (char *)malloc(0x259uLL);
  haystack = v4;
  ++str_alloc_count;
  str_alloc_size += 600LL;
  if ( !v4 )
  {
    syslog(3, "out of memory reallocating a string to %ld bytes", 600LL);
    exit(1);
  }
  v5 = v4;
  v6 = 0LL;
  while ( 1 )
  {
    LODWORD(v7) = read(a2, buf, 0x400uLL);
    if ( (int)v7 < 0 )
      break;
LABEL_7:
    if ( !(_DWORD)v7 )
      goto LABEL_15;
    v8 = (int)v7;
    v9 = (int)v7 + v6;
    httpd_realloc_str((void **)&haystack, &v42, v9);
    v5 = haystack;
    memcpy(&haystack[v6], buf, v8);
    v5[v9] = 0;
    v7 = strstr(v5, "\r\n\r\n");
    if ( !v7 )
    {
      v7 = strstr(v5, "\n\n");
      v6 = v9;
      if ( !v7 )
        continue;
    }
    v11 = v7;
    v6 = v9;
    if ( !*v5 )
      return (int)v7;
    goto LABEL_16;
  }
  v10 = __errno_location();
  while ( 1 )
  {
    LODWORD(v7) = *v10;
    if ( *v10 != 11 && (_DWORD)v7 != 4 )
      break;
    sleep(1u);
    LODWORD(v7) = read(a2, buf, 0x400uLL);
    if ( (int)v7 >= 0 )
      goto LABEL_7;
  }
LABEL_15:
  v11 = &v5[v6];
  if ( !*v5 )
    return (int)v7;
LABEL_16:
  v12 = 200LL;
  if ( !strncmp(v5, "HTTP/", 5uLL) )
  {
    v13 = strcspn(v5, " \t");
    v12 = strtol(&v5[v13], 0LL, 10);
  }
  v14 = strstr(v5, "Location:");
  if ( v14 && v14 < v11 && (v14 == v5 || *(v14 - 1) == 10) )
    v12 = 302LL;
  v15 = strstr(v5, "Status:");
  if ( v15 )
  {
    v16 = v15;
    if ( v15 < v11 && (v15 == v5 || *(v15 - 1) == 10) )
    {
      v17 = strspn(v15 + 7, " \t");
      v12 = strtol(&v16[v17 + 7], 0LL, 10);
    }
  }
  if ( (int)v12 > 399 )
  {
    if ( (int)v12 <= 499 )
    {
      switch ( (int)v12 )
      {
        case 400:
          v18 = v12;
          v19 = *(const char **)&httpd_err400title;
          break;
        case 401:
          v18 = v12;
          v19 = "Unauthorized";
          break;
        case 403:
          v18 = v12;
          v19 = "Forbidden";
          break;
        case 404:
          v18 = v12;
          v19 = "Not Found";
          break;
        case 408:
          v18 = v12;
          v19 = httpd_err408title[0];
          break;
        case 451:
          v18 = v12;
          v19 = "Unavailable For Legal Reasons";
          break;
        default:
          goto LABEL_51;
      }
      goto LABEL_52;
    }
    switch ( (_DWORD)v12 )
    {
      case 0x1F4:
        v18 = v12;
        v19 = "Internal Error";
        goto LABEL_52;
      case 0x1F5:
        v18 = v12;
        v19 = "Not Implemented";
        goto LABEL_52;
      case 0x1F7:
        v18 = v12;
        v19 = *(const char **)&httpd_err503title;
        goto LABEL_52;
    }
LABEL_51:
    v18 = v12;
    v19 = "Something";
    goto LABEL_52;
  }
  if ( (_DWORD)v12 == 200 )
  {
    v18 = v12;
    v19 = "OK";
    goto LABEL_52;
  }
  if ( (_DWORD)v12 == 302 )
  {
    v18 = v12;
    v19 = "Found";
    goto LABEL_52;
  }
  if ( (_DWORD)v12 != 304 )
    goto LABEL_51;
  v18 = v12;
  v19 = "Not Modified";
LABEL_52:
  v20 = 0;
  my_snprintf(buf, 0x400uLL, "HTTP/1.0 %d %s\r\n", v18, v19);
  v21 = *(_DWORD *)(a1 + 704);
  v22 = strlen(buf);
  if ( !v22 )
    goto LABEL_62;
  v23 = v22;
  v24 = 0LL;
  while ( 1 )
  {
    v25 = write(v21, &buf[v24], v23 - v24);
    if ( v25 < 0 )
      break;
    if ( !v25 )
      goto LABEL_61;
    v20 += v25;
LABEL_55:
    v24 = v20;
    if ( v23 <= v20 )
      goto LABEL_61;
  }
  v26 = *__errno_location();
  if ( v26 == 11 || v26 == 4 )
  {
    sleep(1u);
    goto LABEL_55;
  }
LABEL_61:
  v21 = *(_DWORD *)(a1 + 704);
LABEL_62:
  if ( !v6 )
    goto LABEL_73;
  v27 = 0LL;
  v28 = 0;
  while ( 2 )
  {
    v29 = write(v21, &v5[v27], v6 - v27);
    if ( v29 >= 0 )
    {
      if ( !v29 )
        break;
      v28 += v29;
      goto LABEL_65;
    }
    v30 = *__errno_location();
    if ( v30 == 11 || v30 == 4 )
    {
      sleep(1u);
LABEL_65:
      v27 = v28;
      if ( v6 <= v28 )
        break;
      continue;
    }
    break;
  }
LABEL_73:
  while ( 2 )
  {
    while ( 1 )
    {
      v31 = read(a2, buf, 0x400uLL);
      v32 = v31;
      if ( (int)v31 >= 0 )
        break;
      v39 = *__errno_location();
      if ( v39 != 11 && v39 != 4 )
        goto LABEL_89;
      sleep(1u);
    }
    if ( !(_DWORD)v31 || !(v31 << 32) )
      break;
    v33 = *(_DWORD *)(a1 + 704);
    v34 = 0LL;
    v35 = 0;
    while ( 2 )
    {
      v36 = write(v33, &buf[v34], v32 - v34);
      v37 = v36;
      if ( v36 >= 0 )
      {
        v35 += v36;
        if ( !v36 )
          goto LABEL_85;
        goto LABEL_78;
      }
      v38 = *__errno_location();
      if ( v38 == 11 || v38 == 4 )
      {
        sleep(1u);
LABEL_78:
        v34 = v35;
        if ( v32 <= (unsigned __int64)v35 )
          goto LABEL_85;
        continue;
      }
      break;
    }
    v35 = v37;
LABEL_85:
    if ( v35 == v32 )
      continue;
    break;
  }
LABEL_89:
  LODWORD(v7) = shutdown(*(_DWORD *)(a1 + 704), 1);
  return (int)v7;
}
// FFB5: conditional instruction was optimized away because eax.4>=1
// 193B0: using guessed type char *httpd_err408title[4];
// 1B104: using guessed type int str_alloc_count;
// 1B108: using guessed type __int64 str_alloc_size;
// FA70: using guessed type char buf[1080];

//----- (0000000000010010) ----------------------------------------------------
char *__fastcall build_env(const char *a1, const char *a2)
{
  size_t v3; // rbx
  unsigned __int64 v4; // rax
  size_t v5; // rsi
  char *result; // rax

  v3 = strlen(a1);
  v4 = v3 + strlen(a2);
  v5 = build_env_maxbuf;
  if ( v4 > build_env_maxbuf )
  {
    httpd_realloc_str((void **)&build_env_buf, &build_env_maxbuf, v4);
    v5 = build_env_maxbuf;
  }
  my_snprintf(build_env_buf, v5, a1, a2);
  result = strdup(build_env_buf);
  if ( !result )
  {
    syslog(3, "out of memory copying environment variable");
    exit(1);
  }
  return result;
}
// 1B498: using guessed type __int64 build_env_maxbuf;

//----- (00000000000100A0) ----------------------------------------------------
__int64 fdwatch_get_nfiles()
{
  int rlim_cur; // r12d
  void *v1; // r15
  void *v2; // rcx
  __int64 result; // rax
  struct pollfd *v4; // rbx
  void *v5; // r15
  __int64 v6; // rcx
  struct pollfd *v7; // rcx
  __int64 v8; // rdx
  struct rlimit v9[3]; // [rsp+0h] [rbp-38h] BYREF

  nfiles = getdtablesize();
  if ( getrlimit(RLIMIT_NOFILE, v9) )
    goto LABEL_7;
  nfiles = v9[0].rlim_cur;
  if ( v9[0].rlim_max == -1LL )
  {
    v9[0].rlim_cur = 0x2000LL;
  }
  else if ( v9[0].rlim_max > v9[0].rlim_cur )
  {
    v9[0].rlim_cur = v9[0].rlim_max;
  }
  if ( setrlimit(RLIMIT_NOFILE, v9) )
  {
LABEL_7:
    rlim_cur = nfiles;
  }
  else
  {
    rlim_cur = v9[0].rlim_cur;
    nfiles = v9[0].rlim_cur;
  }
  nwatches = 0LL;
  v1 = malloc(4LL * rlim_cur);
  fd_rw = (__int64)v1;
  v2 = malloc(8LL * rlim_cur);
  fd_data = (__int64)v2;
  result = 0xFFFFFFFFLL;
  if ( v1 && v2 )
  {
    if ( rlim_cur > 0 )
      memset(v1, 255, 4LL * (unsigned int)rlim_cur);
    v4 = (struct pollfd *)malloc(8LL * rlim_cur);
    pollfds = v4;
    v5 = malloc(4LL * rlim_cur);
    poll_fdidx = (__int64)v5;
    poll_rfdidx = (__int64)malloc(4LL * rlim_cur);
    result = 0xFFFFFFFFLL;
    if ( v4 != 0LL && v5 != 0LL && poll_rfdidx != 0 )
    {
      result = (unsigned int)rlim_cur;
      if ( rlim_cur > 0 )
      {
        memset(v5, 255, 4LL * (unsigned int)rlim_cur);
        if ( (unsigned __int64)(unsigned int)rlim_cur - 1 >= 7 )
        {
          v6 = 0LL;
          do
          {
            v4[v6].fd = -1;
            v4[v6 + 1].fd = -1;
            v4[v6 + 2].fd = -1;
            v4[v6 + 3].fd = -1;
            v4[v6 + 4].fd = -1;
            v4[v6 + 5].fd = -1;
            v4[v6 + 6].fd = -1;
            v4[v6 + 7].fd = -1;
            v6 += 8LL;
          }
          while ( (rlim_cur & 0xFFFFFFF8) != v6 );
        }
        else
        {
          v6 = 0LL;
        }
        if ( (rlim_cur & 7) != 0 )
        {
          v7 = &v4[v6];
          v8 = 0LL;
          do
            v7[v8++].fd = -1;
          while ( (rlim_cur & 7) != v8 );
        }
        return (unsigned int)rlim_cur;
      }
    }
  }
  return result;
}
// 1B4A0: using guessed type int nfiles;
// 1B4A8: using guessed type __int64 nwatches;
// 1B4B0: using guessed type __int64 fd_rw;
// 1B4B8: using guessed type __int64 fd_data;
// 1B4D0: using guessed type __int64 poll_fdidx;
// 1B4D8: using guessed type __int64 poll_rfdidx;

//----- (00000000000102A0) ----------------------------------------------------
void __fastcall fdwatch_add_fd(int a1, __int64 a2, int a3)
{
  __int64 v5; // rax
  __int64 v6; // rbx
  int v7; // ecx
  struct pollfd *v8; // rdi
  __int16 v9; // dx

  if ( a1 < 0 || nfiles <= a1 || (v5 = fd_rw, v6 = (unsigned int)a1, *(_DWORD *)(fd_rw + 4LL * (unsigned int)a1) != -1) )
  {
    syslog(3, "bad fd (%d) passed to fdwatch_add_fd!", (unsigned int)a1);
    return;
  }
  v7 = npoll_fds;
  if ( npoll_fds < nfiles )
  {
    v8 = pollfds;
    pollfds[npoll_fds].fd = a1;
    if ( a3 )
    {
      if ( a3 != 1 )
      {
LABEL_12:
        *(_DWORD *)(poll_fdidx + 4 * v6) = v7;
        npoll_fds = v7 + 1;
        goto LABEL_13;
      }
      v9 = 4;
    }
    else
    {
      v9 = 1;
    }
    v8[v7].events = v9;
    goto LABEL_12;
  }
  syslog(3, "too many fds in poll_add_fd!");
  v5 = fd_rw;
LABEL_13:
  *(_DWORD *)(v5 + 4 * v6) = a3;
  *(_QWORD *)(fd_data + 8 * v6) = a2;
}
// 1B4A0: using guessed type int nfiles;
// 1B4B0: using guessed type __int64 fd_rw;
// 1B4B8: using guessed type __int64 fd_data;
// 1B4D0: using guessed type __int64 poll_fdidx;
// 1B4E0: using guessed type int npoll_fds;

//----- (0000000000010350) ----------------------------------------------------
void __fastcall fdwatch_del_fd(unsigned int a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // r9
  struct pollfd *v6; // rdi
  struct pollfd v7; // r8

  if ( (a1 & 0x80000000) != 0 || nfiles <= (int)a1 || (v1 = fd_rw, v2 = a1, *(_DWORD *)(fd_rw + 4LL * a1) == -1) )
  {
    syslog(3, "bad fd (%d) passed to fdwatch_del_fd!", a1);
  }
  else
  {
    v3 = poll_fdidx;
    v4 = *(unsigned int *)(poll_fdidx + 4LL * a1);
    if ( (int)v4 < 0 || (int)v4 >= nfiles )
    {
      syslog(3, "bad idx (%d) in poll_del_fd!", v4);
      v1 = fd_rw;
    }
    else
    {
      v5 = npoll_fds--;
      v6 = pollfds;
      v7 = pollfds[v5 - 1];
      pollfds[v4] = v7;
      *(_DWORD *)(v3 + 4LL * v7.fd) = v4;
      v6[v5 - 1].fd = -1;
      *(_DWORD *)(v3 + 4 * v2) = -1;
    }
    *(_DWORD *)(v1 + 4 * v2) = -1;
    *(_QWORD *)(fd_data + 8 * v2) = 0LL;
  }
}
// 1B4A0: using guessed type int nfiles;
// 1B4B0: using guessed type __int64 fd_rw;
// 1B4B8: using guessed type __int64 fd_data;
// 1B4D0: using guessed type __int64 poll_fdidx;
// 1B4E0: using guessed type int npoll_fds;

//----- (0000000000010410) ----------------------------------------------------
__int64 __fastcall fdwatch(int timeout)
{
  int v1; // eax
  __int64 v2; // r9
  struct pollfd *v3; // r10
  __int64 v4; // rdi
  __int64 v5; // r8
  int v6; // ecx
  __int64 v7; // rsi

  ++nwatches;
  v1 = poll(pollfds, npoll_fds, timeout);
  if ( v1 > 0 )
  {
    v2 = (unsigned int)npoll_fds;
    if ( npoll_fds <= 0 )
    {
      v6 = 0;
      goto LABEL_9;
    }
    v3 = pollfds;
    v4 = 0LL;
    v5 = poll_rfdidx;
    v6 = 0;
    while ( 1 )
    {
      if ( (v3[v4].revents & 0x3D) != 0 )
      {
        v7 = v6++;
        *(_DWORD *)(v5 + 4 * v7) = v3[v4].fd;
        if ( v6 == v1 )
          break;
      }
      if ( v2 == ++v4 )
        goto LABEL_9;
    }
  }
  v6 = v1;
LABEL_9:
  nreturned = v6;
  next_ridx = 0;
  return (unsigned int)v6;
}
// 1B4A8: using guessed type __int64 nwatches;
// 1B4C0: using guessed type int nreturned;
// 1B4C4: using guessed type int next_ridx;
// 1B4D8: using guessed type __int64 poll_rfdidx;
// 1B4E0: using guessed type int npoll_fds;

//----- (00000000000104A0) ----------------------------------------------------
__int64 __fastcall fdwatch_check_fd(int a1)
{
  int v1; // eax
  __int64 v2; // rdx
  __int16 revents; // cx
  unsigned int v4; // ebx

  if ( a1 < 0 || nfiles <= a1 || (v1 = *(_DWORD *)(fd_rw + 4LL * (unsigned int)a1), v1 == -1) )
  {
    v4 = 0;
    syslog(3, "bad fd (%d) passed to fdwatch_check_fd!", (unsigned int)a1);
  }
  else
  {
    v2 = *(unsigned int *)(poll_fdidx + 4LL * (unsigned int)a1);
    if ( (int)v2 < 0 || (int)v2 >= nfiles )
    {
      v4 = 0;
      syslog(3, "bad fdidx (%d) in poll_check_fd!", v2);
    }
    else
    {
      revents = pollfds[v2].revents;
      v4 = 0;
      if ( (revents & 8) == 0 )
      {
        if ( v1 == 1 )
          return revents & 0x34;
        if ( !v1 )
          return revents & 0x31;
      }
    }
  }
  return v4;
}
// 1B4A0: using guessed type int nfiles;
// 1B4B0: using guessed type __int64 fd_rw;
// 1B4D0: using guessed type __int64 poll_fdidx;

//----- (0000000000010530) ----------------------------------------------------
__int64 fdwatch_get_next_client_data()
{
  __int64 v0; // rdx
  __int64 v1; // rbx
  __int64 v2; // rax

  v0 = (unsigned int)next_ridx;
  v1 = -1LL;
  if ( next_ridx < nreturned )
  {
    ++next_ridx;
    if ( (int)v0 < 0 || nfiles <= (int)v0 )
    {
      v1 = 0LL;
      syslog(3, "bad ridx (%d) in poll_get_fd!", v0);
    }
    else
    {
      v2 = *(unsigned int *)(poll_rfdidx + 4 * v0);
      v1 = 0LL;
      if ( (int)v2 >= 0 && (int)v2 < nfiles )
        return *(_QWORD *)(fd_data + 8 * v2);
    }
  }
  return v1;
}
// 1B4A0: using guessed type int nfiles;
// 1B4B8: using guessed type __int64 fd_data;
// 1B4C0: using guessed type int nreturned;
// 1B4C4: using guessed type int next_ridx;
// 1B4D8: using guessed type __int64 poll_rfdidx;

//----- (00000000000105A0) ----------------------------------------------------
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm0,xmm4,xmm5> fdwatch_logstats(__int64 a1)
{
  if ( a1 > 0 )
    syslog(5, "  fdwatch - %ld %ss (%g/sec)", nwatches, "poll", (float)((float)(int)nwatches / (float)(int)a1));
  nwatches = 0LL;
}
// 1B4A8: using guessed type __int64 nwatches;

//----- (00000000000105F0) ----------------------------------------------------
__ino_t __fastcall mmc_map(char *file, const void *a2, time_t *a3)
{
  time_t v4; // rax
  const char *v5; // rsi
  _QWORD *v6; // rbx
  int v7; // ebp
  int v8; // r14d
  int v9; // r13d
  void *v10; // rax
  _DWORD *v11; // rax
  __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 v14; // rdi
  __dev_t st_dev; // r14
  __ino_t st_ino; // r15
  __off_t st_size; // r12
  __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rsi
  __time_t tv_sec; // rbp
  int v22; // eax
  int v23; // r13d
  __ino_t *v24; // rbx
  int v25; // eax
  int *v26; // rcx
  __int64 v27; // rbp
  __ino_t *v29; // rax
  void *v30; // rax
  __ino_t v31; // r8
  __int64 v32; // rcx
  __int64 v33; // rbp
  __int64 v34; // rdi
  time_t v35; // [rsp+8h] [rbp-D0h]
  struct stat dest; // [rsp+18h] [rbp-C0h] BYREF

  if ( a2 )
  {
    memcpy(&dest, a2, sizeof(dest));
  }
  else if ( stat(file, &dest) )
  {
    v5 = "stat - %m";
LABEL_40:
    v27 = 0LL;
    syslog(3, v5);
    return v27;
  }
  if ( a3 )
    v4 = *a3;
  else
    v4 = time(0LL);
  v6 = hash_table;
  v35 = v4;
  if ( hash_table )
  {
    v7 = hash_size;
    v8 = map_count;
    if ( hash_size >= 3 * map_count )
    {
      v9 = hash_mask;
      goto LABEL_27;
    }
    free(hash_table);
    do
      v7 *= 2;
    while ( v7 < 6 * v8 );
    hash_size = v7;
    v9 = v7 - 1;
  }
  else
  {
    hash_size = 1024;
    v9 = 1023;
    v7 = 1024;
  }
  hash_mask = v9;
  v10 = malloc(8LL * v7);
  hash_table = v10;
  if ( !v10 )
  {
LABEL_25:
    v5 = "check_hash_size() failure";
    goto LABEL_40;
  }
  v6 = v10;
  if ( v7 > 0 )
    memset(v10, 0, 8LL * (unsigned int)v7);
  v11 = maps;
  if ( maps )
  {
    while ( 1 )
    {
      v12 = v9 & (v11[6] ^ (33 * (v11[4] ^ (33 * (v11[2] ^ (33 * (*v11 ^ 0x2B5A5u)))))));
      v13 = v12;
      LODWORD(v14) = v9 & (v11[6] ^ (33 * (v11[4] ^ (33 * (v11[2] ^ (33 * (*v11 ^ 0x2B5A5)))))));
      if ( v6[v12] )
        break;
LABEL_19:
      v6[v13] = v11;
      v11[14] = v12;
      v11[15] = v14;
      v11 = (_DWORD *)*((_QWORD *)v11 + 8);
      if ( !v11 )
        goto LABEL_27;
    }
    LODWORD(v14) = v12;
    while ( (_DWORD)v14 != (v9 & (v7 - 1 + (_DWORD)v12)) )
    {
      v14 = v9 & (unsigned int)(v14 + 1);
      if ( !v6[v14] )
      {
        v13 = (unsigned int)v14;
        goto LABEL_19;
      }
    }
    goto LABEL_25;
  }
LABEL_27:
  st_dev = dest.st_dev;
  st_ino = dest.st_ino;
  st_size = dest.st_size;
  v18 = v9 & ((33 * ((33 * ((33 * (LODWORD(dest.st_ino) ^ 0x2B5A5u)) ^ LODWORD(dest.st_dev))) ^ LODWORD(dest.st_size))) ^ LODWORD(dest.st_ctim.tv_sec));
  v19 = v6[v18];
  if ( !v19 )
  {
LABEL_36:
    tv_sec = dest.st_ctim.tv_sec;
    v22 = open(file, 0);
    if ( v22 < 0 )
    {
      v5 = "open - %m";
      goto LABEL_40;
    }
    v23 = v22;
    v24 = (__ino_t *)free_maps;
    if ( free_maps )
    {
      free_maps = (void *)*((_QWORD *)free_maps + 8);
      v25 = -1;
      v26 = &free_count;
    }
    else
    {
      v29 = (__ino_t *)malloc(0x48uLL);
      if ( !v29 )
      {
        close(v23);
        v5 = "out of memory allocating a Map";
        goto LABEL_40;
      }
      v24 = v29;
      v25 = 1;
      v26 = &alloc_count;
    }
    *v26 += v25;
    *v24 = st_ino;
    v24[1] = st_dev;
    v24[2] = st_size;
    v24[3] = tv_sec;
    *((_DWORD *)v24 + 8) = 1;
    v24[5] = v35;
    if ( st_size )
    {
      v30 = mmap(0LL, st_size, 1, 2, v23, 0LL);
      v24[6] = (__ino_t)v30;
      if ( v30 == (void *)-1LL )
      {
        if ( *__errno_location() == 12 )
          panic();
        v27 = 0LL;
        syslog(3, "mmap - %m");
        close(v23);
        goto LABEL_57;
      }
    }
    else
    {
      v24[6] = 1LL;
    }
    close(v23);
    v31 = v24[2];
    v32 = hash_mask & (*((_DWORD *)v24 + 6) ^ (33
                                             * ((33 * (*((_DWORD *)v24 + 2) ^ (33 * (*(_DWORD *)v24 ^ 0x2B5A5)))) ^ (unsigned int)v31)));
    v33 = v32;
    LODWORD(v34) = hash_mask & (*((_DWORD *)v24 + 6) ^ (33
                                                      * ((33 * (*((_DWORD *)v24 + 2) ^ (33 * (*(_DWORD *)v24 ^ 0x2B5A5)))) ^ v31)));
    if ( !*((_QWORD *)hash_table + v32) )
    {
LABEL_55:
      *((_QWORD *)hash_table + v33) = v24;
      *((_DWORD *)v24 + 14) = v32;
      *((_DWORD *)v24 + 15) = v34;
      v24[8] = (__ino_t)maps;
      maps = v24;
      ++map_count;
      mapped_bytes += v31;
      return v24[6];
    }
    LODWORD(v34) = v32;
    while ( (_DWORD)v34 != (hash_mask & (hash_size + (_DWORD)v32 - 1)) )
    {
      v34 = ((_DWORD)v34 + 1) & (unsigned int)hash_mask;
      if ( !*((_QWORD *)hash_table + v34) )
      {
        v33 = (unsigned int)v34;
        goto LABEL_55;
      }
    }
    v27 = 0LL;
    syslog(3, "add_hash() failure");
LABEL_57:
    free(v24);
    --alloc_count;
    return v27;
  }
  LODWORD(v20) = v9 & ((33
                      * ((33 * ((33 * (LODWORD(dest.st_ino) ^ 0x2B5A5)) ^ LODWORD(dest.st_dev))) ^ LODWORD(dest.st_size))) ^ LODWORD(dest.st_ctim.tv_sec));
  while ( *(_DWORD *)(v19 + 56) != (_DWORD)v18
       || *(_QWORD *)v19 != dest.st_ino
       || *(_QWORD *)(v19 + 8) != dest.st_dev
       || *(_QWORD *)(v19 + 16) != dest.st_size
       || *(_QWORD *)(v19 + 24) != dest.st_ctim.tv_sec )
  {
    if ( (_DWORD)v20 != (v9 & ((_DWORD)v18 + v7 - 1)) )
    {
      v20 = v9 & (unsigned int)(v20 + 1);
      v19 = v6[v20];
      if ( v19 )
        continue;
    }
    goto LABEL_36;
  }
  ++*(_DWORD *)(v19 + 32);
  *(_QWORD *)(v19 + 40) = v35;
  return *(_QWORD *)(v19 + 48);
}
// 1B4F0: using guessed type int free_count;
// 1B4F4: using guessed type int alloc_count;
// 1B500: using guessed type int map_count;
// 1B508: using guessed type __int64 mapped_bytes;
// 1B510: using guessed type int hash_size;
// 1B520: using guessed type int hash_mask;

//----- (0000000000010A60) ----------------------------------------------------
void __noreturn panic()
{
  char *v0; // rbx
  void **v1; // r15
  size_t v2; // rsi

  syslog(3, "mmc panic - freeing all unreferenced maps");
  v0 = (char *)maps;
  if ( maps )
  {
    v1 = &maps;
    do
    {
      if ( *((_DWORD *)v0 + 8) )
      {
        v1 = (void **)(v0 + 64);
      }
      else
      {
        v2 = *((_QWORD *)v0 + 2);
        if ( v2 )
        {
          if ( munmap(*((void **)v0 + 6), v2) < 0 )
            syslog(3, "munmap - %m");
        }
        mapped_bytes -= *((_QWORD *)v0 + 2);
        *v1 = (void *)*((_QWORD *)v0 + 8);
        --map_count;
        *((_QWORD *)v0 + 8) = free_maps;
        ++free_count;
        free_maps = v0;
        *((_QWORD *)hash_table + *((int *)v0 + 15)) = 0LL;
      }
      v0 = (char *)*v1;
    }
    while ( *v1 );
  }
}
// 1B4F0: using guessed type int free_count;
// 1B500: using guessed type int map_count;
// 1B508: using guessed type __int64 mapped_bytes;

//----- (0000000000010B30) ----------------------------------------------------
void __fastcall mmc_unmap(__int64 a1, __int64 *a2, time_t *a3)
{
  __int64 v3; // r10
  __int64 v4; // r11
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rsi
  _DWORD *v8; // rbx
  int v9; // eax
  int v10; // eax
  time_t v11; // rax

  if ( !a2 )
    goto LABEL_11;
  v3 = *a2;
  v4 = a2[1];
  v5 = a2[6];
  v6 = a2[13];
  v7 = hash_mask & ((33 * ((33 * ((33 * ((unsigned int)v4 ^ 0x2B5A5)) ^ (unsigned int)*a2)) ^ (unsigned int)v5)) ^ (unsigned int)v6);
  v8 = (_DWORD *)*((_QWORD *)hash_table + v7);
  if ( !v8 )
    goto LABEL_11;
  v9 = v7;
  while ( v8[14] != (_DWORD)v7
       || *(_QWORD *)v8 != v4
       || *((_QWORD *)v8 + 1) != v3
       || *((_QWORD *)v8 + 2) != v5
       || *((_QWORD *)v8 + 3) != v6 )
  {
    if ( v9 != (hash_mask & (hash_size + (_DWORD)v7 - 1)) )
    {
      v8 = (_DWORD *)*((_QWORD *)hash_table + ((v9 + 1) & (unsigned int)hash_mask));
      v9 = (v9 + 1) & hash_mask;
      if ( v8 )
        continue;
    }
    goto LABEL_11;
  }
  if ( *((_QWORD *)v8 + 6) != a1 )
  {
LABEL_11:
    v8 = maps;
    if ( !maps )
    {
LABEL_14:
      syslog(3, "mmc_unmap failed to find entry!");
      return;
    }
    while ( *((_QWORD *)v8 + 6) != a1 )
    {
      v8 = (_DWORD *)*((_QWORD *)v8 + 8);
      if ( !v8 )
        goto LABEL_14;
    }
  }
  v10 = v8[8];
  if ( v10 <= 0 )
  {
    syslog(3, "mmc_unmap found zero or negative refcount!");
  }
  else
  {
    v8[8] = v10 - 1;
    if ( a3 )
      v11 = *a3;
    else
      v11 = time(0LL);
    *((_QWORD *)v8 + 5) = v11;
  }
}
// 1B510: using guessed type int hash_size;
// 1B520: using guessed type int hash_mask;

//----- (0000000000010C70) ----------------------------------------------------
void __fastcall mmc_cleanup(time_t *a1)
{
  time_t v1; // r15
  char *v2; // rbx
  void **v3; // r12
  size_t v4; // rsi
  __int64 v5; // rcx
  _QWORD *v6; // rdi
  unsigned int v7; // ebx
  int v8; // ebp
  _QWORD *v9; // r14
  __int64 v10; // rax
  __int64 v11; // rcx

  if ( a1 )
    v1 = *a1;
  else
    v1 = time(0LL);
  v2 = (char *)maps;
  if ( maps )
  {
    v3 = &maps;
    do
    {
      if ( *((_DWORD *)v2 + 8) || v1 - *((_QWORD *)v2 + 5) < (__int64)expire_age )
      {
        v3 = (void **)(v2 + 64);
      }
      else
      {
        v4 = *((_QWORD *)v2 + 2);
        if ( v4 && munmap(*((void **)v2 + 6), v4) < 0 )
          syslog(3, "munmap - %m");
        mapped_bytes -= *((_QWORD *)v2 + 2);
        *v3 = (void *)*((_QWORD *)v2 + 8);
        --map_count;
        *((_QWORD *)v2 + 8) = free_maps;
        ++free_count;
        free_maps = v2;
        *((_QWORD *)hash_table + *((int *)v2 + 15)) = 0LL;
      }
      v2 = (char *)*v3;
    }
    while ( *v3 );
  }
  if ( mapped_bytes >= 1000000001 || map_count >= 1001 )
  {
    v5 = 60LL;
    if ( (__int64)expire_age >= 92 )
      v5 = 2 * (__int64)expire_age / 3;
LABEL_18:
    expire_age = (__int64 *)v5;
    goto LABEL_19;
  }
  if ( map_count <= 499 )
  {
    v10 = 5LL * (_QWORD)expire_age;
    v5 = 1800LL;
    if ( 5 * (__int64)expire_age <= 7199 )
    {
      v11 = v10 + 3;
      if ( v10 >= 0 )
        v11 = 5LL * (_QWORD)expire_age;
      v5 = v11 >> 2;
    }
    goto LABEL_18;
  }
LABEL_19:
  if ( free_count >= 101 )
  {
    v6 = free_maps;
    v7 = free_count + 1;
    v8 = alloc_count - 1;
    do
    {
      free_maps = (void *)v6[8];
      v9 = free_maps;
      free_count = v7 - 2;
      free(v6);
      alloc_count = v8;
      --v7;
      --v8;
      v6 = v9;
    }
    while ( v7 > 0x65 );
  }
}
// 1AC80: using guessed type __int64 *expire_age;
// 1B4F0: using guessed type int free_count;
// 1B4F4: using guessed type int alloc_count;
// 1B500: using guessed type int map_count;
// 1B508: using guessed type __int64 mapped_bytes;

//----- (0000000000010E30) ----------------------------------------------------
void mmc_term()
{
  int *v0; // rax
  void *v1; // rax
  int v2; // ebp
  int *v3; // r15
  size_t v4; // rsi
  int v5; // ebp
  int v6; // ebx
  int *v7; // r14

  v0 = (int *)maps;
  if ( maps )
  {
    do
    {
      v3 = v0;
      v4 = *((_QWORD *)v0 + 2);
      if ( v4 && munmap(*((void **)v0 + 6), v4) < 0 )
        syslog(3, "munmap - %m");
      mapped_bytes -= *((_QWORD *)v3 + 2);
      v1 = (void *)*((_QWORD *)v3 + 8);
      --map_count;
      maps = v1;
      *((_QWORD *)v3 + 8) = free_maps;
      free_maps = v3;
      v2 = ++free_count;
      *((_QWORD *)hash_table + v3[15]) = 0LL;
      v0 = (int *)maps;
    }
    while ( maps );
  }
  else
  {
    v3 = (int *)free_maps;
    if ( !free_maps )
      return;
    v2 = free_count;
  }
  v5 = v2 - 1;
  v6 = alloc_count - 1;
  do
  {
    free_maps = (void *)*((_QWORD *)v3 + 8);
    v7 = (int *)free_maps;
    free_count = v5;
    free(v3);
    alloc_count = v6;
    --v5;
    --v6;
    v3 = v7;
  }
  while ( v7 );
}
// 1B4F0: using guessed type int free_count;
// 1B4F4: using guessed type int alloc_count;
// 1B500: using guessed type int map_count;
// 1B508: using guessed type __int64 mapped_bytes;

//----- (0000000000010F40) ----------------------------------------------------
void mmc_logstats()
{
  syslog(
    5,
    "  map cache - %d allocated, %d active (%lld bytes), %d free; hash size: %d; expire age: %lld",
    (unsigned int)alloc_count,
    (unsigned int)map_count,
    mapped_bytes,
    (unsigned int)free_count,
    (unsigned int)hash_size,
    expire_age);
  if ( map_count + free_count != alloc_count )
    syslog(3, "map counts don't add up!");
}
// 1AC80: using guessed type __int64 *expire_age;
// 1B4F0: using guessed type int free_count;
// 1B4F4: using guessed type int alloc_count;
// 1B500: using guessed type int map_count;
// 1B508: using guessed type __int64 mapped_bytes;
// 1B510: using guessed type int hash_size;

//----- (0000000000010FB0) ----------------------------------------------------
void tmr_init()
{
  memset(timers, 0, sizeof(timers));
  free_timers = 0LL;
  free_count_0 = 0;
  active_count = 0;
  alloc_count_0 = 0;
}
// 1B530: using guessed type _QWORD timers[67];
// 1B750: using guessed type int free_count_0;
// 1B754: using guessed type int active_count;
// 1B758: using guessed type int alloc_count_0;

//----- (0000000000010FF0) ----------------------------------------------------
struct timeval *__fastcall tmr_create(struct timeval *a1, __time_t a2, __suseconds_t a3, __time_t a4, int a5)
{
  struct timeval *v9; // rbx
  int v10; // eax
  int *v11; // rcx
  struct timeval *v12; // rax
  struct timeval *v13; // rdi
  __int64 v14; // rcx
  __int64 v15; // rsi
  __int64 v16; // rdx
  _QWORD *v17; // rax
  _QWORD *v18; // rdx
  __int64 v19; // rbp
  _QWORD *v20; // rdi

  v9 = (struct timeval *)free_timers;
  if ( free_timers )
  {
    free_timers = (void *)*((_QWORD *)free_timers + 7);
    v10 = -1;
    v11 = &free_count_0;
  }
  else
  {
    v12 = (struct timeval *)malloc(0x48uLL);
    if ( !v12 )
      return 0LL;
    v9 = v12;
    v10 = 1;
    v11 = &alloc_count_0;
  }
  *v11 += v10;
  v9->tv_sec = a2;
  v9->tv_usec = a3;
  v9[1].tv_sec = a4;
  LODWORD(v9[1].tv_usec) = a5;
  v13 = v9 + 2;
  if ( a1 )
    *v13 = *a1;
  else
    gettimeofday(v13, 0LL);
  v14 = v9[2].tv_sec + a4 / 1000;
  v9[2].tv_sec = v14;
  v15 = v9[2].tv_usec + 1000 * (a4 % 1000);
  v9[2].tv_usec = v15;
  if ( v15 >= 1000000 )
  {
    v14 += v15 / 0xF4240uLL;
    v9[2].tv_sec = v14;
    v15 %= 0xF4240uLL;
    v9[2].tv_usec = v15;
  }
  v16 = ((unsigned int)v14 ^ (unsigned int)v15) % 0x43;
  LODWORD(v9[4].tv_sec) = v16;
  v17 = (_QWORD *)timers[v16];
  if ( v17 )
  {
    if ( v14 < v17[4] || v14 == v17[4] && v15 <= v17[5] )
    {
      timers[v16] = v9;
      v9[3].tv_sec = 0LL;
      v9[3].tv_usec = (__suseconds_t)v17;
      v17[6] = v9;
    }
    else
    {
      v18 = (_QWORD *)v17[7];
      if ( v18 )
      {
        v19 = v18[4];
        if ( v14 >= v19 )
        {
          while ( 1 )
          {
            v20 = v18;
            if ( v14 == v19 && v15 <= v18[5] )
              break;
            v18 = (_QWORD *)v18[7];
            if ( !v18 )
            {
              v17 = v20;
              goto LABEL_26;
            }
            v19 = v18[4];
            v17 = v20;
            if ( v14 < v19 )
              goto LABEL_23;
          }
        }
        v20 = v17;
LABEL_23:
        v20[7] = v9;
        v9[3].tv_sec = (__time_t)v20;
        v9[3].tv_usec = (__suseconds_t)v18;
        v18[6] = v9;
      }
      else
      {
LABEL_26:
        v17[7] = v9;
        v9[3].tv_sec = (__time_t)v17;
        v9[3].tv_usec = 0LL;
      }
    }
  }
  else
  {
    timers[v16] = v9;
    v9[3] = 0LL;
  }
  ++active_count;
  return v9;
}
// 1B530: using guessed type _QWORD timers[67];
// 1B750: using guessed type int free_count_0;
// 1B754: using guessed type int active_count;
// 1B758: using guessed type int alloc_count_0;

//----- (00000000000111E0) ----------------------------------------------------
__int64 *__fastcall tmr_timeout(_QWORD *a1)
{
  __int64 v1; // rsi
  __int64 v2; // r11
  int v3; // r10d
  __int64 v4; // rax
  __int64 *result; // rax
  __int64 v6; // rdi

  v1 = 0LL;
  v2 = 0LL;
  v3 = 0;
  do
  {
    v4 = timers[v1];
    if ( v4 )
    {
      if ( v3 )
      {
        if ( 1000LL * (*(_QWORD *)(v4 + 32) - *a1) + (*(_QWORD *)(v4 + 40) - a1[1]) / 1000LL < v2 )
          v2 = 1000LL * (*(_QWORD *)(v4 + 32) - *a1) + (*(_QWORD *)(v4 + 40) - a1[1]) / 1000LL;
        v3 = 1;
      }
      else
      {
        v3 = 1;
        v2 = 1000LL * (*(_QWORD *)(v4 + 32) - *a1) + (*(_QWORD *)(v4 + 40) - a1[1]) / 1000LL;
      }
    }
    ++v1;
  }
  while ( v1 != 67 );
  result = 0LL;
  if ( v2 < 0 )
    v2 = 0LL;
  if ( v3 )
  {
    v6 = v2 | -(__int64)(v3 == 0);
    tmr_timeout_timeout = v6 / 1000;
    result = &tmr_timeout_timeout;
    qword_1B768 = 1000 * (v6 % 1000);
  }
  return result;
}
// 1B530: using guessed type _QWORD timers[67];
// 1B760: using guessed type __int64 tmr_timeout_timeout;
// 1B768: using guessed type __int64 qword_1B768;

//----- (00000000000112B0) ----------------------------------------------------
__int64 __fastcall tmr_mstimeout(_QWORD *a1)
{
  __int64 v1; // rcx
  __int64 v2; // r11
  int v3; // r10d
  __int64 v4; // rax
  __int64 v5; // rcx

  v1 = 0LL;
  v2 = 0LL;
  v3 = 0;
  do
  {
    v4 = timers[v1];
    if ( v4 )
    {
      if ( v3 )
      {
        if ( 1000LL * (*(_QWORD *)(v4 + 32) - *a1) + (*(_QWORD *)(v4 + 40) - a1[1]) / 1000LL < v2 )
          v2 = 1000LL * (*(_QWORD *)(v4 + 32) - *a1) + (*(_QWORD *)(v4 + 40) - a1[1]) / 1000LL;
        v3 = 1;
      }
      else
      {
        v3 = 1;
        v2 = 1000LL * (*(_QWORD *)(v4 + 32) - *a1) + (*(_QWORD *)(v4 + 40) - a1[1]) / 1000LL;
      }
    }
    ++v1;
  }
  while ( v1 != 67 );
  v5 = 0LL;
  if ( v2 >= 0 )
    v5 = v2;
  return v5 | -(__int64)(v3 == 0);
}
// 1B530: using guessed type _QWORD timers[67];

//----- (0000000000011350) ----------------------------------------------------
_QWORD *__fastcall tmr_run(__int64 a1)
{
  __int64 i; // r15
  _QWORD *result; // rax
  __int64 v3; // rbx
  __int64 v4; // r12
  __int64 v5; // rsi
  __int64 v6; // rcx
  __int64 v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rcx

  for ( i = 0LL; i != 67; ++i )
  {
    result = timers;
    v3 = timers[i];
    if ( v3 )
    {
      while ( 1 )
      {
        result = *(_QWORD **)a1;
        if ( *(_QWORD *)(v3 + 32) > *(_QWORD *)a1 )
          goto LABEL_2;
        v4 = *(_QWORD *)(v3 + 56);
        if ( *(_QWORD *)(v3 + 32) == *(_QWORD *)a1 )
        {
          result = *(_QWORD **)(v3 + 40);
          if ( (__int64)result > *(_QWORD *)(a1 + 8) )
            goto LABEL_2;
        }
        (*(void (__fastcall **)(_QWORD, __int64))v3)(*(_QWORD *)(v3 + 8), a1);
        if ( *(_DWORD *)(v3 + 24) )
        {
          v5 = *(_QWORD *)(v3 + 16);
          v6 = *(_QWORD *)(v3 + 32) + v5 / 1000;
          *(_QWORD *)(v3 + 32) = v6;
          v7 = *(_QWORD *)(v3 + 40) + 1000 * (v5 % 1000);
          *(_QWORD *)(v3 + 40) = v7;
          if ( v7 >= 1000000 )
          {
            *(_QWORD *)(v3 + 32) = v7 / 0xF4240uLL + v6;
            *(_QWORD *)(v3 + 40) = v7 % 0xF4240uLL;
          }
          result = l_resort(v3);
          goto LABEL_6;
        }
        v8 = *(_QWORD *)(v3 + 48);
        if ( !v8 )
          break;
        *(_QWORD *)(v8 + 56) = *(_QWORD *)(v3 + 56);
        v9 = *(_QWORD *)(v3 + 56);
        if ( v9 )
          goto LABEL_15;
LABEL_16:
        --active_count;
        result = free_timers;
        *(_QWORD *)(v3 + 56) = free_timers;
        free_timers = (void *)v3;
        ++free_count_0;
        *(_QWORD *)(v3 + 48) = 0LL;
LABEL_6:
        v3 = v4;
        if ( !v4 )
          goto LABEL_2;
      }
      v9 = *(_QWORD *)(v3 + 56);
      timers[*(int *)(v3 + 64)] = v9;
      if ( !v9 )
        goto LABEL_16;
LABEL_15:
      *(_QWORD *)(v9 + 48) = v8;
      goto LABEL_16;
    }
LABEL_2:
    ;
  }
  return result;
}
// 1B530: using guessed type _QWORD timers[67];
// 1B750: using guessed type int free_count_0;
// 1B754: using guessed type int active_count;

//----- (00000000000114D0) ----------------------------------------------------
_QWORD *__fastcall l_resort(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  _QWORD *v3; // r9
  __int64 v4; // r8
  __int64 v5; // rsi
  _QWORD *result; // rax
  _QWORD *v7; // rdx
  _QWORD *v8; // rsi
  _QWORD *v9; // rcx

  v1 = *(_QWORD *)(a1 + 48);
  if ( v1 )
  {
    *(_QWORD *)(v1 + 56) = *(_QWORD *)(a1 + 56);
    v2 = *(_QWORD *)(a1 + 56);
    if ( !v2 )
      goto LABEL_4;
    goto LABEL_3;
  }
  v2 = *(_QWORD *)(a1 + 56);
  timers[*(int *)(a1 + 64)] = v2;
  if ( v2 )
LABEL_3:
    *(_QWORD *)(v2 + 48) = v1;
LABEL_4:
  v3 = *(_QWORD **)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  v5 = ((unsigned int)v3 ^ (unsigned int)v4) % 0x43;
  *(_DWORD *)(a1 + 64) = v5;
  result = timers;
  v7 = (_QWORD *)timers[v5];
  if ( v7 )
  {
    if ( (__int64)v3 < v7[4] || v3 == (_QWORD *)v7[4] && v4 <= v7[5] )
    {
      timers[v5] = a1;
      *(_QWORD *)(a1 + 48) = 0LL;
      *(_QWORD *)(a1 + 56) = v7;
      v7[6] = a1;
    }
    else
    {
      v8 = (_QWORD *)v7[7];
      if ( v8 )
      {
        result = (_QWORD *)v8[4];
        if ( (__int64)v3 >= (__int64)result )
        {
          while ( 1 )
          {
            v9 = v8;
            if ( v3 == result && v4 <= v8[5] )
              break;
            v8 = (_QWORD *)v8[7];
            if ( !v8 )
            {
              v7 = v9;
              goto LABEL_21;
            }
            result = (_QWORD *)v8[4];
            v7 = v9;
            if ( (__int64)v3 < (__int64)result )
              goto LABEL_19;
          }
        }
        v9 = v7;
LABEL_19:
        v9[7] = a1;
        *(_QWORD *)(a1 + 48) = v9;
        *(_QWORD *)(a1 + 56) = v8;
        v8[6] = a1;
      }
      else
      {
LABEL_21:
        v7[7] = a1;
        *(_QWORD *)(a1 + 48) = v7;
        *(_QWORD *)(a1 + 56) = 0LL;
      }
    }
  }
  else
  {
    timers[v5] = a1;
    *(_OWORD *)(a1 + 48) = 0LL;
  }
  return result;
}
// 1B530: using guessed type _QWORD timers[67];

//----- (00000000000115E0) ----------------------------------------------------
void *__fastcall tmr_cancel(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  void *result; // rax

  v1 = *(_QWORD *)(a1 + 48);
  if ( !v1 )
  {
    v2 = *(_QWORD *)(a1 + 56);
    timers[*(int *)(a1 + 64)] = v2;
    if ( !v2 )
      goto LABEL_4;
    goto LABEL_3;
  }
  *(_QWORD *)(v1 + 56) = *(_QWORD *)(a1 + 56);
  v2 = *(_QWORD *)(a1 + 56);
  if ( v2 )
LABEL_3:
    *(_QWORD *)(v2 + 48) = v1;
LABEL_4:
  --active_count;
  result = free_timers;
  *(_QWORD *)(a1 + 56) = free_timers;
  free_timers = (void *)a1;
  ++free_count_0;
  *(_QWORD *)(a1 + 48) = 0LL;
  return result;
}
// 1B530: using guessed type _QWORD timers[67];
// 1B750: using guessed type int free_count_0;
// 1B754: using guessed type int active_count;

//----- (0000000000011650) ----------------------------------------------------
_QWORD *__fastcall tmr_reset(_OWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rcx
  __int64 v4; // rdi

  *(_OWORD *)(a2 + 32) = *a1;
  v2 = *(_QWORD *)(a2 + 16);
  v3 = *(_QWORD *)(a2 + 32) + v2 / 1000;
  *(_QWORD *)(a2 + 32) = v3;
  v4 = *(_QWORD *)(a2 + 40) + 1000 * (v2 % 1000);
  *(_QWORD *)(a2 + 40) = v4;
  if ( v4 >= 1000000 )
  {
    *(_QWORD *)(a2 + 32) = v4 / 0xF4240uLL + v3;
    *(_QWORD *)(a2 + 40) = v4 % 0xF4240uLL;
  }
  return l_resort(a2);
}

//----- (00000000000116E0) ----------------------------------------------------
void tmr_cleanup()
{
  _QWORD *v0; // rdi
  int v1; // ebp
  int v2; // ebx
  _QWORD *v3; // r14

  v0 = free_timers;
  if ( free_timers )
  {
    v1 = free_count_0 - 1;
    v2 = alloc_count_0 - 1;
    do
    {
      free_timers = (void *)v0[7];
      v3 = free_timers;
      free_count_0 = v1;
      free(v0);
      alloc_count_0 = v2;
      --v1;
      --v2;
      v0 = v3;
    }
    while ( v3 );
  }
}
// 1B750: using guessed type int free_count_0;
// 1B758: using guessed type int alloc_count_0;

//----- (0000000000011740) ----------------------------------------------------
void tmr_term()
{
  int v0; // eax
  _QWORD *v1; // rdi
  int v2; // ebx
  __int64 i; // r9
  __int64 v4; // rsi
  _QWORD *v5; // rdx
  __int64 v6; // rbp
  __int64 v7; // rsi
  __int64 v8; // rcx
  int v9; // ebx
  int v10; // ebp
  _QWORD *v11; // r14

  v0 = active_count;
  v1 = free_timers;
  v2 = free_count_0;
  for ( i = 0LL; i != 67; ++i )
  {
    v4 = timers[i];
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = (_QWORD *)v4;
        v6 = *(_QWORD *)(v4 + 48);
        if ( v6 )
          break;
        v8 = *(int *)(v4 + 64);
        v7 = *(_QWORD *)(v4 + 56);
        timers[v8] = v7;
        if ( v7 )
          goto LABEL_11;
LABEL_6:
        --v0;
        v5[7] = v1;
        ++v2;
        v5[6] = 0LL;
        v4 = timers[i];
        v1 = v5;
        if ( !v4 )
        {
          active_count = v0;
          free_timers = v5;
          free_count_0 = v2;
          v1 = v5;
          goto LABEL_3;
        }
      }
      *(_QWORD *)(v6 + 56) = *(_QWORD *)(v4 + 56);
      v7 = *(_QWORD *)(v4 + 56);
      if ( !v7 )
        goto LABEL_6;
LABEL_11:
      *(_QWORD *)(v7 + 48) = v6;
      goto LABEL_6;
    }
LABEL_3:
    ;
  }
  if ( v1 )
  {
    v9 = v2 - 1;
    v10 = alloc_count_0 - 1;
    do
    {
      free_timers = (void *)v1[7];
      v11 = free_timers;
      free_count_0 = v9;
      free(v1);
      alloc_count_0 = v10;
      --v9;
      --v10;
      v1 = v11;
    }
    while ( v11 );
  }
}
// 1B530: using guessed type _QWORD timers[67];
// 1B750: using guessed type int free_count_0;
// 1B754: using guessed type int active_count;
// 1B758: using guessed type int alloc_count_0;

//----- (0000000000011840) ----------------------------------------------------
void tmr_logstats()
{
  syslog(
    5,
    "  timers - %d allocated, %d active, %d free",
    (unsigned int)alloc_count_0,
    (unsigned int)active_count,
    (unsigned int)free_count_0);
  if ( active_count + free_count_0 != alloc_count_0 )
    syslog(3, "timer counts don't add up!");
}
// 1B750: using guessed type int free_count_0;
// 1B754: using guessed type int active_count;
// 1B758: using guessed type int alloc_count_0;

//----- (00000000000118A0) ----------------------------------------------------
__int64 __fastcall match(char *s, _BYTE *a2)
{
  const char *v2; // rbx
  char *v3; // rax
  char *v4; // r15
  int v5; // eax

  v2 = s;
  v3 = strchr(s, 124);
  if ( v3 )
  {
    v4 = v3;
    while ( !(unsigned int)match_one((__int64)v2, (int)v4 - (int)v2, a2) )
    {
      v2 = v4 + 1;
      v4 = strchr(v4 + 1, 124);
      if ( !v4 )
        goto LABEL_5;
    }
    return 1LL;
  }
  else
  {
LABEL_5:
    v5 = strlen(v2);
    return match_one((__int64)v2, v5, a2);
  }
}

//----- (0000000000011920) ----------------------------------------------------
__int64 __fastcall match_one(__int64 a1, int a2, _BYTE *a3)
{
  _BYTE *v3; // r15
  __int64 v5; // rcx
  _BYTE *v6; // rsi
  _BYTE *v7; // rbx
  __int64 v8; // rdx
  char v9; // al
  unsigned int v10; // r13d
  const char *v12; // r15
  int v13; // eax
  __int64 v14; // rbp

  v3 = a3;
  if ( a2 <= 0 )
    return *v3 == 0;
  v5 = a2;
  v6 = &a3[a2];
  v7 = (_BYTE *)(a1 + 1);
  v8 = 0LL;
  while ( 1 )
  {
    v9 = *(v7 - 1);
    if ( v9 != 63 )
      break;
    if ( !v3[v8] )
      return 0;
LABEL_4:
    ++v7;
    if ( ++v8 >= v5 )
    {
      v3 = v6;
      return *v3 == 0;
    }
  }
  if ( v9 != 42 )
  {
    if ( v9 != v3[v8] )
      return 0;
    goto LABEL_4;
  }
  v12 = &v3[v8];
  if ( *v7 == 42 )
  {
    ++v7;
    v13 = strlen(v12);
  }
  else
  {
    v13 = strcspn(v12, "/");
  }
  v10 = 0;
  if ( v13 >= 0 )
  {
    v14 = (unsigned int)v13;
    while ( !(unsigned int)match_one(v7, (unsigned int)(a2 + a1 - (_DWORD)v7), &v12[v14]) )
    {
      if ( v14-- <= 0 )
        return v10;
    }
    return 1;
  }
  return v10;
}

//----- (0000000000011A10) ----------------------------------------------------
__int64 __fastcall tdate_parse(_BYTE *a1)
{
  int v2; // eax
  __int64 v3; // rbx
  int v4; // edi
  int v5; // ecx
  __int64 v6; // rbp
  int v8; // [rsp+Ch] [rbp-44Ch] BYREF
  int v9; // [rsp+10h] [rbp-448h] BYREF
  int v10; // [rsp+14h] [rbp-444h] BYREF
  __int64 v11; // [rsp+18h] [rbp-440h] BYREF
  int v12; // [rsp+20h] [rbp-438h] BYREF
  int v13; // [rsp+24h] [rbp-434h] BYREF
  __int64 v14; // [rsp+28h] [rbp-430h] BYREF
  char s1[512]; // [rsp+30h] [rbp-428h] BYREF
  char v16[552]; // [rsp+230h] [rbp-228h] BYREF

  while ( *a1 == 32 || *a1 == 9 )
    ++a1;
  if ( (unsigned int)__isoc99_sscanf(a1, "%d-%400[a-zA-Z]-%d %d:%d:%d GMT", &v8, s1, &v10, &v9, &v12, &v13) == 6
    && (unsigned int)scan_mon(s1, &v11)
    || (unsigned int)__isoc99_sscanf(a1, "%d %400[a-zA-Z] %d %d:%d:%d GMT", &v8, s1, &v10, &v9, &v12, &v13) == 6
    && (unsigned int)scan_mon(s1, &v11)
    || (unsigned int)__isoc99_sscanf(a1, "%d:%d:%d GMT %d-%400[a-zA-Z]-%d", &v9, &v12, &v13, &v8, s1, &v10) == 6
    && (unsigned int)scan_mon(s1, &v11)
    || (unsigned int)__isoc99_sscanf(a1, "%d:%d:%d GMT %d %400[a-zA-Z] %d", &v9, &v12, &v13, &v8, s1, &v10) == 6
    && (unsigned int)scan_mon(s1, &v11)
    || (unsigned int)__isoc99_sscanf(
                       a1,
                       "%400[a-zA-Z], %d-%400[a-zA-Z]-%d %d:%d:%d GMT",
                       v16,
                       &v8,
                       s1,
                       &v10,
                       &v9,
                       &v12,
                       &v13) == 7
    && (unsigned int)scan_wday(v16, &v14)
    && (unsigned int)scan_mon(s1, &v11)
    || (unsigned int)__isoc99_sscanf(
                       a1,
                       "%400[a-zA-Z], %d %400[a-zA-Z] %d %d:%d:%d GMT",
                       v16,
                       &v8,
                       s1,
                       &v10,
                       &v9,
                       &v12,
                       &v13) == 7
    && (unsigned int)scan_wday(v16, &v14)
    && (unsigned int)scan_mon(s1, &v11)
    || (v2 = __isoc99_sscanf(a1, "%400[a-zA-Z] %400[a-zA-Z] %d %d:%d:%d GMT %d", v16, s1, &v8, &v9, &v12, &v13, &v10),
        v3 = -1LL,
        v2 == 7)
    && (unsigned int)scan_wday(v16, &v14)
    && (unsigned int)scan_mon(s1, &v11) )
  {
    v4 = v10 + 100;
    if ( v10 >= 70 )
      v4 = v10;
    if ( v10 >= 1901 )
      v4 = v10 - 1900;
    v5 = v4 - 66;
    if ( v4 - 69 >= 0 )
      v5 = v4 - 69;
    v6 = 365 * v4 - 25550 + (__int64)(v5 >> 2) + tm_to_time_monthtab[(int)v11];
    if ( (int)v11 >= 2
      && (__ROR4__(-1030792151 * (v4 + 1900) + 85899344, 4) <= 0xA3D70Au
       || __ROR4__(-1030792151 * (v4 + 1900) + 85899344, 2) >= 0x28F5C29u && (v4 & 3) == 0) )
    {
      ++v6;
    }
    return 60 * (v12 + 60 * (v9 + 24 * (v6 + v8))) + v13 - 86400;
  }
  return v3;
}
// 5470: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);
// 15990: using guessed type int tm_to_time_monthtab[12];

//----- (0000000000011DA0) ----------------------------------------------------
__int64 __fastcall scan_mon(char *s1, _QWORD *a2)
{
  __int64 v2; // rbx
  const unsigned __int16 **v3; // r12
  char *v4; // rbp
  int v5; // ebx
  int v6; // r13d
  int v7; // ebp
  __int64 v8; // r14
  int v9; // eax

  if ( !scan_mon_sorted )
  {
    qsort(&scan_mon_mon_tab, 0x17uLL, 0x10uLL, (__compar_fn_t)strlong_compare);
    scan_mon_sorted = 1;
  }
  LOBYTE(v2) = *s1;
  if ( *s1 )
  {
    v3 = __ctype_b_loc();
    v4 = s1 + 1;
    do
    {
      v2 = (char)v2;
      if ( ((*v3)[(char)v2] & 0x100) != 0 )
        *(v4 - 1) = (*__ctype_tolower_loc())[v2];
      LOBYTE(v2) = *v4++;
    }
    while ( (_BYTE)v2 );
  }
  v5 = 0;
  v6 = 22;
  while ( 1 )
  {
    while ( 1 )
    {
      v7 = (v5 + v6) / 2;
      v8 = 2LL * v7;
      v9 = strcmp(s1, (&scan_mon_mon_tab)[v8]);
      if ( v9 >= 0 )
        break;
      v6 = v7 - 1;
      if ( v7 - 1 < v5 )
        return 0LL;
    }
    if ( !v9 )
      break;
    v5 = v7 + 1;
    if ( v6 < v7 + 1 )
      return 0LL;
  }
  *a2 = (&scan_mon_mon_tab)[v8 + 1];
  return 1LL;
}
// 1AC90: using guessed type char *scan_mon_mon_tab;
// 1B778: using guessed type char scan_mon_sorted;

//----- (0000000000011EA0) ----------------------------------------------------
__int64 __fastcall scan_wday(char *s1, _QWORD *a2)
{
  __int64 v2; // rbx
  const unsigned __int16 **v3; // r12
  char *v4; // rbp
  int v5; // ebx
  int v6; // r13d
  int v7; // ebp
  __int64 v8; // r14
  int v9; // eax

  if ( !scan_wday_sorted )
  {
    qsort(&scan_wday_wday_tab, 0xEuLL, 0x10uLL, (__compar_fn_t)strlong_compare);
    scan_wday_sorted = 1;
  }
  LOBYTE(v2) = *s1;
  if ( *s1 )
  {
    v3 = __ctype_b_loc();
    v4 = s1 + 1;
    do
    {
      v2 = (char)v2;
      if ( ((*v3)[(char)v2] & 0x100) != 0 )
        *(v4 - 1) = (*__ctype_tolower_loc())[v2];
      LOBYTE(v2) = *v4++;
    }
    while ( (_BYTE)v2 );
  }
  v5 = 0;
  v6 = 13;
  while ( 1 )
  {
    while ( 1 )
    {
      v7 = (v5 + v6) / 2;
      v8 = 2LL * v7;
      v9 = strcmp(s1, (&scan_wday_wday_tab)[v8]);
      if ( v9 >= 0 )
        break;
      v6 = v7 - 1;
      if ( v7 - 1 < v5 )
        return 0LL;
    }
    if ( !v9 )
      break;
    v5 = v7 + 1;
    if ( v6 < v7 + 1 )
      return 0LL;
  }
  *a2 = (&scan_wday_wday_tab)[v8 + 1];
  return 1LL;
}
// 1AE00: using guessed type char *scan_wday_wday_tab;
// 1B77C: using guessed type char scan_wday_sorted;

//----- (0000000000011FA0) ----------------------------------------------------
int __fastcall strlong_compare(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (0000000000011FAC) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=320 queued=94 decompiled=94 lumina nreq=0 worse=0 better=0
// ALL OK, 94 function(s) have been successfully decompiled

